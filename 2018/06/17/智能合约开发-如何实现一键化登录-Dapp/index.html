<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 智能合约开发 - 如何实现一键化登录 Dapp · 程序化思维</title><meta name="description" content="智能合约开发 - 如何实现一键化登录 Dapp - facert"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://facert.github.io/atom.xml" title="程序化思维"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/facert" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">智能合约开发 - 如何实现一键化登录 Dapp</h1><div class="post-info">Jun 17, 2018</div><div class="post-content"><p>任何有帐户体系的网站和 app 都会有自己的登录模块，有时候还会集成 oauth2 （weibo, weixin，github)一键化登录.开发者肯定也都或多或少的开发过注册，登录的功能。那么基于以太坊的 Dapp 中登录功能会有什么区别呢？本文主要介绍了 Dapp 帐号体系的构成，以及如何基于 Metamask 开发一键化登录的功能。</p>
<a id="more"></a>
<p>首先 Dapp 跟普通的网站(app)没多少区别，完全可以延续之前的帐号体系登录，注册。在需要用到以太坊区块链的时候（比如创建交易，支付等）调用钱包或者 MetaMask 插件即可。</p>
<p>当然本身以太坊就有自己的帐号，每个人都可以创建 Address 来和区块链交互，所以如果我们的 Dapp 跟 Address 能够绑定并实现登录的话，整体的体验会好很多。</p>
<p>解决方案是利用私钥对 payload 加密生成 signature，然后再用<br>ecdsa_recover 方法对 signature 解密可以拿到对应的公钥。</p>
<p><img src="/media/15292352605816.gif" alt=""></p>
<p>我们来看下具体的步骤 （默认已经安装 MetaMask）</p>
<p>（1）前端点击登录按钮，首先通过 <code>web3.eth.accounts[0]</code> 拿到 publicAddress，然后去后端拿 nonce </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/user&apos;, &#123;address&#125;)</span><br></pre></td></tr></table></figure>
<p>（2）后端拿到 address 后，会去数据库查询是否存在这个用户，如果有，则直接返回跟 address 对应的 nonce。没有的话，会执行一个注册用户的过程，同样返回 nonce。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Profile(models.Model):</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">    public_address = models.CharField(max_length=256)</span><br><span class="line">    nonce = models.IntegerField()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def user()</span><br><span class="line">    public_address = boby.get(&quot;address&quot;)</span><br><span class="line">    profiles = Profile.objects.filter(public_address=public_address.lower())</span><br><span class="line">    </span><br><span class="line">    if not profiles.exists():</span><br><span class="line">        user = User.objects.create(username=public_address.lower())</span><br><span class="line">        profile = Profile.objects.create(user=user, public_address=public_address.lower(), nonce=generate_nonce())</span><br><span class="line">    else:</span><br><span class="line">        profile = profiles[0]</span><br><span class="line">    return profile</span><br></pre></td></tr></table></figure>
<p>(3) 前端拿到 nonce 之后会去找 MetaMask 签名生成 signature</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.personal.sign(nonce, public_address, callback);</span><br></pre></td></tr></table></figure>
<p>(4) 最后拿 signature 和 address 到后端验证是否签名正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/login&apos;, &#123;address, signature&#125;);</span><br></pre></td></tr></table></figure>
<p>(5) 后端验证，验证成功则完成登录（基于 session 或 jwt）操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message_hash = defunct_hash_message(text=&quot;signature nonce:%s&quot; % profile.nonce)</span><br><span class="line">recover_address = w3.eth.account.recoverHash(message_hash, signature=signature)</span><br><span class="line">if recover_address and recover_address.lower() == public_address:</span><br><span class="line">    user_login(request, profile.user)</span><br></pre></td></tr></table></figure>
<p>这里面的 recoverHash 函数是 python web3.py 模块的。由于以太坊的椭圆曲线加密函数签名参数与比特币不太一样，所以如果用其他椭圆加解密包没法验证通过的话，可查看是不是参数设置不同。</p>
<p>(6) 登录成功后，前后端交互就跟普通 http 请求没什么区别了。</p>
<p><img src="/media/15292413044056.jpg" alt=""></p>
<p>借用一张图来说明登录流程 （challenge 跟上文的 nonce 一致）</p>
<p>最后，我们其实可以看到目前这个登录方式强依赖于 MetaMask 插件，对于手机端 App 是无效的，需要有专门的钱包 app 来完成签名等功能。不过可以展望下，如果 Dapp 越来越多，那么这些基础插件会越来越丰富和完善。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial" target="_blank" rel="noopener">https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial</a></li>
<li><a href="https://github.com/amaurymartiny/login-with-metamask-demo" target="_blank" rel="noopener">https://github.com/amaurymartiny/login-with-metamask-demo</a></li>
<li><a href="https://github.com/m0t0k1ch1/metamask-login-sample" target="_blank" rel="noopener">https://github.com/m0t0k1ch1/metamask-login-sample</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/17/智能合约开发-如何更好的与合约交互/" class="prev">PREV</a><a href="/2018/04/06/智能合约调试指南/" class="next">NEXT</a></div><div class="copyright"><p>© 2021 <a href="https://facert.github.io">facert</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>