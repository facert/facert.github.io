<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> django 安全之防御 csrf · 程序化思维</title><meta name="description" content="django 安全之防御 csrf - facert"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://facert.github.io/atom.xml" title="程序化思维"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/facert" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">django 安全之防御 csrf</h1><div class="post-info">Dec 9, 2016</div><div class="post-content"><h4 id="本文主要通过分析-django-源码-介绍-django-在-csrf-跨站请求伪造-的防御措施，-默认大家对-csrf-有一定的了解"><a href="#本文主要通过分析-django-源码-介绍-django-在-csrf-跨站请求伪造-的防御措施，-默认大家对-csrf-有一定的了解" class="headerlink" title="本文主要通过分析 django 源码 介绍 django 在 csrf (跨站请求伪造) 的防御措施， 默认大家对 csrf 有一定的了解"></a>本文主要通过分析 django 源码 介绍 django 在 csrf (跨站请求伪造) 的防御措施， 默认大家对 csrf 有一定的了解</h4><a id="more"></a>
<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>一般问到如何防御 csrf, 很多人都会给这么个答案，请求的时候带一个 token，到服务器验证 token 的有效性。原理是没错，但是如果让你设计这个防御系统，需要考虑哪些呢，我觉得有这么几点</p>
<ul>
<li>token 如何存储</li>
<li>token 如何验证</li>
<li>token 何时刷新</li>
</ul>
<p>存储和验证相关联，有这么一种做法，每次用户登录生成随机值，存在数据库或者缓存中，请求的时候带上 token，每次去查询 token 有效性，这种方法其实就跟 session 验证用户是否登录一样。但问题是如果用户很多，验证的效率怎么保证。所以这种方法可行，但是成本不划算。第二种就是现在大多数的做法，cookie 里面带一个 csrf_token, 每次请求的时候也带上 token ,然后只要比较两者是否相同就行了，这样服务器没存任何东西，保证了效率。当然如果你的站点有 xss 之类的漏洞，cookie 也会泄露，同样不能保证这种方案的有效性。</p>
<p>token 刷新其实可以只要登录的时候刷新下，因为除非泄露，一般情况下 token 被暴力破解的概率不大。</p>
<h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>下面看 django 如何实现的<br>django 对于 csrf 的防御主要在 middleware 实现，默认是开始 csrf 防御的，当然也可以关闭，单独对一些 view 开启，不过不建议这么做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    csrf_token = _sanitize_token(</span><br><span class="line">    request.COOKIES[settings.CSRF_COOKIE_NAME])</span><br><span class="line">    <span class="comment"># Use same token next time</span></span><br><span class="line">    request.META[<span class="string">'CSRF_COOKIE'</span>] = csrf_token</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">      csrf_token = <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>这部分取得 cookie 里面的 csrf_token, 如果不存在则生成一个新的 csrf_token</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_csrf_token = request.POST.get(<span class="string">'csrfmiddlewaretoken'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>这个是取得 post 请求的 request_csrf_token</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>对于 put delete 或者 ajax 请求来说，需要把 token 放到 headers 里面, 名字为 X-CSRFToken</p>
<p>最后只要比较 csrf_token 和 request_csrf_token 就能有效的防御 csrf</p>
<p>这里面有个特殊的地方，对于 http 来说，有可能存在中间人攻击，所以没法信任 HTTP_REFERER 这个 header ，但如果是 https, 做了下 HTTP_REFERER 的检查，只要 referer 不在信任域，一律拒绝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">referer = force_text(</span><br><span class="line">    request.META.get(<span class="string">'HTTP_REFERER'</span>),</span><br><span class="line">    strings_only=<span class="keyword">True</span>,</span><br><span class="line">    errors=<span class="string">'replace'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> referer <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">return</span> self._reject(request, REASON_NO_REFERER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Here we generate a list of all acceptable HTTP referers,</span></span><br><span class="line"><span class="comment"># including the current host since that has been validated</span></span><br><span class="line"><span class="comment"># upstream.</span></span><br><span class="line">good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)</span><br><span class="line"><span class="comment"># Note that request.get_host() includes the port.</span></span><br><span class="line">good_hosts.append(request.get_host())</span><br><span class="line">good_referers = [<span class="string">'https://&#123;0&#125;/'</span>.format(host) <span class="keyword">for</span> host <span class="keyword">in</span> good_hosts]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> any(same_origin(referer, host) <span class="keyword">for</span> host <span class="keyword">in</span> good_referers):</span><br><span class="line">    reason = REASON_BAD_REFERER % referer</span><br><span class="line">    <span class="keyword">return</span> self._reject(request, reason)</span><br></pre></td></tr></table></figure>
<p>在登录的时候需要加上 rotate_token, 来刷新 token</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_token</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Changes the CSRF token in use for a request - should be done on login</span></span><br><span class="line"><span class="string">    for security purposes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    request.META.update(&#123;</span><br><span class="line">        <span class="string">"CSRF_COOKIE_USED"</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">"CSRF_COOKIE"</span>: _get_new_csrf_key(),</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>总结下，django 框架本身对于安全性这块做的挺好的，对于工程师来说是福也是祸，能够更专注逻辑实现，但是有时候也因为忽视导致安全事故的发生。所以安全研发意识其实很重要，形成一些好的习惯，防患于未然。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/15/2016-关于技术和人生的一些碎碎念/" class="prev">上一篇</a><a href="/2016/12/05/用-python-提高效率之自如爬虫/" class="next">下一篇</a></div><div class="copyright"><p>© 2021 <a href="https://facert.github.io">facert</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>